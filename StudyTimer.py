# ==== EMBEDDED LEADERBOARD WIDGETS (Top-10 + Top-3) ====
from __future__ import annotations
from datetime import date, datetime, timezone
import os, math, random, requests
import gspread
from PIL import Image, ImageTk, ImageDraw, ImageFont, ImageFont, ImageDraw, ImageFilter, ImageChops, Image as PILImage
try:
    from oauth2client.service_account import ServiceAccountCredentials
except Exception:
    ServiceAccountCredentials = None
from tkinter import ttk
import tkinter as tk
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib, ssl
from email.utils import parsedate_to_datetime
from config_paths import app_paths
import hashlib
from pathlib import Path
from secrets_util import get_secret
import platform
from api_client import api
from token_tracker import create_token_usage_widget, set_refresh_callback
import subprocess
from cryptography.fernet import Fernet
import base64
from tkinter import Button
from secrets_util import get_encrypted_gspread_client
import json
from ai_chat_dialog import AIChatDialog 
from api_client import api
import hashlib, base64, json, os, time, threading, requests
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import platform, uuid, psutil
# Add this line at the top with your other imports
from auto_updater import add_auto_update_to_app
import tkinter as tk
import tkinter.ttk as ttk
import subprocess
import glob
import tkinter as tk
from encrypted_gspread_connection import service_account, service_account_from_encrypted
import tempfile
from cryptography.fernet import Fernet
from dotenv import load_dotenv
from Authenticator import UnifiedAuthSystem
import threading
from PIL import Image, ImageTk
import firebase_admin
from firebase_admin import credentials, db
import os, json, google.auth
import json
from secrets_util import get_secret, ONLINE, get_encrypted_gspread_client
gspread_client = get_encrypted_gspread_client()
load_dotenv()
print(f"ENCRYPTION_KEY exists: {bool(get_secret('ENCRYPTION_KEY'))}")
print(f"ENCRYPTED_CREDENTIALS exists: {bool(get_secret('ENCRYPTED_CREDENTIALS'))}")
print(f"LB_SHEET_ID: {get_secret('LB_SHEET_ID')}")
import os
os.environ["GRPC_VERBOSITY"] = "ERROR"
os.environ["GRPC_TRACE"] = ""
import sys
from ai_chat_dialog import open_ai_chat_dialog
from firebase_groups_tab import add_firebase_groups_tab
from google.cloud import secretmanager
import os
os.environ["GRPC_VERBOSITY"] = "ERROR"
os.environ["GRPC_ENABLE_FORK_SUPPORT"] = "0"
os.environ["GOOGLE_CLOUD_DISABLE_ALTS"] = "true"
os.environ["GRPC_DNS_RESOLVER"] = "native"
from token_tracker import (
    chat_complete_with_tracking,
    create_token_usage_widget,
    refresh_token_display
)
from token_manager import get_token_manager
from token_tracker import InsufficientTokensError
from purchase_dialog import show_purchase_dialog
from token_tracker import (
    create_token_usage_widget, 
    set_refresh_callback,
    chat_complete_with_tracking
)

# üëá This line replaces your old hardcoded TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = get_secret("TELEGRAM_BOT_TOKEN")



LB_CREDENTIALS = None

try:
    import win32event, win32api, winerror
    # Create a named mutex (unique app name)
    mutex = win32event.CreateMutex(None, False, "StudyTimerSingleInstance")
    if win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:
        # Another instance is already running
        import tkinter.messagebox as mb
        mb.showinfo("Study Timer", "‚ö† Study Timer is already running.")
        sys.exit(0)
except ImportError:
    # If pywin32 not available, fall back to lock file
    pass
    
load_dotenv()
# Decrypt service account (skip if offline)
encryption_key = get_secret('ENCRYPTION_KEY')
if encryption_key:
    cipher = Fernet(encryption_key.encode())
    encrypted_sa = get_secret('ENCRYPTED_SERVICE_ACCOUNT')
    
    # ADD THIS CHECK:
    if encrypted_sa:
        try:
            service_account_json = cipher.decrypt(encrypted_sa.encode()).decode()
            service_account = json.loads(service_account_json)
        except Exception as e:
            print(f"Failed to decrypt service account: {e}")
            service_account = None
            print("Running in offline mode - Firebase features disabled")
    else:
        service_account = None
        print("Running in offline mode - No encrypted service account found")
else:
    service_account = None
    print("Running in offline mode - Firebase features disabled")
    


from api_client import api

def ensure_anonymous_token():
    """Silently login if no token exists."""
    if not api.id_token:
        print("[PAYMENT] No token found ‚Äî logging in anonymously...")
        result = api.anonymous_login()
        if result.get("success") and result.get("idToken"):
            api.set_auth_token(result["idToken"])
            print("[PAYMENT] ‚úÖ Anonymous token set")
        else:
            print(f"[PAYMENT] ‚ö† Anonymous login failed: {result.get('error')}")

def get_decrypted_service_account():
    encryption_key = get_secret('ENCRYPTION_KEY')
    encrypted_sa = get_secret('ENCRYPTED_SERVICE_ACCOUNT')
    
    if not encryption_key or not encrypted_sa:
        return None
    
    cipher = Fernet(encryption_key.encode())
    service_account_json = cipher.decrypt(encrypted_sa.encode()).decode()
    return json.loads(service_account_json)


def is_system_time_valid(max_drift_minutes: int = 5):
    """Check if local system time is within an acceptable drift of server time.

    Returns (is_valid, drift_seconds). If the server time cannot be retrieved,
    the function returns (False, None) so the caller can block the payment flow.
    """
    def _get_server_time():
        # Try a lightweight HEAD request first
        response = requests.head("https://www.google.com", timeout=5)
        date_header = response.headers.get("Date")
        if date_header:
            return parsedate_to_datetime(date_header).astimezone(timezone.utc)

        # Fallback to a dedicated time API if the Date header is missing
        api_resp = requests.get("https://worldtimeapi.org/api/ip", timeout=5)
        api_resp.raise_for_status()
        data = api_resp.json()
        if "utc_datetime" in data:
            return datetime.fromisoformat(data["utc_datetime"])
        raise ValueError("No server time available")

    try:
        server_time = _get_server_time()
        local_time = datetime.utcnow().replace(tzinfo=timezone.utc)
        drift_seconds = abs((local_time - server_time).total_seconds())
        return drift_seconds <= max_drift_minutes * 60, drift_seconds
    except Exception as e:
        print(f"[TIME-CHECK] Unable to validate system time: {e}")
        return False, None

FIREBASE_DATABASE_URL = get_secret("FIREBASE_DATABASE_URL") or "https://leaderboard-98e8c-default-rtdb.asia-southeast1.firebasedatabase.app"
FIREBASE_SERVICE_ACCOUNT = get_decrypted_service_account()

# ===== Google Sheets sync (safe: writes ONLY your row) =====
# Configure via environment variables (or edit defaults below):
#   LB_CREDENTIALS: path to service account json
#   LB_SHEET_ID: spreadsheet key or full URL
#   LB_WORKSHEET: worksheet/tab name (default "Sheet1")

import os, time

LB_SHEET_ID    = get_secret("LB_SHEET_ID")
LB_WORKSHEET   = get_secret("LB_WORKSHEET") or "Sheet1"

DAILY_REPORT_STATUS_FILE = app_paths.daily_report_file


CURRENT_VERSION = "version 00.04.10.25"

# === Razorpay key bootstrap (final) ===
RAZORPAY_KEY_ID = "rzp_live_RCiAvkzn29q7AQ"  # your real Razorpay Key ID (public)
RAZORPAY_KEY_SECRET = None  # never expose secret on client
# === end bootstrap ===

APP_INSTANCE = None

# === Multi-plan save paths ===
PLANS_FILE = os.path.join(app_paths.appdata_dir, "plans.json")


def _get_exam_key_for_plans(explicit_exam_name=None):
    """
    Decide which key to use inside plans.json for this exam.
    If explicit_exam_name is given, use that; otherwise read from profile.
    Falls back to '__GLOBAL__' if exam name is empty.
    """
    try:
        if explicit_exam_name is not None:
            exam_name = (explicit_exam_name or "").strip()
        else:
            prof = _load_profile() or {}
            exam_name = (prof.get("exam_name") or "").strip()
        return exam_name or "__GLOBAL__"
    except Exception as e:
        print(f"[PLANS] Failed to determine exam key: {e}")
        return "__GLOBAL__"


def _load_plans_for_exam(exam_name=None):
    """
    Internal helper: load plans for a specific exam.
    - NEW format: { "<exam>": { "<plan_name>": [sessions...] }, ... }
    - LEGACY format: { "<plan_name>": [sessions...] }  (no exam separation)
    """
    exam_key = _get_exam_key_for_plans(exam_name)

    if not os.path.exists(PLANS_FILE):
        return {}

    try:
        with open(PLANS_FILE, "r", encoding="utf-8") as f:
            raw = json.load(f)
    except Exception as e:
        print(f"[PLANS] Error reading plans.json: {e}")
        return {}

    if not isinstance(raw, dict) or not raw:
        return {}

    # Detect NEW format: all values are dicts (per-exam containers)
    sample_val = next(iter(raw.values()))
    if isinstance(sample_val, dict):
        # Normal new-style file: pick the current exam's plans dict
        plans_for_exam = raw.get(exam_key, {})
        if isinstance(plans_for_exam, dict):
            return plans_for_exam
        return {}

    # LEGACY format: top-level is {plan_name: [sessions...]}
    # For loading we just return as-is; upgrade happens on first save.
    return raw
# === Exam date storage (per exam) ===
# We reuse app_paths.exam_date_file but store multiple exam dates inside.
EXAM_DATE_FILE = app_paths.exam_date_file


def _load_exam_date_mapping():
    """Load all exam dates from exam_date.json.

    New format:
        {
          "<Exam A>": "YYYY-MM-DD",
          "<Exam B>": "YYYY-MM-DD",
          "__GLOBAL__": "YYYY-MM-DD"   # optional legacy default
        }

    Legacy format:
        {"exam_date": "YYYY-MM-DD"}
    """
    import json, os

    if not os.path.exists(EXAM_DATE_FILE):
        return {}

    try:
        with open(EXAM_DATE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        print(f"[EXAM] Failed to read exam_date file: {e}")
        return {}

    if not isinstance(data, dict):
        return {}

    # Legacy single-date
    if "exam_date" in data and isinstance(data["exam_date"], str):
        return {"__GLOBAL__": data["exam_date"]}

    return data


def _save_exam_date_mapping(mapping):
    """Save the whole exam-date mapping."""
    import json, os

    if not isinstance(mapping, dict):
        mapping = {}

    try:
        os.makedirs(os.path.dirname(EXAM_DATE_FILE), exist_ok=True)
        with open(EXAM_DATE_FILE, "w", encoding="utf-8") as f:
            json.dump(mapping, f, indent=2)
    except Exception as e:
        print(f"[EXAM] Failed to write exam_date file: {e}")


def get_exam_date_for_exam(exam_name: str):
    """Return datetime.date for given exam_name, or None if missing."""
    from datetime import datetime

    mapping = _load_exam_date_mapping()
    exam_name = (exam_name or "").strip()

    # Exact match first
    if exam_name and exam_name in mapping:
        try:
            return datetime.fromisoformat(mapping[exam_name]).date()
        except Exception as e:
            print(f"[EXAM] Bad date format for '{exam_name}': {e}")

    # Fallback: global legacy date
    if "__GLOBAL__" in mapping:
        try:
            return datetime.fromisoformat(mapping["__GLOBAL__"]).date()
        except Exception as e:
            print(f"[EXAM] Bad global exam_date: {e}")

    return None


def set_exam_date_for_exam(exam_name: str, dt):
    """Save date dt (datetime.date) for this exam."""
    exam_name = (exam_name or "").strip() or "__GLOBAL__"
    mapping = _load_exam_date_mapping()
    mapping[exam_name] = dt.isoformat()
    _save_exam_date_mapping(mapping)

def load_all_plans():
    """Load all saved plans for the *current* exam from JSON file."""
    return _load_plans_for_exam(None)


def save_all_plans(plans):
    """
    Save plans for the *current* exam back to JSON file.

    NEW format on disk:
        {
            "<exam A>": { "<plan_name>": [ ...sessions... ], ... },
            "<exam B>": { ... }
        }

    If an old one-level structure is found, it is migrated so that the
    existing data is stored under the *current* exam key.
    """
    os.makedirs(app_paths.appdata_dir, exist_ok=True)
    exam_key = _get_exam_key_for_plans(None)

    data = {}
    if os.path.exists(PLANS_FILE):
        try:
            with open(PLANS_FILE, "r", encoding="utf-8") as f:
                raw = json.load(f)
            if isinstance(raw, dict):
                data = raw
        except Exception as e:
            print(f"[PLANS] Error loading existing plans.json for save: {e}")
            data = {}

    # If existing data is LEGACY ({plan_name: [...]}) convert to NEW format
    if data:
        sample_val = next(iter(data.values()))
        if not isinstance(sample_val, dict):
            # Treat legacy data as belonging to the current exam
            data = {exam_key: data}
    else:
        data = {}

    # Update current exam's plans
    data[exam_key] = plans

    try:
        with open(PLANS_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
        print(f"[PLANS] Saved plans for exam '{exam_key}' with {len(plans)} plan(s)")
    except Exception as e:
        print(f"[PLANS] Error writing plans.json: {e}")

def get_all_exam_names():
    """
    Return list of all exam names that have plans in plans.json.
    New format:
        { "<exam>": { "<plan_name>": [...] }, ... }
    Legacy flat format is treated as a single exam "__GLOBAL__".
    """
    if not os.path.exists(PLANS_FILE):
        return []

    try:
        with open(PLANS_FILE, "r", encoding="utf-8") as f:
            raw = json.load(f)
    except Exception as e:
        print(f"[PLANS] Error reading plans.json for exam list: {e}")
        return []

    if not isinstance(raw, dict) or not raw:
        return []

    sample_val = next(iter(raw.values()))
    if isinstance(sample_val, dict):
        # New multi-exam structure
        return list(raw.keys())

    # Legacy: flat plan dict
    return ["__GLOBAL__"]


import tkinter.messagebox as mb

LOCKFILE = os.path.join(tempfile.gettempdir(), "studytimer.lock")

def is_already_running():
    return os.path.exists(LOCKFILE)

def create_lock():
    with open(LOCKFILE, "w") as f:
        f.write(str(os.getpid()))

def remove_lock():
    if os.path.exists(LOCKFILE):
        os.remove(LOCKFILE)

def run_app():
    global APP_INSTANCE
    if is_already_running():
        mb.showinfo("Study Timer", "‚ö† Study Timer is already running.")
        sys.exit(0)

    create_lock()
    root = tk.Tk()
    APP_INSTANCE = StudyTimerApp(root)

    # remove lock when window closes
    root.protocol("WM_DELETE_WINDOW", lambda: (remove_lock(), root.destroy()))
    root.mainloop()

import threading
def send_telegram_message(text, chat_id=None):
    """Send a message to the linked Telegram account (if connected)."""
    from api_client import api  # ‚úÖ Added import
    
    if chat_id is None:
        prof = _load_profile()
        chat_id = prof.get("telegram_chat_id")
    
    if not chat_id:
        print("[Telegram] No chat ID linked yet.")
        return False
    
    try:
        result = api.send_telegram(text, chat_id=chat_id)  # ‚úÖ Replaced direct API call
        if result.get('success'):
            print(f"[Telegram] Message sent successfully")
            return True
        else:
            print(f"[Telegram] Failed: {result.get('error')}")
            return False
    except Exception as e:
        print(f"[Telegram] Error: {e}")
        return False



# Fix the decimal_hours_to_hhmm function as well:
def decimal_hours_to_hhmm(decimal_hours):
    """
    Convert decimal hours to HH:MM format correctly
    
    Examples:
    2.17 hours = 2 hours + 0.17 hours
    0.17 hours = 0.17 √ó 60 = 10.2 minutes = 10 minutes
    Result: 02:10
    """
    try:
        decimal_hours = float(decimal_hours)
        
        # Get whole hours
        hours = int(decimal_hours)
        
        # Get fractional part and convert to minutes
        fractional_hours = decimal_hours - hours
        minutes = int(round(fractional_hours * 60))  # Convert fraction to minutes
        
        # Handle edge case where rounding gives 60 minutes
        if minutes >= 60:
            hours += 1
            minutes = 0
            
        return f"{hours:02d}:{minutes:02d}"
        
    except Exception as e:
        print(f"Error converting {decimal_hours}: {e}")
        return "00:00"

# Also fix the convert_today_hours_fallback function:
def convert_today_hours_fallback(today_hours):
    """Fallback conversion for Today Hours column with CORRECT logic"""
    try:
        decimal_hours = float(today_hours)
        
        # Get whole hours
        hours = int(decimal_hours)
        
        # Get fractional part and convert to minutes
        fractional_hours = decimal_hours - hours
        minutes = int(round(fractional_hours * 60))
        
        # Handle edge case where rounding gives 60 minutes
        if minutes >= 60:
            hours += 1
            minutes = 0
            
        return f"{hours:02d}:{minutes:02d}"
    except:
        return "00:00"

# Try local JSON config if env vars missing
def _load_gsync_local():
    try:
        import json, os
        if os.path.exists(app_paths.gsync_config_file):
            with open(app_paths.gsync_config_file, 'r', encoding='utf-8') as f:
                return json.load(f) or {}
    except Exception:
        return {}
    return {}
    
_cfg = _load_gsync_local()
if not LB_CREDENTIALS and _cfg.get('credentials'):
    LB_CREDENTIALS = _cfg['credentials']
if not LB_SHEET_ID and _cfg.get('sheet'):
    LB_SHEET_ID = _cfg['sheet']
if _cfg.get('worksheet'):
    LB_WORKSHEET = _cfg['worksheet']
# Fallback: read local gsync.json if env vars are not set
try:
    if (not LB_CREDENTIALS or not LB_SHEET_ID):
        with open("gsync.json","r",encoding="utf-8") as _f:
            _g = json.load(_f)
            LB_CREDENTIALS = _g.get("credentials", LB_CREDENTIALS)
            LB_SHEET_ID    = _g.get("sheet_id", LB_SHEET_ID)
            LB_WORKSHEET   = _g.get("worksheet", LB_WORKSHEET)
except Exception:
    pass

def _col_letter(idx0: int) -> str:
    s = ""; idx = idx0 + 1
    while idx:
        idx, rem = divmod(idx-1, 26)
        s = chr(65 + rem) + s
    return s
    
def get_sheet_id():
    """Return the Google Sheet ID from env or secret (with fallback)."""
    # 1. Check environment variable
    sheet_id = os.environ.get("LB_SHEET_ID")
    if sheet_id:
        return sheet_id

    # 2. Try secret manager
    from secrets_util import get_secret
    sheet_id = get_secret("LB_SHEET_ID")
    if sheet_id:
        return sheet_id

    # 3. Fallback (optional) - hardcoded ID or cached file
    fallback_id = "1qJugcDLdCYtKk2q5rDc9p9cRQT_4S8kicKO_Ow5lQZo"
    if fallback_id:
        print("[REFERRAL] Using fallback Sheet ID")
        return fallback_id

    # 4. If nothing found
    raise RuntimeError("‚ùå Missing LB_SHEET_ID environment variable or secret")

# Updated ReferralSystem class with UPI, Telegram notifications, and subscription requirements

import tkinter as tk
from tkinter import messagebox, simpledialog, ttk
import json
import os
import uuid
import random
import string
import hashlib
import platform
import subprocess
import requests
import threading
from datetime import datetime
import gspread
from google.oauth2.service_account import Credentials
from cryptography.fernet import Fernet
from dotenv import load_dotenv
import re
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart


class ReferralSystem:
    def __init__(self, main_app):
        from api_client import api  # ‚úÖ Add import at the top of file (if not already)

        self.main_app = main_app
        load_dotenv()
        self.referral_sheet_id = get_sheet_id()
        self.referral_worksheet = get_secret("REFERRAL_WORKSHEET") or "referral_program"
        self.updates_worksheet = get_secret("UPDATES_WORKSHEET") or "Updates"
        self.app_download_url = None
        self.referral_link = None
        self.user_referral_id = None
        
        self.referral_window = None
        
        # OTP Email settings
        self.smtp_server = get_secret("SMTP_SERVER") or "smtp.gmail.com"
        self.smtp_port = int(get_secret("SMTP_PORT") or "587")
        self.email_user = get_secret("EMAIL_USER") or "studytimerpro@gmail.com"
        self.email_password = get_secret("EMAIL_PASSWORD")

        # ‚úÖ Telegram bot token no longer stored locally
        # Backend handles Telegram credentials now.

        
    def check_subscription_status(self):
        """Check if user is a subscriber by checking UserRecords sheet or local cache."""
        try:
            # Local cache path
            cache_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'subscription_status.json')

            # Machine fingerprint
            machine_fp = self.generate_machine_fingerprint()

            # 1Ô∏è‚É£ Try local cache first
            if os.path.exists(cache_path):
                try:
                    with open(cache_path, 'r') as f:
                        cache = json.load(f)
                    if cache.get('fingerprint') == machine_fp:
                        print(f"[SUBSCRIPTION] Using cached status: {cache['status']}")
                        return cache['status'] == 'active'
                except:
                    pass

            # 2Ô∏è‚É£ No cache or mismatch ‚Üí try online check
            client = get_encrypted_gspread_client()
            if not client:
                print("[SUBSCRIPTION] Offline & no cache found ‚Äî fallback to allowing access")
                return True  # or False if you want to block instead

            sheet = client.open_by_key(self.referral_sheet_id)
            try:
                user_records = sheet.worksheet("UserRecords")
            except:
                print("[SUBSCRIPTION] UserRecords sheet not found")
                return True

            all_records = user_records.get_all_values()
            if not all_records or len(all_records) < 2:
                print("[SUBSCRIPTION] No data in UserRecords")
                return True

            status_col_index = 3
            user_uid = None
            profile_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'profile.json')
            if os.path.exists(profile_path):
                with open(profile_path, 'r') as f:
                    profile = json.load(f)
                    user_uid = profile.get('uid')

            for row in all_records[1:]:
                if len(row) > status_col_index:
                    row_str = ' '.join(str(cell) for cell in row)
                    if machine_fp in row_str or (user_uid and user_uid in row_str):
                        status = row[status_col_index].strip().lower()
                        print(f"[SUBSCRIPTION] Found user, status: {status}")

                        # üíæ Save cache for next offline launch
                        with open(cache_path, 'w') as f:
                            json.dump({'fingerprint': machine_fp, 'status': status}, f)

                        return status == 'active'

            print("[SUBSCRIPTION] User not found in sheet")
            return False

        except Exception as e:
            print(f"[SUBSCRIPTION] Error checking status: {e}")
            return True  # or False if you want to restrict
    
    def get_encrypted_gspread_client(self):
        """Get gspread client using encrypted credentials"""
        if self.gspread_client:
            return self.gspread_client
            
        try:
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if encryption_key and encrypted_creds:
                fernet = Fernet(encryption_key.encode())
                decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
                creds_dict = json.loads(decrypted_creds)
                
                
                return self.gspread_client
            else:
                return None
                
        except Exception as e:
            print(f"‚ö† [REFERRAL] Failed to use encrypted credentials: {e}")
            return None
    
    def generate_machine_fingerprint(self):
        """Generate a unique machine fingerprint"""
        try:
            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
            hostname = platform.node()
            fingerprint_data = f"{system_info}-{hostname}"
            fingerprint = hashlib.md5(fingerprint_data.encode()).hexdigest()[:16]
            return fingerprint
        except Exception as e:
            return str(uuid.uuid4())[:16]
    
    def generate_otp(self):
        """Generate a 6-digit OTP"""
        return ''.join(random.choices(string.digits, k=6))
    
    def is_email(self, contact):
        """Check if contact is email or phone"""
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(email_pattern, contact) is not None
    
    def is_valid_upi(self, upi_id):
        """Validate UPI ID format"""
        upi_pattern = r'^[a-zA-Z0-9.\-_]{3,}@[a-zA-Z]{3,}$'
        return re.match(upi_pattern, upi_id) is not None
    
    def send_email_otp(self, email, otp):
        """Send OTP via email using simple SMTP"""
        try:
            if not self.email_user or not self.email_password:
                return False
            
            subject = "StudyTimer - Referral Program OTP"
            body = f"""Hi there!

Your OTP for StudyTimer Referral Program is: {otp}

This OTP is valid for 5 minutes only.

Best regards,
StudyTimer Team
"""
            
            msg = MIMEMultipart()
            msg['From'] = self.email_user
            msg['To'] = email
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.email_user, self.email_password)
            server.send_message(msg)
            server.quit()
            
            print(f"Email OTP sent successfully to {email}")
            return True
            
        except Exception as e:
            print(f"Email sending error: {e}")
            return False
    
    def send_otp(self, contact, otp):
        """Send OTP via email only"""
        if self.is_email(contact):
            if self.send_email_otp(contact, otp):
                return True
            else:
                messagebox.showerror("Error", "Failed to send email OTP. Please check your email configuration.")
                return False
        else:
            messagebox.showwarning("Email Only", 
                                 "SMS service is not available. Please use your email address instead.")
            return False
    
    def get_current_download_link(self):
        """Fetch the current download link from updates sheet B column last row"""
        try:
            worksheet = self.get_google_sheet_by_name(self.updates_worksheet)
            if not worksheet:
                return None
            
            b_column_values = worksheet.col_values(2)
            if not b_column_values:
                return None
            
            download_link = None
            for value in reversed(b_column_values):
                if value and value.strip():
                    download_link = value.strip()
                    break
            
            return download_link
            
        except Exception as e:
            print(f"Error fetching download link: {e}")
            return None
    
    def get_google_sheet_by_name(self, worksheet_name):
        """Get a specific worksheet by name"""
        try:
            client = get_encrypted_gspread_client()
            if not client:
                return None
            
            sheet = client.open_by_key(self.referral_sheet_id)
            worksheet = sheet.worksheet(worksheet_name)
            return worksheet
                
        except Exception as e:
            print(f"Error connecting to worksheet '{worksheet_name}': {e}")
            return None
    
    def get_google_sheet(self):
        """Get Google Sheet connection for referral program with updated columns"""
        try:
            client = get_encrypted_gspread_client()
            if not client:
                return None
            
            sheet = client.open_by_key(self.referral_sheet_id)
            
            try:
                worksheet = sheet.worksheet(self.referral_worksheet)
                
                # Check if we need to add new columns
                headers = worksheet.row_values(1)
                expected_headers = [
                    "UID", "Username", "Machine_Fingerprint", "Contact", "Referral_ID", 
                    "Referral_Link", "Date_Joined", "Referrals_Count", "Referred_Users", 
                    "Status", "UPI_ID", "Telegram_ID", "Install_Count", "Installed_Users",
                    "Subscription_Count", "Subscribed_Users", "Total_Earnings", "Paid_Amount"
                ]
                
                # Update headers if needed
                if len(headers) < len(expected_headers):
                    worksheet.update(f"A1:{chr(65 + len(expected_headers) - 1)}1", [expected_headers])
                    
            except gspread.WorksheetNotFound:
                worksheet = sheet.add_worksheet(title=self.referral_worksheet, rows="1000", cols="20")
                headers = [
                    "UID", "Username", "Machine_Fingerprint", "Contact", "Referral_ID", 
                    "Referral_Link", "Date_Joined", "Referrals_Count", "Referred_Users", 
                    "Status", "UPI_ID", "Telegram_ID", "Install_Count", "Installed_Users",
                    "Subscription_Count", "Subscribed_Users", "Total_Earnings", "Paid_Amount"
                ]
                worksheet.append_row(headers)
            
            return worksheet
            
        except Exception as e:
            print(f"Error connecting to Google Sheet: {e}")
            return None
    
    def generate_referral_id(self, username):
        """Generate a unique referral ID"""
        timestamp = str(int(datetime.now().timestamp()))
        base_id = f"{username.upper()[:3]}{timestamp[-6:]}"
        return base_id
    
    def create_referral_link(self, referral_id):
        """Create a referral link using the current download URL from updates sheet"""
        current_download_url = self.get_current_download_link()
        
        if not current_download_url:
            return None
        
        self.app_download_url = current_download_url
        
        if "?" in current_download_url:
            referral_link = f"{current_download_url}&ref={referral_id}"
        else:
            referral_link = f"{current_download_url}?ref={referral_id}"
        
        return referral_link
    
    def add_to_referral_sheet(self, user_data):
        """Add user to referral program sheet with UPI and Telegram ID"""
        try:
            worksheet = self.get_google_sheet()
            if not worksheet:
                return False
            
            # Check if user already exists
            try:
                uid_col = worksheet.col_values(1)
                if user_data["uid"] in uid_col:
                    row_index = uid_col.index(user_data["uid"]) + 1
                    existing_data = worksheet.row_values(row_index)
                    if len(existing_data) >= 6:
                        self.referral_link = existing_data[5]
                        self.user_referral_id = existing_data[4]
                        
                        # Update UPI and Telegram if provided
                        if user_data.get("upi_id"):
                            worksheet.update_cell(row_index, 11, user_data["upi_id"])
                        if user_data.get("telegram_id"):
                            worksheet.update_cell(row_index, 12, user_data["telegram_id"])
                        
                        return True
                    return False
            except:
                pass
            
            # Generate referral ID and link
            referral_id = self.generate_referral_id(user_data["username"])
            referral_link = self.create_referral_link(referral_id)
            
            if not referral_link:
                return False
            
            # Prepare row data with all columns
            row_data = [
                user_data["uid"],
                user_data["username"],
                user_data["machine_fingerprint"],
                user_data["contact"],
                referral_id,
                referral_link,
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "0",  # Referrals_Count
                "",   # Referred_Users
                "Active",
                user_data.get("upi_id", ""),  # UPI_ID
                user_data.get("telegram_id", ""),  # Telegram_ID
                "0",  # Install_Count
                "",   # Installed_Users
                "0",  # Subscription_Count
                "",   # Subscribed_Users
                "0",  # Total_Earnings
                "0"   # Paid_Amount
            ]
            
            worksheet.append_row(row_data)
            self.referral_link = referral_link
            self.user_referral_id = referral_id
            
            return True
            
        except Exception as e:
            print(f"Error adding to referral sheet: {e}")
            return False
    
    def show_loading(self, parent, message="Loading..."):
        """Show loading indicator"""
        loading_frame = tk.Frame(parent, bg="#f0f0f0")
        loading_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        spinner = ttk.Progressbar(loading_frame, mode='indeterminate')
        spinner.pack(pady=10)
        spinner.start()
        
        loading_label = tk.Label(loading_frame, text=message, 
                               font=("Arial", 10), bg="#f0f0f0")
        loading_label.pack(pady=5)
        
        parent.update()
        return loading_frame, spinner
    
    def hide_loading(self, loading_frame, spinner):
        """Hide loading indicator"""
        spinner.stop()
        loading_frame.destroy()
    
    def create_unified_referral_window(self):
        """Create referral window - subscription check moved to registration step"""
        if self.referral_window and self.referral_window.winfo_exists():
            self.referral_window.lift()
            return
        
        self.referral_window = tk.Toplevel(self.main_app)
        self.referral_window.title("StudyTimer Referral Program - Earn Money!")
        self.referral_window.geometry("650x700")
        self.referral_window.resizable(False, False)
        self.referral_window.grab_set()
        
        # Center the window
        self.referral_window.transient(self.main_app)
        x = self.main_app.winfo_rootx() + (self.main_app.winfo_width() // 2) - 325
        y = self.main_app.winfo_rooty() + (self.main_app.winfo_height() // 2) - 350
        self.referral_window.geometry(f"650x700+{x}+{y}")
        
        # Main container
        self.main_container = tk.Frame(self.referral_window, bg="white")
        self.main_container.pack(fill="both", expand=True)
        
        # Header
        header_frame = tk.Frame(self.main_container, bg="#FF9800", height=80)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üí∞ Earn Money with Referrals! üí∞", 
                font=("Arial", 18, "bold"), bg="#FF9800", fg="white").pack(expand=True)
        
        # Content area
        self.content_frame = tk.Frame(self.main_container, bg="white")
        self.content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Start with rewards info - available to all users
        self.show_rewards_info()
    
    def show_rewards_info(self):
        """Show referral rewards information"""
        self.clear_content()
        
        # Create scrollable frame
        canvas = tk.Canvas(self.content_frame, bg="white")
        scrollbar = ttk.Scrollbar(self.content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="white")
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        tk.Label(scrollable_frame, text="How to Earn with StudyTimer Referral Program", 
                font=("Arial", 14, "bold"), bg="white").pack(pady=15)
        
        # Rewards section
        rewards_frame = tk.Frame(scrollable_frame, bg="#f8f9fa", relief="ridge", bd=1, pady=15, padx=15)
        rewards_frame.pack(fill="x", pady=10, padx=10)
        
        tk.Label(rewards_frame, text="üéØ Your Earning Potential:", 
                font=("Arial", 12, "bold"), bg="#f8f9fa").pack(anchor="w", pady=5)
        
        rewards = [
            ("üì± Per Install:", "‚Çπ10", "When someone installs using your code"),
            ("üíé Per Subscription:", "‚Çπ50", "When they subscribe to Pro"),
            ("üí∞ Total per User:", "‚Çπ60", "Maximum earnings per referral")
        ]
        
        for title, amount, desc in rewards:
            reward_row = tk.Frame(rewards_frame, bg="#f8f9fa")
            reward_row.pack(fill="x", pady=3)
            
            tk.Label(reward_row, text=title, font=("Arial", 10, "bold"), 
                    bg="#f8f9fa", width=20, anchor="w").pack(side="left")
            tk.Label(reward_row, text=amount, font=("Arial", 11, "bold"), 
                    bg="#f8f9fa", fg="#4CAF50", width=10).pack(side="left")
            tk.Label(reward_row, text=desc, font=("Arial", 9), 
                    bg="#f8f9fa", fg="#666").pack(side="left")
        
        # Payment info
        payment_frame = tk.Frame(scrollable_frame, bg="#e8f5e9", relief="ridge", bd=1, pady=15, padx=15)
        payment_frame.pack(fill="x", pady=10, padx=10)
        
        tk.Label(payment_frame, text="üí≥ Payment Details:", 
                font=("Arial", 12, "bold"), bg="#e8f5e9").pack(anchor="w", pady=5)
        
        payment_info = [
            "‚úÖ Payments processed within 24 business hours",
            "‚úÖ Direct transfer to your UPI ID",
            "‚úÖ Instant notifications for each referral",
            "‚úÖ Track your earnings in real-time"
        ]
        
        for info in payment_info:
            tk.Label(payment_frame, text=info, font=("Arial", 10), 
                    bg="#e8f5e9", justify="left").pack(anchor="w", pady=2)
        
        # Requirements
        req_frame = tk.Frame(scrollable_frame, bg="#fff3e0", relief="ridge", bd=1, pady=15, padx=15)
        req_frame.pack(fill="x", pady=10, padx=10)
        
        tk.Label(req_frame, text="üìã Requirements:", 
                font=("Arial", 12, "bold"), bg="#fff3e0").pack(anchor="w", pady=5)
        
        requirements = [
            "‚Ä¢ Valid UPI ID for receiving payments",
            "‚Ä¢ Email address for notifications",
            "‚Ä¢ Optional: Telegram for instant alerts",
            "‚Ä¢ Active StudyTimer Pro subscription"
        ]
        
        for req in requirements:
            tk.Label(req_frame, text=req, font=("Arial", 10), 
                    bg="#fff3e0", justify="left").pack(anchor="w", pady=2)
        
        # Button frame at bottom
        button_frame = tk.Frame(scrollable_frame, bg="white")
        button_frame.pack(pady=20)
        
        # Continue button - make it more prominent
        continue_btn = tk.Button(button_frame, text="Continue to Registration ‚Üí", 
                                command=self.show_registration_form,
                                font=("Arial", 13, "bold"), bg="#4CAF50", fg="white",
                                width=30, height=2, cursor="hand2", bd=2, relief="raised")
        continue_btn.pack(pady=10)
        
        # Cancel button
        cancel_btn = tk.Button(button_frame, text="Cancel", 
                              command=self.referral_window.destroy,
                              font=("Arial", 11), bg="#757575", fg="white",
                              width=20, height=1, cursor="hand2")
        cancel_btn.pack(pady=5)
        
        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def show_registration_form(self):
        """Show registration form with UPI and Telegram - now with subscription check"""
        # Check subscription status here, after they've read the instructions
        if not self.check_subscription_status():
            self.clear_content()
            
            # Show subscription required message
            tk.Label(self.content_frame, text="‚ö† Subscription Required", 
                    font=("Arial", 16, "bold"), bg="white", fg="#FF5722").pack(pady=20)
            
            info_frame = tk.Frame(self.content_frame, bg="#fff3e0", relief="ridge", bd=1, pady=20, padx=20)
            info_frame.pack(fill="x", pady=20)

            tk.Label(info_frame, text="To join the referral program, you need an active subscription.", 
                    font=("Arial", 11), bg="#fff3e0").pack(pady=5)

            tk.Label(info_frame, text="Your current status: Inactive/Not Found", 
                    font=("Arial", 11, "bold"), bg="#fff3e0", fg="#FF5722").pack(pady=5)

            tk.Label(info_frame, text="Please ensure:\n‚Ä¢ You have completed payment\n‚Ä¢ Your subscription is active\n‚Ä¢ Status shows 'Active' in our records", 
                    font=("Arial", 10), bg="#fff3e0", justify="left").pack(pady=10)

            # Button frame to hold both buttons side by side
            button_frame = tk.Frame(self.content_frame, bg="white")
            button_frame.pack(pady=20)

            # Back button (left)
            tk.Button(button_frame, text="Back", 
                     command=self.show_rewards_info,
                     font=("Arial", 12, "bold"), bg="#757575", fg="white",
                     width=15, height=2, cursor="hand2").pack(side="left", padx=5)

            # Subscribe Now button (right)
            tk.Button(button_frame, text="Subscribe Now", 
                     command=lambda: self.main_app._show_payment_wizard(),
                     font=("Arial", 12, "bold"), bg="#4CAF50", fg="white",
                     width=15, height=2, cursor="hand2").pack(side="left", padx=5)

            return
        
        # Check if user is already registered in referral program
        machine_fp = self.generate_machine_fingerprint()
        try:
            worksheet = self.get_google_sheet()
            if worksheet:
                all_records = worksheet.get_all_values()
                
                # Check if user already exists (Machine_Fingerprint is in column C - index 2)
                for i, row in enumerate(all_records[1:], start=2):  # Skip header, start from row 2
                    if len(row) > 2 and row[2] == machine_fp:  # Column C contains Machine_Fingerprint
                        # User already registered - show their existing details
                        self.show_already_registered_panel(row)
                        return
        except Exception as e:
            print(f"Error checking existing registration: {e}")
            # Continue to show registration form if check fails
        
        # If subscription is active and user not already registered, show the registration form
        self.clear_content()
        
        tk.Label(self.content_frame, text="Register for Referral Program", 
                font=("Arial", 14, "bold"), bg="white").pack(pady=10)
        
        # Form frame
        form_frame = tk.Frame(self.content_frame, bg="white")
        form_frame.pack(pady=5)
        
        # Email
        tk.Label(form_frame, text="Email Address*:", 
                font=("Arial", 11, "bold"), bg="white").grid(row=0, column=0, sticky="w", pady=3)
        self.email_var = tk.StringVar()
        email_entry = tk.Entry(form_frame, textvariable=self.email_var, 
                              font=("Arial", 11), width=30, bd=2, relief="groove")
        email_entry.grid(row=0, column=1, padx=10, pady=3)
        
        # UPI ID
        tk.Label(form_frame, text="UPI ID*:", 
                font=("Arial", 11, "bold"), bg="white").grid(row=1, column=0, sticky="w", pady=3)
        self.upi_var = tk.StringVar()
        upi_entry = tk.Entry(form_frame, textvariable=self.upi_var, 
                           font=("Arial", 11), width=30, bd=2, relief="groove")
        upi_entry.grid(row=1, column=1, padx=10, pady=3)
        tk.Label(form_frame, text="(e.g., yourname@paytm, 9876543210@ybl)", 
                font=("Arial", 9), bg="white", fg="#666").grid(row=2, column=1, sticky="w", padx=10)
        
        # Telegram ID (optional)
        tk.Label(form_frame, text="Telegram Username:", 
                font=("Arial", 11), bg="white").grid(row=3, column=0, sticky="w", pady=3)
        self.telegram_var = tk.StringVar()
        telegram_entry = tk.Entry(form_frame, textvariable=self.telegram_var, 
                                 font=("Arial", 11), width=30, bd=2, relief="groove")
        telegram_entry.grid(row=3, column=1, padx=10, pady=3)
        tk.Label(form_frame, text="(Optional - for instant notifications)", 
                font=("Arial", 9), bg="white", fg="#666").grid(row=4, column=1, sticky="w", padx=10)
        
        # Terms & Conditions Section
        terms_container = tk.Frame(self.content_frame, bg="white")
        terms_container.pack(pady=8, padx=20, fill="both")
        
        # Terms header
        tk.Label(terms_container, text="Referral Program Terms & Conditions", 
                font=("Arial", 10, "bold"), bg="white", fg="#333").pack(anchor="w", pady=(0, 3))
        
        # Scrollable terms frame with both scrollbars
        terms_frame = tk.Frame(terms_container, bg="#f9f9f9", relief="solid", bd=1)
        terms_frame.pack(fill="both", expand=True)
        
        # Create canvas with both scrollbars
        canvas = tk.Canvas(terms_frame, bg="#f9f9f9", height=220, highlightthickness=0)
        v_scrollbar = tk.Scrollbar(terms_frame, orient="vertical", command=canvas.yview)
        h_scrollbar = tk.Scrollbar(terms_frame, orient="horizontal", command=canvas.xview)
        scrollable_frame = tk.Frame(canvas, bg="#f9f9f9")
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Terms text content
        terms_text = """
    1. ELIGIBILITY
    The Program is open only to active paid subscribers of StudyTimerPro. Participants must be at least 18 years of age and have a valid UPI ID in India for reward payments. Accounts found to be in violation of StudyTimerPro's general Terms of Use may be disqualified.

    2. HOW THE PROGRAM WORKS
    Each subscriber will receive a unique referral link or code. A referral is considered valid only when: (1) A new user installs StudyTimerPro using your referral link/code (reward: ‚Çπ10), and (2) A referred user purchases a valid subscription (reward: ‚Çπ50). Rewards are credited after successful verification by our team. Only genuine referrals are eligible. Fraudulent or duplicate installs/subscriptions will not qualify.

    3. REWARDS & PAYOUTS
    Rewards: ‚Çπ10 per valid install and ‚Çπ50 per valid subscription. Payments will be made through UPI to the participant's provided UPI ID. Rewards are non-transferable, non-refundable, and cannot be exchanged for other benefits.

    4. RESTRICTIONS
    Participants may not: refer themselves, use multiple fake accounts, or attempt fraudulent installs/subscriptions; share referral codes through spam, misleading promotions, or paid ads; sell or trade referral codes outside of this Program. StudyTimerPro reserves the right to withhold or cancel rewards for suspected misuse.

    5. NON-REFUND POLICY
    Subscription fees paid by users are non-refundable under this Program. Referral rewards once paid are considered final and non-reversible.

    6. PROGRAM CHANGES & TERMINATION
    StudyTimerPro reserves the right to modify, suspend, or terminate this Program at any time without prior notice. Rewards earned before termination will be honored unless found to be fraudulent.

    7. LIMITATION OF LIABILITY
    We are not responsible for: delays in payments due to incorrect UPI details; technical issues, failed installs, or failed subscriptions caused by third-party platforms. Our liability is limited to the amount of verified rewards earned by a participant.

    8. PRIVACY
    By joining the Program, you consent to the use of your data for processing rewards in line with our Privacy Policy. Participants will not receive personal details of referred users.

    9. GOVERNING LAW
    These Terms are governed by the laws of India. Any disputes shall be subject to the jurisdiction of courts.

    10. ACCEPTANCE
    By participating in the StudyTimerPro Referral Program, you confirm that you have read, understood, and agree to these Terms & Conditions.
        """
        
        # Add terms text without wraplength to allow horizontal scrolling
        tk.Label(scrollable_frame, text=terms_text.strip(), 
                font=("Arial", 8), bg="#f9f9f9", fg="#555", 
                justify="left", anchor="w").pack(padx=10, pady=8)
        
        # Pack canvas and scrollbars
        h_scrollbar.pack(side="bottom", fill="x")
        v_scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        
        # Agreement checkbox
        self.agree_var = tk.BooleanVar()
        agree_frame = tk.Frame(self.content_frame, bg="white")
        agree_frame.pack(pady=5)
        
        tk.Checkbutton(agree_frame, text="I have read and agree to the Referral Program Terms & Conditions", 
                      variable=self.agree_var, bg="white", 
                      font=("Arial", 9, "bold")).pack(side="left")
        
        # Buttons
        button_frame = tk.Frame(self.content_frame, bg="white")
        button_frame.pack(pady=10)
        
        tk.Button(button_frame, text="Send OTP", 
                 command=self.handle_registration_submit,
                 font=("Arial", 12, "bold"), bg="#FF9800", fg="white",
                 width=15, height=2, cursor="hand2").pack(side="left", padx=10)
        
        tk.Button(button_frame, text="Back", 
                 command=self.show_rewards_info,
                 font=("Arial", 12, "bold"), bg="#757575", fg="white",
                 width=15, height=2, cursor="hand2").pack(side="left", padx=10)

    def show_already_registered_panel(self, user_row):
        """Show panel for users who are already registered"""
        self.clear_content()
        
        # Extract user details from the row based on your column structure:
        # A=UID(0), B=Username(1), C=Machine_Fingerprint(2), D=Contact(3), E=Referral_ID(4), 
        # F=Referral_Link(5), G=Date_Joined(6), H=Referrals_Count(7), I=Referred_Users(8), 
        # J=Status(9), K=UPI_ID(10), L=Telegram_ID(11), M=Install_Count(12), N=Installed_Users(13),
        # O=Subscription_Count(14), P=Subscribed_Users(15), Q=Total_Earnings(16), R=Paid_Amount(17)
        
        referral_id = user_row[4] if len(user_row) > 4 else "N/A"  # Column E - Referral_ID
        referral_link = user_row[5] if len(user_row) > 5 else "N/A"  # Column F - Referral_Link
        upi_id = user_row[10] if len(user_row) > 10 else "N/A"  # Column K - UPI_ID
        telegram_id = user_row[11] if len(user_row) > 11 else ""  # Column L - Telegram_ID
        total_earnings = user_row[16] if len(user_row) > 16 else "‚Çπ0"  # Column Q - Total_Earnings
        referrals_count = user_row[7] if len(user_row) > 7 else "0"  # Column H - Referrals_Count
        
        # Already registered header
        tk.Label(self.content_frame, text="‚úÖ Already Registered!", 
                font=("Arial", 16, "bold"), bg="white", fg="#4CAF50").pack(pady=20)
        
        tk.Label(self.content_frame, text="You're already part of our referral program!", 
                font=("Arial", 12), bg="white", fg="#666").pack(pady=5)
        
        # Referral details frame
        details_frame = tk.Frame(self.content_frame, bg="#f8f9fa", relief="ridge", bd=1)
        details_frame.pack(fill="x", pady=20, padx=20)
        
        tk.Label(details_frame, text="Your Referral Details", 
                font=("Arial", 12, "bold"), bg="#f8f9fa").pack(pady=10)
        
        tk.Label(details_frame, text=f"Referral ID: {referral_id}", 
                font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        tk.Label(details_frame, text=f"UPI ID: {upi_id}", 
                font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        if telegram_id:
            tk.Label(details_frame, text=f"Telegram: {telegram_id}", 
                    font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        tk.Label(details_frame, text=f"Total Referrals: {referrals_count}", 
                font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        tk.Label(details_frame, text=f"Total Earnings: {total_earnings}", 
                font=("Arial", 10, "bold"), bg="#f8f9fa", fg="#4CAF50").pack(pady=2)
        
        # Earnings reminder
        earnings_frame = tk.Frame(self.content_frame, bg="#e8f5e9", relief="ridge", bd=1)
        earnings_frame.pack(fill="x", pady=10, padx=20)
        
        tk.Label(earnings_frame, text="üí∞ Keep Earning!", 
                font=("Arial", 11, "bold"), bg="#e8f5e9").pack(pady=5)
        
        tk.Label(earnings_frame, text="Continue sharing your referral link to earn:", 
                font=("Arial", 10), bg="#e8f5e9").pack()
        
        tk.Label(earnings_frame, text="‚Çπ10 per install + ‚Çπ50 per subscription", 
                font=("Arial", 11, "bold"), bg="#e8f5e9", fg="#4CAF50").pack(pady=5)
        
        # Share message
        message_frame = tk.Frame(self.content_frame, bg="white")
        message_frame.pack(fill="x", pady=10, padx=20)
        
        tk.Label(message_frame, text="Share this message:", 
                font=("Arial", 11, "bold"), bg="white").pack(anchor="w")
        
        share_text = tk.Text(message_frame, height=5, font=("Arial", 9), wrap="word",
                           bg="#f8f9fa", bd=1, relief="solid")
        share_text.pack(fill="x", pady=5)
        
        share_message = f"""üéì Join me on StudyTimer - The best study companion!

    Download: {referral_link}
    Referral ID: {referral_id}

    Use my referral ID to get 40% OFF (‚Çπ150 instead of ‚Çπ250)!"""
        
        share_text.insert("1.0", share_message)
        share_text.config(state="disabled")
        
        # Action buttons
        button_frame = tk.Frame(self.content_frame, bg="white")
        button_frame.pack(pady=30)
        
        copy_btn = tk.Button(button_frame, text="üìã Copy Message", 
                           command=lambda: self.copy_message(share_message),
                           font=("Arial", 10, "bold"), bg="#2196F3", fg="white",
                           width=15, height=2, cursor="hand2")
        copy_btn.pack(side="left", padx=5)
        
        share_btn = tk.Button(button_frame, text="üì§ Share", 
                            command=lambda: self.share_message(share_message),
                            font=("Arial", 10, "bold"), bg="#4CAF50", fg="white",
                            width=15, height=2, cursor="hand2")
        share_btn.pack(side="left", padx=5)
        
        close_btn = tk.Button(button_frame, text="Close", 
                            command=self.referral_window.destroy,
                            font=("Arial", 10, "bold"), bg="#757575", fg="white",
                            width=15, height=2, cursor="hand2")
        close_btn.pack(side="left", padx=5)
    
    def handle_registration_submit(self):
        """Handle registration form submission"""
        email = self.email_var.get().strip()
        upi_id = self.upi_var.get().strip()
        telegram_id = self.telegram_var.get().strip()
        
        # Validation
        if not email or not self.is_email(email):
            messagebox.showerror("Error", "Please enter a valid email address")
            return
        
        if not upi_id or not self.is_valid_upi(upi_id):
            messagebox.showerror("Error", "Please enter a valid UPI ID")
            return
        
        if not self.agree_var.get():
            messagebox.showerror("Error", "Please agree to the terms")
            return
        
        # Store temporarily
        self.temp_registration = {
            'email': email,
            'upi_id': upi_id,
            'telegram_id': telegram_id
        }
        
        # Send OTP
        self.clear_content()
        loading_frame, spinner = self.show_loading(self.content_frame, "Sending OTP...")
        
        def send_otp_task():
            try:
                otp = self.generate_otp()
                success = self.send_otp(email, otp)
                
                self.referral_window.after(0, lambda: [
                    self.hide_loading(loading_frame, spinner),
                    self.show_otp_form(email, otp) if success else self.show_registration_form()
                ])
                
            except Exception as e:
                self.referral_window.after(0, lambda: [
                    self.hide_loading(loading_frame, spinner),
                    messagebox.showerror("Error", f"Failed to send OTP: {str(e)}"),
                    self.show_registration_form()
                ])
        
        threading.Thread(target=send_otp_task, daemon=True).start()
    
    def clear_content(self):
        """Clear the content frame"""
        for widget in self.content_frame.winfo_children():
            widget.destroy()
    
    def show_otp_form(self, contact, generated_otp):
        """Show OTP verification form"""
        self.clear_content()
        self.current_contact = contact
        self.current_otp = generated_otp
        self.otp_sent_time = datetime.now()
        
        tk.Label(self.content_frame, text="OTP Verification", 
                font=("Arial", 16, "bold"), bg="white").pack(pady=20)
        
        tk.Label(self.content_frame, text=f"Enter OTP sent to:", 
                font=("Arial", 11), bg="white").pack(pady=5)
        
        tk.Label(self.content_frame, text=contact, 
                font=("Arial", 11, "bold"), bg="white", fg="#FF9800").pack(pady=5)
        
        # Timer display
        self.timer_label = tk.Label(self.content_frame, text="Valid for: 5:00", 
                                   font=("Arial", 10), bg="white", fg="#666")
        self.timer_label.pack(pady=5)
        
        # OTP input
        otp_frame = tk.Frame(self.content_frame, bg="white")
        otp_frame.pack(pady=30)
        
        self.otp_var = tk.StringVar()
        otp_entry = tk.Entry(otp_frame, textvariable=self.otp_var, 
                           font=("Arial", 14), width=15, justify="center",
                           bd=2, relief="groove")
        otp_entry.pack(pady=10)
        otp_entry.focus()
        
        # Buttons
        button_frame = tk.Frame(self.content_frame, bg="white")
        button_frame.pack(pady=20)
        
        self.verify_btn = tk.Button(button_frame, text="Verify OTP", 
                                   command=self.handle_verify_current_otp,
                                   font=("Arial", 12, "bold"), bg="#4CAF50", fg="white",
                                   width=12, height=2, cursor="hand2")
        self.verify_btn.pack(side="left", padx=5)
        
        self.resend_btn = tk.Button(button_frame, text="Resend OTP", 
                                   command=self.handle_resend_otp,
                                   font=("Arial", 12, "bold"), bg="#FF9800", fg="white",
                                   width=12, height=2, cursor="hand2")
        self.resend_btn.pack(side="left", padx=5)
        
        back_btn = tk.Button(button_frame, text="Back", 
                           command=self.show_registration_form,
                           font=("Arial", 12, "bold"), bg="#757575", fg="white",
                           width=12, height=2, cursor="hand2")
        back_btn.pack(side="left", padx=5)
        
        # Start timer
        self.update_timer()
        
        # Bind Enter key
        self.referral_window.bind('<Return>', lambda e: self.handle_verify_current_otp())
    
    def update_timer(self):
        """Update the countdown timer"""
        try:
            if not hasattr(self, 'otp_sent_time') or not hasattr(self, 'timer_label'):
                return
            
            elapsed = datetime.now() - self.otp_sent_time
            remaining = 300 - elapsed.total_seconds()  # 5 minutes = 300 seconds
            
            if remaining <= 0:
                self.timer_label.config(text="OTP Expired", fg="red")
                self.verify_btn.config(state="disabled", bg="#cccccc")
                return
            
            minutes = int(remaining // 60)
            seconds = int(remaining % 60)
            self.timer_label.config(text=f"Valid for: {minutes}:{seconds:02d}", fg="#666")
            
            # Schedule next update
            self.referral_window.after(1000, self.update_timer)
            
        except Exception as e:
            print(f"Timer update error: {e}")
    
    def handle_verify_current_otp(self):
        """Handle OTP verification with current OTP"""
        self.handle_verify_otp(self.current_contact, self.current_otp)
    
    def handle_resend_otp(self):
        """Handle resending OTP"""
        try:
            new_otp = self.generate_otp()
            
            self.clear_content()
            loading_frame, spinner = self.show_loading(self.content_frame, "Resending OTP...")
            
            def resend_task():
                try:
                    success = self.send_otp(self.current_contact, new_otp)
                    
                    self.referral_window.after(0, lambda: [
                        self.hide_loading(loading_frame, spinner),
                        self.show_otp_form(self.current_contact, new_otp) if success 
                        else messagebox.showerror("Error", "Failed to resend OTP")
                    ])
                    
                except Exception as e:
                    self.referral_window.after(0, lambda: [
                        self.hide_loading(loading_frame, spinner),
                        messagebox.showerror("Error", f"Failed to resend OTP: {str(e)}"),
                        self.show_otp_form(self.current_contact, self.current_otp)
                    ])
            
            threading.Thread(target=resend_task, daemon=True).start()
            
        except Exception as e:
            messagebox.showerror("Error", f"Resend failed: {str(e)}")
    
    def send_registration_success_notification(self, email, telegram_id, referral_details):
        """Send success notification to new referrer via email and Telegram"""
        from api_client import api  # ‚úÖ ensure this import is present at the top of the file

        try:
            # ‚úÖ EMAIL NOTIFICATION (Unchanged)
            if email:
                subject = "Welcome to StudyTimer Referral Program! üéâ"
                body = f"""Congratulations! You've successfully joined the StudyTimer Referral Program.

    Your Referral Details:
    -----------------------
    Referral ID: {referral_details.get('referral_id')}
    Referral Link: {referral_details.get('referral_link')}
    UPI ID: {referral_details.get('upi_id')}

    How to Earn:
    ------------
    ‚Ä¢ ‚Çπ10 for each install using your referral code
    ‚Ä¢ ‚Çπ50 when they subscribe to Pro
    ‚Ä¢ Total potential: ‚Çπ60 per referral

    Payment Details:
    ---------------
    ‚Ä¢ Payments processed within 24 business hours
    ‚Ä¢ Direct transfer to your registered UPI ID
    ‚Ä¢ You'll be notified for each successful referral

    Start Sharing:
    -------------
    Share your referral link with friends and start earning today!
    {referral_details.get('referral_link')}

    Use this message to share:
    "Join me on StudyTimer - The best study companion!
    Download: {referral_details.get('referral_link')}
    Referral ID: {referral_details.get('referral_id')}
    Get 40% OFF with my referral code!"

    Thank you for joining our referral program!

    Best regards,
    StudyTimer Team"""
                
                try:
                    msg = MIMEMultipart()
                    msg['From'] = self.email_user
                    msg['To'] = email
                    msg['Subject'] = subject
                    msg.attach(MIMEText(body, 'plain'))
                    
                    server = smtplib.SMTP(self.smtp_server, self.smtp_port)
                    server.starttls()
                    server.login(self.email_user, self.email_password)
                    server.send_message(msg)
                    server.quit()
                    
                    print(f"‚úì Registration success email sent to {email}")
                except Exception as e:
                    print(f"Failed to send email: {e}")
            
            # ‚úÖ TELEGRAM NOTIFICATION (NEW PATTERN)
            if telegram_id:
                telegram_message = f"""üéâ <b>Welcome to StudyTimer Referral Program!</b>

    Your referral is now active!

    <b>Referral ID:</b> <code>{referral_details.get('referral_id')}</code>
    <b>Earnings:</b> ‚Çπ10/install + ‚Çπ50/subscription

    Share your link and start earning:
    {referral_details.get('referral_link')}

    You'll receive instant notifications here for each referral! üí∞"""

                try:
                    result = api.send_telegram(telegram_message, chat_id=telegram_id)
                    if result.get('success'):
                        print(f"‚úì Telegram notification sent to {telegram_id}")
                    else:
                        print(f"Failed to send Telegram notification: {result.get('error')}")
                except Exception as e:
                    print(f"Failed to send Telegram notification: {e}")
                    
        except Exception as e:
            print(f"Error sending registration notifications: {e}")

    
    def handle_verify_otp(self, contact, generated_otp):
        """Handle OTP verification with success notifications"""
        entered_otp = self.otp_var.get().strip()
        
        if entered_otp != generated_otp:
            messagebox.showerror("Invalid OTP", "Please enter the correct OTP")
            return
        
        # Show loading
        self.clear_content()
        loading_frame, spinner = self.show_loading(self.content_frame, "Setting up your referral account...")
        
        def setup_referral_task():
            try:
                # Get user profile
                profile = _load_profile()
                username = (profile.get("user_name") or 
                           profile.get("username") or 
                           profile.get("name") or 
                           "User")
                
                user_data = {
                    "uid": profile.get("uid") or str(uuid.uuid4()),
                    "username": username,
                    "machine_fingerprint": self.generate_machine_fingerprint(),
                    "contact": contact,
                    "upi_id": self.temp_registration.get('upi_id'),
                    "telegram_id": self.temp_registration.get('telegram_id')
                }
                
                # Add to referral program
                success = self.add_to_referral_sheet(user_data)
                
                if success:
                    # Prepare referral details for notification
                    referral_details = {
                        'referral_id': self.user_referral_id,
                        'referral_link': self.referral_link,
                        'upi_id': self.temp_registration.get('upi_id')
                    }
                    
                    # Send success notifications
                    self.send_registration_success_notification(
                        contact,  # email
                        self.temp_registration.get('telegram_id'),
                        referral_details
                    )
                
                # Hide loading and show result
                self.referral_window.after(0, lambda: [
                    self.hide_loading(loading_frame, spinner),
                    self.show_success_panel() if success else self.show_error_panel()
                ])
                
            except Exception as e:
                self.referral_window.after(0, lambda: [
                    self.hide_loading(loading_frame, spinner),
                    messagebox.showerror("Error", f"Failed to setup referral: {str(e)}"),
                    self.show_registration_form()
                ])
        
        threading.Thread(target=setup_referral_task, daemon=True).start()
    
    def show_success_panel(self):
        """Show success panel with referral details and earning info"""
        self.clear_content()
        
        # Success header
        tk.Label(self.content_frame, text="üéâ Welcome to Referral Program! üéâ", 
                font=("Arial", 16, "bold"), bg="white", fg="#4CAF50").pack(pady=20)
        
        # Referral details frame
        details_frame = tk.Frame(self.content_frame, bg="#f8f9fa", relief="ridge", bd=1)
        details_frame.pack(fill="x", pady=20, padx=20)
        
        tk.Label(details_frame, text="Your Referral Details", 
                font=("Arial", 12, "bold"), bg="#f8f9fa").pack(pady=10)
        
        tk.Label(details_frame, text=f"Referral ID: {self.user_referral_id}", 
                font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        tk.Label(details_frame, text=f"UPI ID: {self.temp_registration.get('upi_id')}", 
                font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        if self.temp_registration.get('telegram_id'):
            tk.Label(details_frame, text=f"Telegram: {self.temp_registration.get('telegram_id')}", 
                    font=("Arial", 10), bg="#f8f9fa", fg="#333").pack(pady=2)
        
        # Earnings reminder
        earnings_frame = tk.Frame(self.content_frame, bg="#e8f5e9", relief="ridge", bd=1)
        earnings_frame.pack(fill="x", pady=10, padx=20)
        
        tk.Label(earnings_frame, text="üí∞ Start Earning Now!", 
                font=("Arial", 11, "bold"), bg="#e8f5e9").pack(pady=5)
        
        tk.Label(earnings_frame, text="Share your referral link and earn:", 
                font=("Arial", 10), bg="#e8f5e9").pack()
        
        tk.Label(earnings_frame, text="‚Çπ10 per install + ‚Çπ50 per subscription", 
                font=("Arial", 11, "bold"), bg="#e8f5e9", fg="#4CAF50").pack(pady=5)
        
        # Share message
        message_frame = tk.Frame(self.content_frame, bg="white")
        message_frame.pack(fill="x", pady=10, padx=20)
        
        tk.Label(message_frame, text="Share this message:", 
                font=("Arial", 11, "bold"), bg="white").pack(anchor="w")
        
        share_text = tk.Text(message_frame, height=5, font=("Arial", 9), wrap="word",
                           bg="#f8f9fa", bd=1, relief="solid")
        share_text.pack(fill="x", pady=5)
        
        share_message = f"""üéì Join me on StudyTimer - The best study companion!

Download: {self.referral_link}
Referral ID: {self.user_referral_id}

Use my referral ID to get 40% OFF (‚Çπ150 instead of ‚Çπ250)!"""
        
        share_text.insert("1.0", share_message)
        share_text.config(state="disabled")
        
        # Action buttons
        button_frame = tk.Frame(self.content_frame, bg="white")
        button_frame.pack(pady=30)
        
        copy_btn = tk.Button(button_frame, text="üìã Copy Message", 
                           command=lambda: self.copy_message(share_message),
                           font=("Arial", 10, "bold"), bg="#2196F3", fg="white",
                           width=15, height=2, cursor="hand2")
        copy_btn.pack(side="left", padx=5)
        
        share_btn = tk.Button(button_frame, text="üì§ Share", 
                            command=lambda: self.share_message(share_message),
                            font=("Arial", 10, "bold"), bg="#4CAF50", fg="white",
                            width=15, height=2, cursor="hand2")
        share_btn.pack(side="left", padx=5)
        
        close_btn = tk.Button(button_frame, text="Close", 
                            command=self.referral_window.destroy,
                            font=("Arial", 10, "bold"), bg="#757575", fg="white",
                            width=15, height=2, cursor="hand2")
        close_btn.pack(side="left", padx=5)
    
    def show_error_panel(self):
        """Show error panel"""
        self.clear_content()
        
        tk.Label(self.content_frame, text="‚ùå Setup Failed", 
                font=("Arial", 16, "bold"), bg="white", fg="#f44336").pack(pady=20)
        
        tk.Label(self.content_frame, text="Failed to setup referral program.\nPlease try again later.", 
                font=("Arial", 11), bg="white").pack(pady=20)
        
        tk.Button(self.content_frame, text="Try Again", 
                command=self.show_registration_form,
                font=("Arial", 12, "bold"), bg="#FF9800", fg="white",
                width=15, height=2, cursor="hand2").pack(pady=20)
    
    def copy_message(self, message):
        """Copy message to clipboard"""
        self.main_app.clipboard_clear()
        self.main_app.clipboard_append(message)
        messagebox.showinfo("Copied!", "Referral message copied to clipboard!")
    
    def share_message(self, message):
        """Share message via system"""
        try:
            import tempfile
            import webbrowser
            
            # Create sharing options dialog
            share_dialog = tk.Toplevel(self.main_app)
            share_dialog.title("Share Referral Link")
            share_dialog.geometry("400x300")
            share_dialog.resizable(False, False)
            share_dialog.grab_set()
            
            # Center dialog
            x = self.main_app.winfo_rootx() + 100
            y = self.main_app.winfo_rooty() + 100
            share_dialog.geometry(f"400x300+{x}+{y}")
            
            tk.Label(share_dialog, text="Share Your Referral", 
                    font=("Arial", 14, "bold")).pack(pady=20)
            
            # Share options
            options_frame = tk.Frame(share_dialog)
            options_frame.pack(pady=20)
            
            def save_to_file():
                try:
                    from tkinter import filedialog
                    filename = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("Text files", ".txt"), ("All files", ".*")],
                        title="Save Referral Message"
                    )
                    if filename:
                        with open(filename, 'w', encoding='utf-8') as f:
                            f.write(message)
                        messagebox.showinfo("Saved", f"Referral message saved to {filename}")
                        share_dialog.destroy()
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to save file: {str(e)}")
            
            def open_email_client():
                try:
                    import urllib.parse
                    subject = urllib.parse.quote("Join me on StudyTimer!")
                    body = urllib.parse.quote(message)
                    mailto_url = f"mailto:?subject={subject}&body={body}"
                    webbrowser.open(mailto_url)
                    share_dialog.destroy()
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to open email client: {str(e)}")
            
            # Share option buttons
            tk.Button(options_frame, text="üìß Open Email Client", 
                     command=open_email_client, font=("Arial", 11), 
                     width=20, pady=5).pack(pady=5)
            
            tk.Button(options_frame, text="üíæ Save to File", 
                     command=save_to_file, font=("Arial", 11), 
                     width=20, pady=5).pack(pady=5)
            
            tk.Button(options_frame, text="Cancel", 
                     command=share_dialog.destroy, font=("Arial", 11), 
                     bg="#757575", fg="white", width=20, pady=5).pack(pady=15)
            
        except Exception as e:
            messagebox.showerror("Error", f"Share failed: {str(e)}")
    
    def join_referral_program(self):
        """Main entry point for referral program with subscription check"""
        self.create_unified_referral_window()


# Helper function to load profile
def _load_profile():
    """Load profile from local file only"""
    if os.path.exists(app_paths.profile_file):
        try:
            with open(app_paths.profile_file, 'r', encoding='utf-8') as f:
                profile_data = json.load(f)                
                return profile_data
        except Exception as e:
            print(f"Error reading local profile: {e}")
    
    print("No profile found - creating empty profile")
    return {}
    
def get_user_id_from_profile():
    """Get user_id from existing profile"""

    profile = _load_profile()
    legacy_uid = profile.get('uid')

    def _generate_machine_fingerprint():
        """Create a stable machine fingerprint for identity recovery"""
        try:
            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
            hostname = platform.node()
            fingerprint_data = f"{system_info}-{hostname}"
            return hashlib.md5(fingerprint_data.encode()).hexdigest()[:16]
        except Exception as e:
            print(f"Error generating machine fingerprint: {e}")
            return None

    # Ensure we always have a fingerprint on disk
    machine_fp = profile.get('machine_fingerprint') or _generate_machine_fingerprint()
    if machine_fp and profile.get('machine_fingerprint') != machine_fp:
        profile['machine_fingerprint'] = machine_fp

    # ‚úÖ Prefer the machine fingerprint as the canonical identity so group membership survives reinstalls
    user_id = machine_fp or legacy_uid or str(uuid.uuid4())[:16]

    # Persist both uid and fingerprint so they survive app reinstalls/file deletion
    profile['uid'] = user_id
    if legacy_uid and legacy_uid != user_id:
        profile['legacy_uid'] = legacy_uid
    try:
        os.makedirs(os.path.dirname(app_paths.profile_file), exist_ok=True)
        with open(app_paths.profile_file, 'w', encoding='utf-8') as f:
            json.dump(profile, f, indent=4)
    except Exception as e:
        print(f"Error saving uid/fingerprint to profile: {e}")

    return user_id
        
def _create_default_profile():
    """Create a default profile when actually needed"""
    try:
        appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
        profile_path = os.path.join(appdata_path, 'profile.json')
        
        os.makedirs(appdata_path, exist_ok=True)
        
        default_profile = {
            'uid': str(uuid.uuid4()),
            'username': os.getlogin() if hasattr(os, 'getlogin') else 'User',
            'created_at': datetime.now().isoformat()
        }
        
        with open(profile_path, 'w') as f:
            json.dump(default_profile, f, indent=2)
        
        return default_profile
    except Exception as e:
        print(f"Error creating profile: {e}")
        return {'uid': str(uuid.uuid4()), 'username': 'User'}
        
import os
import sys
import json
import hashlib
import platform
import uuid
import threading
import time
import requests
import smtplib
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from cryptography.fernet import Fernet
import gspread
import tkinter as tk
from tkinter import messagebox


class ReferralValidator:
    """Handles referral validation and tracking for new users with payment system"""
    
    def __init__(self, main_app):
        self.main_app = main_app
        load_dotenv()
        
        # Configuration
        self.referral_sheet_id = get_sheet_id()
        self.referral_worksheet = get_secret("REFERRAL_WORKSHEET") or "referral_program"
        
        # Consistent paths using AppData
        self.appdata_path = os.path.join(os.getenv('APPDATA', os.path.expanduser('~')), 'StudyTimer')
        self.profile_path = os.path.join(self.appdata_path, 'profile.json')
        self.pending_updates_file = os.path.join(self.appdata_path, 'pending_referrals.json')
        
        # Email settings - use environment variables
        self.sender_email = get_secret("EMAIL_USER") or "studytimerpro@gmail.com"
        self.sender_password = get_secret("EMAIL_PASSWORD") or "iubj mluu oiro prhd"
        self.smtp_server = get_secret("SMTP_SERVER") or "smtp.gmail.com"
        self.smtp_port = int(get_secret("SMTP_PORT") or "587")
        
        # Telegram settings
        self.telegram_bot_token = get_secret("TELEGRAM_BOT_TOKEN") or ""
        
        # Instance variables
        
        self.entered_referral_id = None
        self.validation_window = None
        # Add processing lock
        self.processing_lock = threading.Lock()
        self.currently_processing = False
        # Ensure directories exist
        os.makedirs(self.appdata_path, exist_ok=True)
               
        self.sync_on_startup()           # Immediate sync check
        
    def check_internet_connection(self):
        """Check if internet connection is available"""
        try:
            import requests
            response = requests.get("https://www.google.com", timeout=5)
            return response.status_code == 200
        except:
            return False

    def sync_on_startup(self):
        """Immediate sync check when app starts"""
        def startup_sync():
            time.sleep(2)  # Small delay to ensure everything is initialized
            try:
                if self.check_internet_connection():
                    print("üîÑ Starting initial sync check...")
                    self.process_pending_updates()
                else:
                    print("üì¥ No internet - sync will happen when connection is available")
            except Exception as e:
                print(f"Startup sync error: {e}")
        
        startup_thread = threading.Thread(target=startup_sync, daemon=True)
        startup_thread.start()
        print("‚úì Startup sync initiated")

    def start_connection_monitor(self):
        """Monitor for internet connection changes and sync immediately when online"""
        def monitor_connection():
            was_online = False
            while True:
                try:
                    is_online = self.check_internet_connection()
                    
                    # If just came online, sync immediately
                    if is_online and not was_online:
                        print("üåê Internet connection detected - syncing pending updates...")
                        self.process_pending_updates()
                    elif not is_online and was_online:
                        print("üì¥ Internet connection lost")
                    
                    was_online = is_online
                    time.sleep(10)  # Check every 10 seconds
                    
                except Exception as e:
                    print(f"Connection monitor error: {e}")
                    time.sleep(30)
        
        monitor_thread = threading.Thread(target=monitor_connection, daemon=True)
        monitor_thread.start()
        print("‚úì Connection monitor started")
    
    
    
    def load_user_profile(self):
        """Load or create user profile WITHOUT setting referral_checked flag"""
        try:
            if os.path.exists(self.profile_path):
                with open(self.profile_path, 'r') as f:
                    profile = json.load(f)
            else:
                profile = {}
            
            # Only ensure required fields exist, don't auto-save
            if 'uid' not in profile:
                profile['uid'] = str(uuid.uuid4())
            
            if 'machine_fingerprint' not in profile:
                profile['machine_fingerprint'] = self.generate_machine_fingerprint()
            
            # DON'T automatically save here - let referral process control when to save
            # Only save if it's a completely new profile with no referral data
            if not os.path.exists(self.profile_path) and 'referral_checked' not in profile:
                # This is truly a new installation - save minimal profile
                minimal_profile = {
                    'uid': profile['uid'],
                    'machine_fingerprint': profile['machine_fingerprint']
                }
                self.save_user_profile(minimal_profile)
                return minimal_profile
            
            return profile
            
        except Exception as e:
            print(f"Error loading profile: {e}")
            # Return minimal profile without saving
            return {
                'uid': str(uuid.uuid4()),
                'machine_fingerprint': self.generate_machine_fingerprint()
            }
    
    def save_user_profile(self, profile):
        """Save user profile"""
        try:
            with open(self.profile_path, 'w') as f:
                json.dump(profile, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving profile: {e}")
            return False
    
    def generate_machine_fingerprint(self):
        """Generate unique machine fingerprint"""
        try:
            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
            hostname = platform.node()
            fingerprint_data = f"{system_info}-{hostname}"
            fingerprint = hashlib.md5(fingerprint_data.encode()).hexdigest()[:16]
            return fingerprint
        except Exception as e:
            print(f"Error generating fingerprint: {e}")
            return str(uuid.uuid4())[:16]
    
    def check_referral_from_args(self):
        """Check if app was launched with referral ID"""
        try:
            # Check command line arguments
            if len(sys.argv) > 1:
                for arg in sys.argv[1:]:
                    if 'ref=' in arg:
                        ref_id = arg.split('ref=')[1].split('&')[0]
                        if ref_id:
                            print(f"Found referral ID from args: {ref_id}")
                            return ref_id
            
            # Check temp file (from download)
            temp_ref_file = os.path.join(self.appdata_path, 'referral_temp.txt')
            if os.path.exists(temp_ref_file):
                try:
                    with open(temp_ref_file, 'r') as f:
                        ref_id = f.read().strip()
                    os.remove(temp_ref_file)
                    print(f"Found referral ID from temp file: {ref_id}")
                    return ref_id
                except Exception as e:
                    print(f"Error reading temp referral file: {e}")
                    
        except Exception as e:
            print(f"Error checking referral args: {e}")
        
        return None
    
    def validate_referral_id_online(self, referral_id):
        """Validate referral ID against Google Sheet"""
        try:
            client = get_encrypted_gspread_client()
            if not client:
                print("Cannot validate - no Google Sheets connection")
                return None
            
            sheet = client.open_by_key(self.referral_sheet_id)
            worksheet = sheet.worksheet(self.referral_worksheet)
            
            # Get all referral IDs (column E - index 5)
            try:
                referral_ids = worksheet.col_values(5)  # Column E
            except Exception as e:
                print(f"Error fetching referral IDs: {e}")
                return None
            
            if referral_id in referral_ids:
                try:
                    row_index = referral_ids.index(referral_id) + 1
                    referrer_data = worksheet.row_values(row_index)
                    
                    if len(referrer_data) >= 5:
                        return {
                            'valid': True,
                            'referrer_uid': referrer_data[0] if len(referrer_data) > 0 else '',
                            'referrer_name': referrer_data[1] if len(referrer_data) > 1 else '',
                            'referral_id': referrer_data[4] if len(referrer_data) > 4 else '',
                            'contact': referrer_data[3] if len(referrer_data) > 3 else '',
                            'telegram_id': referrer_data[11] if len(referrer_data) > 11 else '',
                            'row_index': row_index
                        }
                except Exception as e:
                    print(f"Error parsing referrer data: {e}")
                    return {'valid': False}
            
            return {'valid': False}
            
        except Exception as e:
            print(f"Error validating referral online: {e}")
            return None
    
    def update_referral_stats_online(self, referral_id, user_info, install_type="install"):
        """Update referral statistics in Google Sheet - Updated to check entire N and P columns for duplicates"""
        try:
            client = get_encrypted_gspread_client()
            if not client:
                print("Cannot update stats - no connection")
                return False
            
            sheet = client.open_by_key(self.referral_sheet_id)
            worksheet = sheet.worksheet(self.referral_worksheet)
            
            # Find referrer's row
            referral_ids = worksheet.col_values(5)
            if referral_id not in referral_ids:
                print(f"Referral ID {referral_id} not found")
                return False
            
            row_index = referral_ids.index(referral_id) + 1
            current_data = worksheet.row_values(row_index)
            
            # Ensure we have enough columns (extend if needed)
            while len(current_data) < 18:
                current_data.append("")
            
            # Extract fingerprint from user_info if it contains uid_fingerprint format
            if "_" in user_info:
                # Extract only fingerprint part (after underscore)
                fingerprint = user_info.split("_")[-1]
            else:
                # Already fingerprint only
                fingerprint = user_info
            
            # GET ENTIRE COLUMNS FOR DUPLICATE CHECK
            try:
                # Get all values from column N (Installed Users) - index 14
                installed_users_column = worksheet.col_values(14)
                # Get all values from column P (Subscribed Users) - index 16
                subscribed_users_column = worksheet.col_values(16)
            except Exception as e:
                print(f"Error fetching columns: {e}")
                installed_users_column = []
                subscribed_users_column = []
            
            # Helper function to extract all fingerprints from column data
            def extract_all_fingerprints(column_data):
                all_fingerprints = set()
                for cell_data in column_data:
                    if cell_data and cell_data.strip():
                        # Split by comma and clean each fingerprint
                        fingerprints_in_cell = [fp.strip() for fp in cell_data.split(",") if fp.strip()]
                        for fp in fingerprints_in_cell:
                            # Handle both fingerprint-only and uid_fingerprint formats
                            if "_" in fp:
                                # Extract fingerprint part after underscore
                                clean_fp = fp.split("_")[-1]
                            else:
                                clean_fp = fp
                            all_fingerprints.add(clean_fp)
                return all_fingerprints
            
            # Extract all existing fingerprints from both columns
            existing_installed_fingerprints = extract_all_fingerprints(installed_users_column)
            existing_subscribed_fingerprints = extract_all_fingerprints(subscribed_users_column)
            
            # Update based on install type
            if install_type == "install":
                # CHECK FOR DUPLICATE FINGERPRINT IN ENTIRE INSTALLED USERS COLUMN (N)
                if fingerprint in existing_installed_fingerprints:
                    print(f"‚ùå Verification failed: Fingerprint {fingerprint} already exists in installed users")
                    return False  # Return False for any duplicate/invalid case
                
                # Update install count (column M - index 12)
                install_count = int(current_data[12]) if current_data[12].isdigit() else 0
                worksheet.update_cell(row_index, 13, str(install_count + 1))
                
                # Add fingerprint to installed users list (column N - index 13)
                current_installed = current_data[13] if len(current_data) > 13 else ""
                new_installed = f"{current_installed}, {fingerprint}" if current_installed else fingerprint
                worksheet.update_cell(row_index, 14, new_installed)
                
            elif install_type == "subscription":
                # CHECK FOR DUPLICATE FINGERPRINT IN ENTIRE SUBSCRIBED USERS COLUMN (P)
                if fingerprint in existing_subscribed_fingerprints:
                    print(f"‚ùå Verification failed: Fingerprint {fingerprint} already exists in subscribed users")
                    return False  # Return False for any duplicate/invalid case
                
                # Check if fingerprint exists in installed users (prerequisite for subscription)
                if fingerprint not in existing_installed_fingerprints:
                    print(f"‚ùå Cannot subscribe: Fingerprint {fingerprint} not found in installed users")
                    return False  # Return False for any invalid case
                
                # Update subscription count (column O - index 14)
                sub_count = int(current_data[14]) if len(current_data) > 14 and current_data[14].isdigit() else 0
                worksheet.update_cell(row_index, 15, str(sub_count + 1))
                
                # Add fingerprint to subscribed users list (column P - index 15)
                current_subscribed = current_data[15] if len(current_data) > 15 else ""
                new_subscribed = f"{current_subscribed}, {fingerprint}" if current_subscribed else fingerprint
                worksheet.update_cell(row_index, 16, new_subscribed)
            
            # Always update total referral count (column H - index 7)
            current_count = int(current_data[7]) if len(current_data) > 7 and current_data[7].isdigit() else 0
            worksheet.update_cell(row_index, 8, str(current_count + 1))
            
            # Update referred users list with fingerprint only (column I - index 8)
            referred_users = current_data[8] if len(current_data) > 8 else ""
            new_referred = f"{referred_users}, {fingerprint}" if referred_users else fingerprint
            worksheet.update_cell(row_index, 9, new_referred)
            
            print(f"‚úì Updated referral stats for {referral_id} - {install_type}")
            return True
            
        except Exception as e:
            print(f"Error updating referral stats: {e}")
            return False
    
    def send_notification_to_referrer(self, referrer_details, user_info, notification_type="install"):
        """Send notification to referrer via Telegram and Email"""
        from api_client import api  # ‚úÖ ensure this import is at top of file

        try:
            # Prepare notification content
            if notification_type == "install":
                subject = "New Referral Install!"
                emoji = "üéâ"
                reward = "‚Çπ10"
                message_body = f"""Great news! Someone just installed StudyTimer using your referral code.

    Referred User: {user_info}
    Reward: {reward} (pending verification)

    Keep sharing to earn more!"""
            else:  # subscription
                subject = "Referral Subscription Success!"
                emoji = "üí∞"
                reward = "‚Çπ50"
                message_body = f"""Amazing! Your referral just subscribed to StudyTimer Pro!

    Subscribed User: {user_info}
    Reward: {reward} (will be processed within 24 hours)

    Total earnings from this referral: ‚Çπ60
    Keep up the great work!"""
            
            # Send notifications
            success_email = False
            success_telegram = False
            
            # ‚úÖ Email notification (unchanged)
            if referrer_details.get('contact') and '@' in referrer_details.get('contact', ''):
                success_email = self.send_email_notification(
                    referrer_details['contact'], 
                    subject, 
                    message_body
                )
            
            # ‚úÖ Telegram notification (updated)
            if referrer_details.get('telegram_id'):
                telegram_message = f"{emoji} <b>{subject}</b>\n\n{message_body}"
                try:
                    result = api.send_telegram(telegram_message, chat_id=referrer_details['telegram_id'])
                    if result.get('success'):
                        print(f"‚úì Telegram notification sent to {referrer_details['telegram_id']}")
                        success_telegram = True
                    else:
                        print(f"[Telegram] Failed: {result.get('error')}")
                except Exception as e:
                    print(f"Failed to send Telegram notification: {e}")
            
            return success_email or success_telegram
            
        except Exception as e:
            print(f"Error sending notifications: {e}")
            return False

    
    def send_telegram_notification(self, telegram_id, message):
        """Send notification via Telegram (via secure backend API)"""
        from api_client import api  # ‚úÖ make sure this is at top of file (only once overall)

        try:
            # ‚úÖ Format telegram_id properly
            chat_id = telegram_id
            if not chat_id.startswith('@') and not chat_id.isdigit():
                chat_id = f"@{chat_id}"

            # ‚úÖ Send using backend API instead of bot token
            result = api.send_telegram(message, chat_id=chat_id)
            if result.get('success'):
                print(f"‚úì Telegram notification sent to {telegram_id}")
                return True
            else:
                print(f"Telegram API error: {result.get('error')}")
                return False

        except Exception as e:
            print(f"Telegram notification error: {e}")
            return False

    
    def send_email_notification(self, email, subject, message):
        """Send notification via Email"""
        try:
            if not self.sender_email or not self.sender_password:
                return False
            
            msg = MIMEMultipart()
            msg['From'] = self.sender_email
            msg['To'] = email
            msg['Subject'] = f"StudyTimer Referral - {subject}"
            
            # Add StudyTimer branding to email
            body = f"""Hello!

{message}

Thank you for being part of our referral program!

Best regards,
StudyTimer Team"""
            
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.sender_email, self.sender_password)
            server.send_message(msg)
            server.quit()
            
            print(f"‚úì Email notification sent to {email}")
            return True
            
        except Exception as e:
            print(f"Email notification error: {e}")
            return False
    
    def save_referral_locally(self, referral_id=None, skipped=False):
        """Save referral information locally"""
        try:
            profile = self.load_user_profile()
            
            # Update referral status
            profile['referral_checked'] = True
            profile['referral_check_date'] = datetime.now().isoformat()
            
            if referral_id:
                profile['used_referral'] = True
                profile['referral_code'] = referral_id
                profile['subscription_price_after_trial'] = 150  # Discounted price
            else:
                profile['used_referral'] = False
                profile['referral_skipped'] = skipped
                if skipped:
                    profile['subscription_price_after_trial'] = 200  # Full price
            
            return self.save_user_profile(profile)
            
        except Exception as e:
            print(f"Error saving referral locally: {e}")
            return False
    
    def queue_pending_update(self, referral_id, user_uid, fingerprint, install_type="install"):
        """Queue a pending update for when internet is available"""
        try:
            # Load existing pending updates
            pending = []
            if os.path.exists(self.pending_updates_file):
                with open(self.pending_updates_file, 'r') as f:
                    pending = json.load(f)
            
            # Add new pending update
            pending_update = {
                'referral_id': referral_id,
                'user_uid': user_uid,
                'user_fingerprint': fingerprint,
                'install_type': install_type,
                'timestamp': datetime.now().isoformat()
            }
            
            # Avoid duplicates
            if pending_update not in pending:
                pending.append(pending_update)
            
            # Save pending updates
            with open(self.pending_updates_file, 'w') as f:
                json.dump(pending, f, indent=2)
            
            print(f"‚úì Queued pending update for {referral_id}")
            return True
            
        except Exception as e:
            print(f"Error queuing update: {e}")
            return False
    
    def process_pending_updates(self):
        """Process any pending referral updates when internet is available - Enhanced with better logging"""
        try:
            if not os.path.exists(self.pending_updates_file):
                print("[DEBUG] No pending updates file found")
                return
            
            with open(self.pending_updates_file, 'r') as f:
                pending = json.load(f)
            
            if not pending:
                print("[DEBUG] No pending updates to process")
                return
            
            print(f"[DEBUG] Processing {len(pending)} pending updates...")
            processed = []
            failed = []
            
            for update in pending:
                try:
                    # Send only fingerprint (first 8 chars)
                    user_info = update['user_fingerprint'][:8]
                    print(f"[DEBUG] Processing update for referral: {update['referral_id']}")
                    
                    success = self.update_referral_stats_online(
                        update['referral_id'], 
                        user_info,
                        update.get('install_type', 'install')
                    )
                    
                    if success:
                        processed.append(update)
                        print(f"‚úÖ Successfully processed: {update['referral_id']}")
                        
                        # Try to send notification
                        result = self.validate_referral_id_online(update['referral_id'])
                        if result and result.get('valid'):
                            self.send_notification_to_referrer(
                                result, 
                                user_info, 
                                update.get('install_type', 'install')
                            )
                            print(f"üìß Notification sent for: {update['referral_id']}")
                    else:
                        failed.append(update)
                        print(f"‚ùå Failed to process: {update['referral_id']}")
                        
                except Exception as e:
                    print(f"Error processing update {update}: {e}")
                    failed.append(update)
            
            # Remove only successfully processed updates
            remaining = [u for u in pending if u not in processed]
            
            # Save remaining updates
            with open(self.pending_updates_file, 'w') as f:
                json.dump(remaining, f, indent=2)
            
            if processed:
                print(f"‚úÖ Successfully processed {len(processed)} pending referral updates")
            if failed:
                print(f"‚ùå {len(failed)} updates failed, will retry later")
                
        except Exception as e:
            print(f"Error processing pending updates: {e}")
    
    def start_background_sync(self):
        """Start background thread to sync pending updates - Updated for better responsiveness"""
        def sync_worker():
            while True:
                try:
                    if self.check_internet_connection():
                        self.process_pending_updates()
                        time.sleep(300)  # 5 minutes when online and no pending updates
                    else:
                        time.sleep(30)   # Check every 30 seconds when offline
                except Exception as e:
                    print(f"Background sync error: {e}")
                    time.sleep(60)  # Wait 1 minute on error
        
        sync_thread = threading.Thread(target=sync_worker, daemon=True)
        sync_thread.start()
        print("‚úì Enhanced background sync started")
    
    def check_and_show_referral(self):
        """Check if referral prompt should be shown"""
        try:
            profile = self.load_user_profile()
            
            # Skip if already checked
            if profile.get('referral_checked'):
                print("[REFERRAL] Already checked - skipping")
                return False
            
            # Check for auto referral ID from app launch
            auto_id = self.check_referral_from_args()
            
            # Show referral prompt
            self.show_referral_prompt(auto_id)
            
            # After showing (whether skipped or validated), mark as checked
            self.mark_referral_as_checked()
            
            return True
            
        except Exception as e:
            print(f"[REFERRAL] Error checking referral: {e}")
            return False
    
    def mark_referral_as_checked(self):
        """Mark referral as checked in profile"""
        try:
            profile = self.load_user_profile()
            profile['referral_checked'] = True
            
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            
            os.makedirs(appdata_path, exist_ok=True)
            with open(profile_path, 'w') as f:
                json.dump(profile, f, indent=2)
            
            print("[REFERRAL] Marked as checked - won't show again")
            
        except Exception as e:
            print(f"[REFERRAL] Error marking as checked: {e}")
    
    def update_to_subscription(self, user_uid=None):
        """Call this when user completes subscription payment"""
        try:
            print("[DEBUG] Starting update_to_subscription...")
            profile = self.load_user_profile()
            
            # Get referral info from profile (matching your JSON structure)
            used_referral = profile.get('used_referral', False)
            referral_code = profile.get('referral_code')  # This will get "BAL507550"
            
            print(f"[DEBUG] used_referral: {used_referral}")
            print(f"[DEBUG] referral_code: {referral_code}")
            
            # Check if user used a referral
            if not used_referral or not referral_code:
                print(f"[DEBUG] No referral used - used_referral: {used_referral}, referral_code: {referral_code}")
                return False
            
            # Create user info from profile data
            uid = profile.get('uid', 'unknown')
            machine_fingerprint = profile.get('machine_fingerprint', 'unknown')
            user_info = f"{uid}_{machine_fingerprint[:8]}"
            
            print(f"[DEBUG] user_info: {user_info}")
            print(f"[DEBUG] Calling update_referral_stats_online with:")
            print(f"  - referral_code: {referral_code}")
            print(f"  - user_info: {user_info}")
            print(f"  - action: subscription")
            
            # Update stats for subscription
            success = self.update_referral_stats_online(referral_code, user_info, "subscription")
            
            print(f"[DEBUG] update_referral_stats_online result: {success}")
            
            if success:
                # Get referrer details and send notification
                print(f"[DEBUG] Getting referrer details for {referral_code}")
                result = self.validate_referral_id_online(referral_code)
                if result and result.get('valid'):
                    self.send_notification_to_referrer(result, user_info, "subscription")
                    print(f"‚úì Subscription notification sent for {referral_code}")
                else:
                    print(f"[DEBUG] Referrer details not found or invalid")
            else:
                # Queue for later if offline
                print(f"[DEBUG] Online update failed, queuing for later")
                self.queue_pending_update(
                    referral_code,
                    profile.get('uid'),
                    profile.get('machine_fingerprint'),
                    "subscription"
                )
                print(f"‚úì Subscription update queued for {referral_code}")
            
            return success
            
        except Exception as e:
            print(f"[DEBUG] Exception in update_to_subscription: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def show_referral_prompt(self, auto_filled_id=None):
        """Show referral prompt window with discount info"""
        if self.validation_window and self.validation_window.winfo_exists():
            self.validation_window.lift()
            return
        
        print(f"[DEBUG] Creating referral prompt window with auto_filled_id: {auto_filled_id}")
        
        self.validation_window = tk.Toplevel(self.main_app)
        self.validation_window.title("Special Offer - StudyTimer Pro")
        self.validation_window.geometry("550x650")
        self.validation_window.resizable(False, False)
        
        # Make modal and center
        self.validation_window.transient(self.main_app)
        self.validation_window.grab_set()
        
        # Center window
        self.validation_window.update_idletasks()
        x = (self.validation_window.winfo_screenwidth() // 2) - 275
        y = (self.validation_window.winfo_screenheight() // 2) - 290
        self.validation_window.geometry(f"550x650+{x}+{y}")
        
        # Main container
        main_frame = tk.Frame(self.validation_window, bg="white")
        main_frame.pack(fill="both", expand=True)
        
        # Header with special offer badge
        header_frame = tk.Frame(main_frame, bg="#4CAF50", height=100)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        # Special offer badge
        badge_frame = tk.Frame(header_frame, bg="#FF5722", padx=12, pady=5)
        badge_frame.pack(pady=8)
        
        tk.Label(badge_frame, text="LIMITED TIME OFFER", 
                font=("Arial", 10, "bold"), bg="#FF5722", fg="white").pack()
        
        tk.Label(header_frame, text="üéÅ Get 40% OFF with Referral Code!", 
                font=("Arial", 16, "bold"), bg="#4CAF50", fg="white").pack()
        
        # Content
        content_frame = tk.Frame(main_frame, bg="white", padx=25, pady=20)
        content_frame.pack(fill="both", expand=True)
        
        # Pricing comparison section - UPDATED PRICES
        pricing_frame = tk.Frame(content_frame, bg="#f8f9fa", relief="ridge", bd=1, pady=15)
        pricing_frame.pack(fill="x", pady=15)
        
        # With referral code pricing
        with_code_frame = tk.Frame(pricing_frame, bg="#f8f9fa")
        with_code_frame.pack(pady=5)
        
        tk.Label(with_code_frame, text="‚úÖ WITH Referral Code: ", 
                font=("Arial", 11, "bold"), bg="#f8f9fa", fg="#4CAF50").pack(side="left")
        
        tk.Label(with_code_frame, text="‚Çπ199", 
                font=("Arial", 14, "bold"), bg="#f8f9fa", fg="#4CAF50").pack(side="left")
        
        tk.Label(with_code_frame, text=" (Save ‚Çπ150!)", 
                font=("Arial", 10), bg="#f8f9fa", fg="#FF5722").pack(side="left")
        
        # Without referral code pricing
        without_code_frame = tk.Frame(pricing_frame, bg="#f8f9fa")
        without_code_frame.pack(pady=5)
        
        tk.Label(without_code_frame, text="‚ùå WITHOUT Code: ", 
                font=("Arial", 11), bg="#f8f9fa", fg="#666").pack(side="left")
        
        tk.Label(without_code_frame, text="‚Çπ349", 
                font=("Arial", 14), bg="#f8f9fa", fg="#666").pack(side="left")
        
        tk.Label(without_code_frame, text=" (Standard price)", 
                font=("Arial", 10), bg="#f8f9fa", fg="#999").pack(side="left")
        
        # Benefits info
        tk.Label(content_frame, text="Enter referral code to unlock:", 
                font=("Arial", 11, "bold"), bg="white").pack(anchor="w", pady=(15, 5))
        
        benefits = [
            "‚Ä¢ 7 days FREE trial of all Pro features",
            "‚Ä¢ 40% lifetime discount on subscription",
            "‚Ä¢ Support your friend who referred you"
        ]
        
        for benefit in benefits:
            benefit_label = tk.Label(content_frame, text=benefit, 
                                    font=("Arial", 10), bg="white", fg="#333", 
                                    justify="left")
            benefit_label.pack(anchor="w", pady=2)
        
        # Referral input
        input_frame = tk.Frame(content_frame, bg="white")
        input_frame.pack(fill="x", pady=(20, 10))
        
        tk.Label(input_frame, text="Enter Referral Code:", 
                font=("Arial", 11, "bold"), bg="white").pack(anchor="w", pady=5)
        
        self.referral_entry = tk.Entry(input_frame, font=("Arial", 13), 
                                      bd=2, relief="solid", highlightthickness=2,
                                      highlightcolor="#4CAF50")
        self.referral_entry.pack(fill="x", pady=5)
        
        # Auto-fill if provided
        if auto_filled_id:
            self.referral_entry.insert(0, auto_filled_id)
            self.referral_entry.config(state="readonly", bg="#e8f5e9")
        
        # Status label
        self.status_label = tk.Label(input_frame, text="", 
                                    font=("Arial", 10), bg="white", fg="red")
        self.status_label.pack(anchor="w")
        
        # Modified handle_skip to close window and continue
        def handle_skip_modified():
            print("[DEBUG] Skip button clicked - closing referral prompt")
            # Save that prompt was shown
            profile = self.load_user_profile()
            profile['referral_prompt_shown'] = True
            self.save_user_profile(profile)
            # Close window
            self.validation_window.destroy()
            # Continue with validation after a delay
            self.main_app.after(500, self.main_app._check_license_and_payment)
        
        # Modified handle_apply_code to continue after success
        original_handle_apply = self.handle_apply_code
        
        def handle_apply_modified():
            print("[DEBUG] Apply button clicked")
            # Store original window reference
            original_window = self.validation_window
            # Call the original handle_apply_code
            original_handle_apply()
            # Check if window still exists (might be closed by success)
            print("[DEBUG] ysssssssssssssssssssssssssssssssssssssssssssssss")
            
        # Buttons with modern design - smaller size with shadow effects
        button_frame = tk.Frame(content_frame, bg="white")
        button_frame.pack(fill="x", pady=25)

        # Create shadow frames first (behind buttons)
        apply_shadow = tk.Frame(button_frame, bg="#cccccc", height=2)
        apply_shadow.place(x=12, y=32, width=160, height=2)

        skip_shadow = tk.Frame(button_frame, bg="#cccccc", height=2)  
        skip_shadow.place(x=-148, y=32, width=160, height=2, relx=1.0)

        # Primary button - smaller size
        self.apply_btn = tk.Button(
            button_frame, 
            text="Apply Code & Save 40%", 
            command=handle_apply_modified,
            font=("Arial", 10, "bold"), 
            bg="#4CAF50", 
            fg="white",
            width=18,  # Reduced width
            height=2,  # Reduced height
            cursor="hand2", 
            relief="flat",
            bd=0,
            activebackground="#45a049",
            activeforeground="white",
            padx=10,
            pady=5
        )
        self.apply_btn.pack(side="left", padx=10)

        # Secondary button - smaller size  
       
        skip_btn = tk.Button(
            button_frame, 
            text="Skip (Pay ‚Çπ349)", 
            command=handle_skip_modified,
            font=("Arial", 10, "bold"), 
            bg="white", 
            fg="#757575",
            width=18,  # Reduced width
            height=2,  # Reduced height
            cursor="hand2", 
            relief="solid",
            bd=2,
            highlightcolor="#757575",
            highlightbackground="#757575",
            activebackground="#f5f5f5",
            activeforeground="#616161",
            padx=10,
            pady=5
        )
        skip_btn.pack(side="right", padx=10)

        # Enhanced hover effects with shadow animation
        def on_apply_enter(e):
            self.apply_btn.config(bg="#45a049", relief="raised", bd=1)
            # Enhance shadow on hover
            apply_shadow.config(bg="#999999", height=3)
            apply_shadow.place(x=13, y=33, width=160, height=3)
            
        def on_apply_leave(e):
            self.apply_btn.config(bg="#4CAF50", relief="flat", bd=0)
            # Reset shadow
            apply_shadow.config(bg="#cccccc", height=2)
            apply_shadow.place(x=12, y=32, width=160, height=2)

        def on_skip_enter(e):
            skip_btn.config(bg="#f5f5f5", fg="#616161", bd=3, relief="raised")
            # Enhance shadow on hover
            skip_shadow.config(bg="#999999", height=3)
            skip_shadow.place(x=-147, y=33, width=160, height=3, relx=1.0)
            
        def on_skip_leave(e):
            skip_btn.config(bg="white", fg="#757575", bd=2, relief="solid")
            # Reset shadow
            skip_shadow.config(bg="#cccccc", height=2)
            skip_shadow.place(x=-148, y=32, width=160, height=2, relx=1.0)

        self.apply_btn.bind("<Enter>", on_apply_enter)
        self.apply_btn.bind("<Leave>", on_apply_leave)
        skip_btn.bind("<Enter>", on_skip_enter)
        skip_btn.bind("<Leave>", on_skip_leave)
        
        # Footer note - UPDATED PRICE
        footer_frame = tk.Frame(main_frame, bg="#f0f0f0", height=50)
        footer_frame.pack(fill="x", side="bottom")
        footer_frame.pack_propagate(False)
        
        tk.Label(footer_frame, text="üí° No code? During subscription you'll pay ‚Çπ349", 
                font=("Arial", 9), bg="#f0f0f0", fg="#666").pack(expand=True)
        
        # Focus
        if not auto_filled_id:
            self.referral_entry.focus()
        
        # Bind Enter key
        self.validation_window.bind('<Return>', lambda e: handle_apply_modified())
        
        # Handle window close (X button)
        def on_closing():
            print("[DEBUG] Window closed via X button")
            profile = self.load_user_profile()
            profile['referral_prompt_shown'] = True
            self.save_user_profile(profile)
            self.validation_window.destroy()
            self.main_app.after(500, self.main_app._check_license_and_payment)
        
        self.validation_window.protocol("WM_DELETE_WINDOW", on_closing)
        
        print("[DEBUG] Referral prompt window created successfully")
    
    def handle_apply_code(self):
        """Handle referral code application"""
        referral_code = self.referral_entry.get().strip().upper()
        
        if not referral_code:
            self.status_label.config(text="Please enter a referral code", fg="red")
            return
        
        print(f"[DEBUG] Applying referral code: {referral_code}")
        
        # Disable button
        self.apply_btn.config(state="disabled", text="Checking...")
        self.status_label.config(text="Validating code...", fg="blue")
        
        def validate_task():
            try:
                print(f"[DEBUG] Validating code online: {referral_code}")
                # Try online validation first
                result = self.validate_referral_id_online(referral_code)
                print(f"[DEBUG] Validation result: {result}")
                
                if result is None:
                    # No internet connection
                    print("[DEBUG] No internet - handling offline")
                    self.validation_window.after(0, lambda: self.handle_offline_validation(referral_code))
                elif result.get('valid'):
                    # Valid code
                    print("[DEBUG] Code valid - handling success")
                    self.validation_window.after(0, lambda: self.handle_valid_code(referral_code, result))
                else:
                    # Invalid code
                    print("[DEBUG] Code invalid")
                    self.validation_window.after(0, lambda: [
                        self.status_label.config(text="Invalid referral code", fg="red"),
                        self.apply_btn.config(state="normal", text="Apply Code & Save 40%")
                    ])
                    
            except Exception as e:
                print(f"[DEBUG] Validation error: {e}")
                self.validation_window.after(0, lambda: self.handle_offline_validation(referral_code))
        
        import threading
        threading.Thread(target=validate_task, daemon=True).start()
    
    def handle_skip(self):
        """Handle skip button - mark referral as complete without code"""
        print("[DEBUG] User skipped referral code entry")
        
        # Mark referral setup as complete without code
        self.referral_setup_complete = True
        self.has_referral_code = False
        self.referral_in_progress = False
        
        # Close referral window
        if self.validation_window:
            self.validation_window.destroy()
        
        # Show plan choice popup now that referral is done
        if hasattr(self, 'pending_trial_popup') and self.pending_trial_popup:
            self.pending_trial_popup = False
            # Get user profile for plan choice
            user_profile = self.load_user_profile()
            self._show_plan_choice_popup(user_profile)
    
    def handle_valid_code(self, referral_code, result):
        """Handle valid referral code - Updated to handle all failure cases uniformly with UI updates"""
        print(f"[DEBUG] Handling valid code: {referral_code}")
        
        # Get user profile
        profile = self.load_user_profile()
        # Send only fingerprint (first 8 chars)
        user_info = profile.get('machine_fingerprint', '')[:8]
        
        # Update online stats (install type)
        success = self.update_referral_stats_online(referral_code, user_info, "install")
        
        # Handle results - all failures return False from update_referral_stats_online
        if success:
            # Save locally only if online update succeeds
            self.save_referral_locally(referral_code)
            
            # Send notification to referrer
            self.send_notification_to_referrer(result, user_info, "install")
            
            # Show success
            self.show_success(referral_code, result.get('referrer_name', 'Your friend'))
            return True
        else:
            # All validation failures (duplicates, not found, etc.) - Update UI same as invalid code
            print("‚ùå Verification failed - referral code validation failed")
            
            # Update UI to show verification failed (same pattern as invalid code)
            self.status_label.config(text="Verification failed - Device alreaady registered", fg="red")
            self.apply_btn.config(state="normal", text="Apply Code & Save 40%")
            
            # Do NOT save locally, do NOT send notifications, do NOT show success
            return False
    
    def show_success(self, referral_code, referrer_name):
        """Show success message"""
        print(f"[DEBUG] Showing success for code: {referral_code}")
        
        # Clear window
        for widget in self.validation_window.winfo_children():
            widget.destroy()
        
        success_frame = tk.Frame(self.validation_window, bg="white")
        success_frame.pack(fill="both", expand=True)
        
        # Header
        header = tk.Frame(success_frame, bg="#4CAF50", height=120)
        header.pack(fill="x")
        header.pack_propagate(False)
        
        tk.Label(header, text="‚úÖ", font=("Arial", 36), 
                bg="#4CAF50", fg="white").pack(pady=10)
        tk.Label(header, text="Referral Code Applied!", 
                font=("Arial", 16, "bold"), bg="#4CAF50", fg="white").pack()
        
        # Content
        content = tk.Frame(success_frame, bg="white", pady=30)
        content.pack(fill="both", expand=True)
        
        tk.Label(content, text=f"Referred by: {referrer_name}", 
                font=("Arial", 12), bg="white").pack(pady=10)
        
        tk.Label(content, text="Your referral has been registered successfully!\nYou'll get 40% discount on subscription!", 
                font=("Arial", 11), bg="white", fg="#666", justify="center").pack(pady=10)
        
        tk.Button(content, text="Continue", 
                 command=self.close_and_continue,
                 font=("Arial", 12, "bold"), bg="#4CAF50", fg="white",
                 width=20, height=2, cursor="hand2").pack(pady=20)
        
        # Auto close after 3 seconds
        self.validation_window.after(3000, self.close_and_continue)
    
    def handle_offline_validation(self, referral_code):
        """Handle validation when offline"""
        print(f"[DEBUG] Handling offline validation for: {referral_code}")
        
        # Save locally and queue for later
        self.save_referral_locally(referral_code)
        
        # Get user info
        profile = self.load_user_profile()
        
        # Queue for later update
        self.queue_pending_update(
            referral_code, 
            profile.get('uid'),
            profile.get('machine_fingerprint'),
            "install"
        )
        
        # Show offline success
        self.show_offline_success(referral_code)
    
    def show_offline_success(self, referral_code):
        """Show offline success message"""
        print(f"[DEBUG] Showing offline success for: {referral_code}")
        
        for widget in self.validation_window.winfo_children():
            widget.destroy()
        
        success_frame = tk.Frame(self.validation_window, bg="white")
        success_frame.pack(fill="both", expand=True)
        
        # Header
        header = tk.Frame(success_frame, bg="#FF9800", height=120)
        header.pack(fill="x")
        header.pack_propagate(False)
        
        tk.Label(header, text="üìù", font=("Arial", 36), 
                bg="#FF9800", fg="white").pack(pady=10)
        tk.Label(header, text="Referral Code Saved!", 
                font=("Arial", 16, "bold"), bg="#FF9800", fg="white").pack()
        
        # Content
        content = tk.Frame(success_frame, bg="white", pady=30)
        content.pack(fill="both", expand=True)
        
        tk.Label(content, text="No internet connection detected", 
                font=("Arial", 11, "bold"), bg="white").pack(pady=5)
        
        tk.Label(content, text="Your referral code has been saved locally\nand will be verified when you're online.\nYou'll still get the 40% discount!", 
                font=("Arial", 11), bg="white", fg="#666", justify="center").pack(pady=10)
        
        tk.Button(content, text="Continue", 
                 command=self.close_and_continue,
                 font=("Arial", 12, "bold"), bg="#FF9800", fg="white",
                 width=20, height=2, cursor="hand2").pack(pady=20)
        
        self.validation_window.after(3000, self.close_and_continue)
    
    def close_and_continue(self):
        """Close window and continue"""        
        print("[DEBUG] Closing referral window")
        if self.validation_window:
            self.validation_window.destroy()
        
        # Add your referral success logic here
        print("[DEBUG] Referral applied successfully, continuing with validation")               
        profile = self.load_user_profile()
        profile['referral_prompt_shown'] = True
        self.save_user_profile(profile)                
        self.main_app.after(500, self.main_app._check_license_and_payment)
        
        if hasattr(self.main_app, 'after_referral_check'):
            self.main_app.after_referral_check()
    
class InteractiveGuide:
    def __init__(self, parent, steps):
        self.parent = parent
        self.steps = steps
        self.current_step = 0
        self.overlay_frames = []
        self.info_panel = None
        self.highlight_window = None
        
    def start(self):
        # Create info panel first
        self.create_info_panel()
        
        # Show first step
        self.show_step()
    
    def switch_to_tab(self, tab_name):
        """Switch to the specified tab in the notebook"""
        if hasattr(self.parent, 'notebook'):
            try:
                if tab_name == 'plan':
                    self.parent.notebook.select(self.parent.plan_tab)
                elif tab_name == 'live':
                    self.parent.notebook.select(self.parent.live_tab)
                elif tab_name == 'wastage':
                    self.parent.notebook.select(self.parent.wastage_tab)
                
                # Wait for tab to fully render
                self.parent.update_idletasks()
                self.parent.after(200)
            except Exception as e:
                print(f"Error switching tab: {e}")
        
    def create_overlay_with_hole(self, hole_x, hole_y, hole_width, hole_height):
        """Create 4 overlay frames around the highlighted area"""
        for frame in self.overlay_frames:
            try:
                frame.destroy()
            except:
                pass
        self.overlay_frames = []
        
        screen_width = self.parent.winfo_screenwidth()
        screen_height = self.parent.winfo_screenheight()
        
        padding = 5
        hole_x -= padding
        hole_y -= padding
        hole_width += 2 * padding
        hole_height += 2 * padding
        
        # Create overlays with click handler to prevent interaction issues
        def on_overlay_click(event=None):
            # Bring info panel to front when overlay is clicked
            if self.info_panel and self.info_panel.winfo_exists():
                self.info_panel.lift()
                self.info_panel.focus_force()
        
        # Top overlay
        if hole_y > 0:
            top = tk.Toplevel(self.parent)
            top.overrideredirect(True)
            top.attributes('-topmost', True)
            top.attributes('-alpha', 0.7)
            top.configure(bg='black')
            top.geometry(f"{screen_width}x{hole_y}+0+0")
            top.bind("<Button-1>", on_overlay_click)
            self.overlay_frames.append(top)
        
        # Bottom overlay
        bottom_y = hole_y + hole_height
        if bottom_y < screen_height:
            bottom = tk.Toplevel(self.parent)
            bottom.overrideredirect(True)
            bottom.attributes('-topmost', True)
            bottom.attributes('-alpha', 0.7)
            bottom.configure(bg='black')
            bottom_height = screen_height - bottom_y
            bottom.geometry(f"{screen_width}x{bottom_height}+0+{bottom_y}")
            bottom.bind("<Button-1>", on_overlay_click)
            self.overlay_frames.append(bottom)
        
        # Left overlay
        if hole_x > 0:
            left = tk.Toplevel(self.parent)
            left.overrideredirect(True)
            left.attributes('-topmost', True)
            left.attributes('-alpha', 0.7)
            left.configure(bg='black')
            left.geometry(f"{hole_x}x{hole_height}+0+{hole_y}")
            left.bind("<Button-1>", on_overlay_click)
            self.overlay_frames.append(left)
        
        # Right overlay
        right_x = hole_x + hole_width
        if right_x < screen_width:
            right = tk.Toplevel(self.parent)
            right.overrideredirect(True)
            right.attributes('-topmost', True)
            right.attributes('-alpha', 0.7)
            right.configure(bg='black')
            right_width = screen_width - right_x
            right.geometry(f"{right_width}x{hole_height}+{right_x}+{hole_y}")
            right.bind("<Button-1>", on_overlay_click)
            self.overlay_frames.append(right)
            
    def create_highlight_border(self, x, y, width, height, color='#3498DB'):
        """Create a highlight border around the widget"""
        if hasattr(self, 'highlight_window') and self.highlight_window:
            try:
                self.highlight_window.destroy()
            except:
                pass
            
        self.highlight_window = tk.Toplevel(self.parent)
        self.highlight_window.overrideredirect(True)
        self.highlight_window.attributes('-topmost', True)
        
        border_thickness = 4
        highlight_x = x - border_thickness
        highlight_y = y - border_thickness
        highlight_width = width + (2 * border_thickness)
        highlight_height = height + (2 * border_thickness)
        
        self.highlight_window.geometry(f"{highlight_width}x{highlight_height}+{highlight_x}+{highlight_y}")
        self.highlight_window.configure(bg=color)
        
        inner_frame = tk.Frame(self.highlight_window, bg='white')
        inner_frame.place(x=border_thickness, y=border_thickness, 
                         width=width, height=height)
        
        self.highlight_window.attributes('-transparentcolor', 'white')
        
    def create_fullscreen_overlay(self):
        """Create a simple fullscreen overlay for steps without widgets"""
        for frame in self.overlay_frames:
            try:
                frame.destroy()
            except:
                pass
        self.overlay_frames = []
        
        if hasattr(self, 'highlight_window') and self.highlight_window:
            try:
                self.highlight_window.destroy()
            except:
                pass
            self.highlight_window = None
        
        def on_overlay_click(event=None):
            # Bring info panel to front when overlay is clicked
            if self.info_panel and self.info_panel.winfo_exists():
                self.info_panel.lift()
                self.info_panel.focus_force()
        
        overlay = tk.Toplevel(self.parent)
        overlay.attributes('-fullscreen', True)
        overlay.attributes('-topmost', True)
        overlay.attributes('-alpha', 0.7)
        overlay.configure(bg='black')
        overlay.overrideredirect(True)
        overlay.bind("<Button-1>", on_overlay_click)
        self.overlay_frames.append(overlay)
        
    def create_info_panel(self):
        self.info_panel = tk.Toplevel(self.parent)
        self.info_panel.overrideredirect(True)
        self.info_panel.configure(bg='white')
        self.info_panel.attributes('-topmost', True)
        
        # Make sure panel stays on top
        self.info_panel.bind("<Map>", lambda e: self.info_panel.lift())
        
        main_frame = tk.Frame(self.info_panel, bg='white', relief='raised', bd=3)
        main_frame.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Header - fixed height
        header_frame = tk.Frame(main_frame, bg='#3498DB', height=40)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        self.title_label = tk.Label(header_frame, text="", font=("Arial", 14, "bold"), 
                                   bg='#3498DB', fg='white')
        self.title_label.pack(pady=8)
        
        # Scrollable content frame for long descriptions
        content_frame = tk.Frame(main_frame, bg='white')
        content_frame.pack(fill='both', expand=True, padx=20, pady=(10, 5))
        
        self.desc_label = tk.Label(content_frame, text="", font=("Arial", 11), 
                                  bg='white', fg='#34495E', wraplength=350, justify='left')
        self.desc_label.pack()
        
        # Progress - fixed position
        self.progress_label = tk.Label(main_frame, text="", font=("Arial", 9), 
                                     bg='white', fg='#7F8C8D')
        self.progress_label.pack(pady=(5, 10))
        
        # Buttons - fixed at bottom
        btn_frame = tk.Frame(main_frame, bg='white', height=40)
        btn_frame.pack(side='bottom', fill='x', pady=(0, 10))
        btn_frame.pack_propagate(False)
        
        # Center the buttons in the frame
        btn_container = tk.Frame(btn_frame, bg='white')
        btn_container.place(relx=0.5, rely=0.5, anchor='center')
        
        self.prev_btn = tk.Button(btn_container, text="‚Üê Previous", font=("Arial", 10),
                                bg='#95A5A6', fg='white', width=10,
                                command=self.prev_step, cursor="hand2", bd=0)
        self.prev_btn.pack(side='left', padx=5)
        
        self.next_btn = tk.Button(btn_container, text="Next ‚Üí", font=("Arial", 10),
                                bg='#3498DB', fg='white', width=10,
                                command=self.next_step, cursor="hand2", bd=0)
        self.next_btn.pack(side='left', padx=5)
        
        self.exit_btn = tk.Button(btn_container, text="Exit", font=("Arial", 10),
                                bg='#E74C3C', fg='white', width=10,
                                command=self.exit_guide, cursor="hand2", bd=0)
        self.exit_btn.pack(side='left', padx=5)
    
    def calculate_dynamic_height(self, text):
        """Calculate required height based on text content - more accurate"""
        # Fixed heights for components
        header_height = 40  # Title header
        progress_height = 30  # Progress label
        button_height = 50  # Button frame with padding
        padding = 30  # Top and bottom padding for description
        
        # Count actual lines in text
        lines = text.split('\n')
        total_lines = len(lines)
        
        # Account for word wrapping (approximately 50 chars per line with wraplength=350)
        for line in lines:
            if len(line) > 50:
                # Add extra lines for wrapping
                total_lines += (len(line) // 50)
        
        # Each line is approximately 16 pixels high with the font size used
        text_height = total_lines * 16
        
        # Calculate total height
        total_height = header_height + padding + text_height + progress_height + button_height + 20
        
        # Enforce reasonable bounds
        return max(200, min(total_height, 450))  # Reduced max height to 450
    
    def position_info_panel_smart(self, widget_x, widget_y, widget_width, widget_height, panel_height):
        """Smart positioning to avoid covering the widget"""
        info_width = 420  # Slightly wider for better text display
        screen_width = self.parent.winfo_screenwidth()
        screen_height = self.parent.winfo_screenheight()
        padding = 30
        
        # Calculate widget center
        widget_center_x = widget_x + widget_width // 2
        widget_center_y = widget_y + widget_height // 2
        
        # Determine best position - prioritize sides for tall panels
        positions = []
        
        # If panel is tall, prefer side positions
        if panel_height > 400:
            if widget_center_x < screen_width // 2:
                positions.append((widget_x + widget_width + padding, widget_y))  # Right
            else:
                positions.append((widget_x - info_width - padding, widget_y))  # Left
        
        # Then try top/bottom
        if widget_center_y < screen_height // 2:
            positions.append((widget_x, widget_y + widget_height + padding))  # Below
        else:
            positions.append((widget_x, widget_y - panel_height - padding))  # Above
        
        # Add opposite side as fallback
        if widget_center_x >= screen_width // 2:
            positions.append((widget_x + widget_width + padding, widget_y))  # Right
        else:
            positions.append((widget_x - info_width - padding, widget_y))  # Left
        
        for pos_x, pos_y in positions:
            # Adjust position to keep panel on screen
            final_x = max(10, min(pos_x, screen_width - info_width - 10))
            final_y = max(10, min(pos_y, screen_height - panel_height - 10))
            
            # Check if position doesn't overlap widget
            if not (final_x < widget_x + widget_width and 
                    final_x + info_width > widget_x and 
                    final_y < widget_y + widget_height and 
                    final_y + panel_height > widget_y):
                self.info_panel.geometry(f"{info_width}x{panel_height}+{final_x}+{final_y}")
                return
        
        # If all positions overlap, place to the side with most space
        if widget_center_x < screen_width // 2:
            final_x = widget_x + widget_width + padding
        else:
            final_x = widget_x - info_width - padding
        
        final_x = max(10, min(final_x, screen_width - info_width - 10))
        final_y = max(10, min(widget_y, screen_height - panel_height - 10))
        
        self.info_panel.geometry(f"{info_width}x{panel_height}+{final_x}+{final_y}")
    
    def show_step(self):
        if self.current_step >= len(self.steps):
            self.exit_guide()
            return
            
        step = self.steps[self.current_step]
        
        # Update info panel content
        self.title_label.config(text=step['title'])
        self.desc_label.config(text=step['description'])
        self.progress_label.config(text=f"Step {self.current_step + 1} of {len(self.steps)}")
        
        # Calculate dynamic height based on description length
        dynamic_height = self.calculate_dynamic_height(step['description'])
        
        # Update button states
        self.prev_btn.config(state='normal' if self.current_step > 0 else 'disabled')
        self.next_btn.config(text="Finish" if self.current_step == len(self.steps) - 1 else "Next ‚Üí")
        
        # Switch to required tab if specified
        required_tab = step.get('tab', None)
        if required_tab:
            self.switch_to_tab(required_tab)
            self.parent.update()
            self.parent.after(100)
        
        # Get widget position
        widget = step.get('widget')
        highlight_color = step.get('highlight_color', '#3498DB')
        
        if widget:
            try:
                if widget.winfo_exists() and widget.winfo_viewable():
                    self.parent.update_idletasks()
                    widget.update_idletasks()
                    
                    x = widget.winfo_rootx()
                    y = widget.winfo_rooty()
                    width = widget.winfo_width()
                    height = widget.winfo_height()
                    
                    self.create_overlay_with_hole(x, y, width, height)
                    self.create_highlight_border(x, y, width, height, highlight_color)
                    self.position_info_panel_smart(x, y, width, height, dynamic_height)
                else:
                    self.create_fullscreen_overlay()
                    self.center_info_panel(dynamic_height)
            except:
                self.create_fullscreen_overlay()
                self.center_info_panel(dynamic_height)
        else:
            self.create_fullscreen_overlay()
            self.center_info_panel(dynamic_height)
        
        # Ensure proper stacking - info panel ALWAYS on top
        for frame in self.overlay_frames:
            frame.lift()
        if self.highlight_window:
            self.highlight_window.lift()
        self.info_panel.lift()
        self.info_panel.attributes('-topmost', True)
        self.info_panel.focus_force()
    
    def center_info_panel(self, height):
        """Center the info panel on screen with dynamic height"""
        info_width = 420  # Wider for better readability
        screen_width = self.parent.winfo_screenwidth()
        screen_height = self.parent.winfo_screenheight()
        info_x = (screen_width - info_width) // 2
        info_y = (screen_height - height) // 2
        self.info_panel.geometry(f"{info_width}x{height}+{info_x}+{info_y}")
            
    def next_step(self):
        if self.current_step < len(self.steps) - 1:
            self.current_step += 1
            self.show_step()
        else:
            self.exit_guide()
            
    def prev_step(self):
        if self.current_step > 0:
            self.current_step -= 1
            self.show_step()
            
    def exit_guide(self):
        try:
            for frame in self.overlay_frames:
                if frame and frame.winfo_exists():
                    frame.destroy()
            if self.highlight_window and self.highlight_window.winfo_exists():
                self.highlight_window.destroy()
            if self.info_panel and self.info_panel.winfo_exists():
                self.info_panel.destroy()
        except:
            pass
    
class ToolTip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tip_window = None
        widget.bind("<Enter>", self.show_tip)
        widget.bind("<Leave>", self.hide_tip)

    def show_tip(self, event=None):
        if self.tip_window or not self.text:
            return
        x, y, _, cy = self.widget.bbox("insert")
        x = x + self.widget.winfo_rootx() + 25
        y = y + cy + self.widget.winfo_rooty() + 25
        self.tip_window = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=self.text, background="#ffffe0",
                         relief="solid", borderwidth=1,
                         font=("Arial", 9))
        label.pack(ipadx=4)

    def hide_tip(self, event=None):
        tw = self.tip_window
        self.tip_window = None
        if tw:
            tw.destroy()
    
class PaymentWizardWithLicenseReady(tk.Toplevel):
    """Payment wizard with license ready (payment already completed) - Professional UI"""

    def __init__(self, app, unified_manager):
        super().__init__(app)
        self.app = app
        self.unified_manager = unified_manager
        
        self.title("Study Timer Pro - Complete Activation")
        
        # Professional color scheme (same as PaymentWizard)
        self.bg_color = "#4d4d4d"  # grey background - match PaymentWizard
        self.card_bg = "#2d3139"
        self.accent_color = "#4f46e5"
        self.success_color = "#10b981"
        self.warning_color = "#f59e0b"
        self.error_color = "#ef4444"
        self.text_primary = "#ffffff"
        self.text_secondary = "#9ca3af"
        
        self.configure(bg=self.bg_color)

        # Compact size - matching PaymentWizard
        self.width = 480
        self.height = 650
        self.geometry(f"{self.width}x{self.height}")
        self.resizable(False, False)
        self.transient(app)
        self.grab_set()

        # Center window
        self.update_idletasks()
        x = (self.winfo_screenwidth() - self.width) // 2
        y = (self.winfo_screenheight() - self.height) // 2
        self.geometry(f"{self.width}x{self.height}+{x}+{y}")

        self.payment_completed = True  # Payment already completed
        self.license_activated = False

        self._build_ui()
        self.protocol('WM_DELETE_WINDOW', self._on_close)

    def _build_ui(self):
        # Main container
        main_container = tk.Frame(self, bg=self.bg_color)
        main_container.pack(fill="both", expand=True)

        self._create_header(main_container)
        self._create_progress_display(main_container)
        self._create_features_showcase(main_container)
        self._create_action_buttons(main_container)
        self._create_footer(main_container)

    def _create_header(self, parent):
        # Header with success indication - compact
        header_frame = tk.Frame(parent, bg=self.card_bg, height=90)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        # Center container
        center_container = tk.Frame(header_frame, bg=self.card_bg)
        center_container.place(relx=0.5, rely=0.5, anchor="center")
        
        
        
        # Title - smaller
        tk.Label(center_container, text="Payment Confirmed",
                font=("Segoe UI", 17, "bold"), bg=self.card_bg, 
                fg=self.text_primary).pack(pady=(8, 4))
        
        # Badge
        badge_frame = tk.Frame(center_container, bg=self.success_color, padx=10, pady=3)
        badge_frame.pack()
        tk.Label(badge_frame, text="ACTIVATE NOW",
                font=("Segoe UI", 9, "bold"), bg=self.success_color, 
                fg="white").pack()

    def _create_progress_display(self, parent):
        # Status container - compact
        status_container = tk.Frame(parent, bg=self.bg_color)
        status_container.pack(fill="x", padx=22, pady=16)
        
        # Status card
        status_card = tk.Frame(status_container, bg=self.card_bg)
        status_card.pack(fill="x")
        
        inner_frame = tk.Frame(status_card, bg=self.card_bg)
        inner_frame.pack(padx=16, pady=12)
        
        self.status_var = tk.StringVar(value="‚úÖ Payment successful! Click 'Activate License' to complete setup.")
        self.status_label = tk.Label(inner_frame, textvariable=self.status_var,
                                    wraplength=self.width-80, justify="center",
                                    fg=self.text_primary, font=("Segoe UI", 10),
                                    bg=self.card_bg)
        self.status_label.pack()

    def update_status(self, message, state="info"):
        colors = {
            "info": self.text_primary,
            "success": self.success_color,
            "error": self.error_color
        }
        self.status_var.set(message)
        self.status_label.config(fg=colors.get(state, self.text_primary))

        if state == "success" and self.license_activated:
            self.status_var.set("üéâ License activated successfully! Enjoy Study Timer Pro!")
            self.status_label.config(fg=self.success_color)
            self.after(1800, self.destroy)

    def _create_features_showcase(self, parent):
        # Features container - compact
        features_container = tk.Frame(parent, bg=self.bg_color)
        features_container.pack(fill="both", expand=True, padx=22, pady=(0, 8))
        
        # Title row
        title_row = tk.Frame(features_container, bg=self.bg_color)
        title_row.pack(fill="x", pady=(0, 10))
        
        tk.Label(title_row, text="Your Premium Features",
                font=("Segoe UI", 13, "bold"),
                fg=self.text_primary, bg=self.bg_color).pack(side="left")
        
        ready_label = tk.Label(title_row, text="Ready to Activate",
                              font=("Segoe UI", 11, "bold"),
                              fg=self.success_color, bg=self.bg_color)
        ready_label.pack(side="right")
        
        # Features grid
        features_frame = tk.Frame(features_container, bg=self.bg_color)
        features_frame.pack(fill="both", expand=True)
        
        features_list = [
            ("üìä", "Analytics", "Advanced study analytics"),
            ("üèÜ", "Leaderboard", "Live global ranking"),
            ("üì±", "Telegram", "Instant notifications"),
            ("üìÑ", "PDF Reports", "Professional reports"),
            ("üéØ", "Goals", "Track study goals"),
            ("‚òÅ", "Cloud Sync", "Multi-device sync"),
            ("üìà", "Daily Reports", "Auto summaries"),
            ("‚è±", "Tracking", "Wastage analysis"),
        ]
        
        # Create 2-column grid - compact
        for i, (icon, title, desc) in enumerate(features_list):
            row = i // 2
            col = i % 2
            
            # Feature card with success colors
            card = tk.Frame(features_frame, bg=self.card_bg)
            card.grid(row=row, column=col, padx=3, pady=3, sticky="ew")
            
            # Card content - compact
            content = tk.Frame(card, bg=self.card_bg)
            content.pack(padx=10, pady=7)
            
            # Icon and title
            top_row = tk.Frame(content, bg=self.card_bg)
            top_row.pack(fill="x")
            
            tk.Label(top_row, text=icon, font=("Arial", 13),
                    fg=self.success_color, bg=self.card_bg).pack(side="left", padx=(0, 6))
            tk.Label(top_row, text=title, font=("Segoe UI", 9, "bold"),
                    fg=self.text_primary, bg=self.card_bg).pack(side="left")
            
            # Description - smaller font
            tk.Label(content, text=desc, font=("Segoe UI", 8),
                    fg=self.text_secondary, bg=self.card_bg,
                    justify="left").pack(anchor="w", pady=(2, 0))
        
        # Configure grid weights
        features_frame.grid_columnconfigure(0, weight=1)
        features_frame.grid_columnconfigure(1, weight=1)

    def _create_action_buttons(self, parent):
        # Button container - compact spacing
        button_container = tk.Frame(parent, bg=self.bg_color)
        button_container.pack(fill="x", padx=22, pady=(3, 12))
        
        # Status message above button
        status_text = "‚úÖ Payment received - Complete activation now!"
        status_color = self.success_color
        
        status_label = tk.Label(button_container, text=status_text,
                                font=("Segoe UI", 9, "bold"),
                                fg=status_color, bg=self.bg_color)
        status_label.pack(pady=(0, 8))

        # Single activation button - full width
        self.license_btn = tk.Button(button_container, text="üöÄ Activate License Now",
                                    command=self.activate_license,
                                    bg=self.success_color, fg="white",
                                    font=("Segoe UI", 11, "bold"),
                                    relief="flat", bd=0,
                                    padx=20, pady=12,
                                    cursor="hand2",
                                    activebackground="#059669",
                                    activeforeground="white",
                                    height=1)
        self.license_btn.pack(fill="x")
        
        # Start pulsing effect
        self._pulse_button()

    def _pulse_button(self):
        """Add pulsing effect to activate button"""
        if not self.license_activated and hasattr(self, 'license_btn'):
            current_bg = self.license_btn.cget("bg")
            new_bg = "#6366f1" if current_bg == self.success_color else self.success_color
            self.license_btn.config(bg=new_bg)
            self.after(500, self._pulse_button)
    
    def _create_footer(self, parent):
        # Footer - compact
        footer = tk.Frame(parent, bg=self.bg_color)
        footer.pack(side="bottom", fill="x", pady=8)
        
        tk.Label(footer, text="üéâ One click to activate your lifetime license!",
                font=("Segoe UI", 9, "bold"),
                fg=self.success_color, bg=self.bg_color).pack()

    def activate_license(self):
        """Activate license using the unified manager"""
        try:
            self.update_status("üîê Activating your license...", "info")
            self.license_btn.config(state="disabled", text="‚è≥ Activating...")
            self.update()

            user_profile = _load_profile()
            if not user_profile:
                self.update_status("‚ùå Failed to load user profile.", "error")
                self.license_btn.config(state="normal", text="üöÄ Activate License Now")
                return False

            success, message = self.unified_manager.activate_license(user_profile)
            
            if success:
                self.license_activated = True
                
                # Clean up trial data after successful activation
                if hasattr(self.app, 'trial_manager') and self.app.trial_manager:
                    self.app.trial_manager.cleanup_trial_on_payment(user_profile)
                
                # Clear tampering flags
                if 'trial_tampered' in user_profile:
                    del user_profile['trial_tampered']
                    _save_profile(user_profile)
                
                self.update_status("üéâ License activated successfully! Enjoy Study Timer Pro!", "success")
                self.license_btn.config(text="‚úÖ Successfully Activated!", state="disabled",
                                      bg=self.success_color)
                
                # Close after delay
                self.after(2000, self.destroy)
                return True
            else:
                self.update_status(f"‚ùå Activation failed: {message}", "error")
                self.license_btn.config(state="normal", text="üîÑ Retry Activation")
                return False
                
        except Exception as e:
            error_msg = f"‚ùå License activation failed: {str(e)}"
            self.update_status(error_msg, "error")
            self.license_btn.config(state="normal", text="üîÑ Retry Activation")
            return False

    def _on_close(self):
        """Handle window close - don't allow closing without activation"""
        if not self.license_activated:
            from tkinter import messagebox
            response = messagebox.askquestion("License Required", 
                "License activation is required to use the app.\n\nTry activation again?",
                parent=self)
            if response == 'yes':
                return  # Don't close, let user try again
            else:
                # User wants to exit - but don't force exit, just minimize or hide
                self.withdraw()  # Hide window instead of destroying
        else:
            self.destroy()

import os
import json
import time
import hashlib
import platform
import uuid
import psutil
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import winreg  # For Windows registry
import tempfile
import shutil

class SecureTrialManager:
    """
    Secure 7-day trial system with multiple anti-tampering measures:
    - Encrypted trial records with hardware fingerprint
    - Multiple hidden storage locations
    - Google Sheets server-side validation
    - System time tampering detection
    - Registry/system file tracking (Windows)
    - Reinstall detection
    """
    
    TRIAL_DAYS = 7
    CHECK_INTERVAL_HOURS = 1  # How often to verify trial integrity
    
    def __init__(self, gsheet_credentials, gsheet_id, unified_manager):
        self.gsheet_credentials = gsheet_credentials
        self.gsheet_id = gsheet_id
        self.unified_manager = unified_manager
        
        # Generate unique machine fingerprint
        self.machine_id = self._get_advanced_machine_fingerprint()
        
        # Encryption setup
        self.salt = self._get_or_create_salt()
        self.encryption_key = self._derive_key()
        self.fernet = Fernet(self.encryption_key)
        
        # Storage locations (reuse from unified manager + add more)
        self.storage_locations = self._get_all_storage_locations()
        
        # Google Sheets connection
        self.ws = None
        self._connect_to_sheet()
        
        # Time verification
        self.last_known_time = None
        self.time_check_points = []
        
    def _load_online_trial_with_timeout(self, user_profile, timeout_seconds=5):
        """
        Run _load_trial_from_sheet() in a background thread with a timeout.
        If it takes too long or errors, we treat online as unavailable for this run.
        Returns: (online_trial_dict or None, error_reason or None)
        error_reason is one of: None, "timeout", "error"
        """
        import threading

        result = {}
        error = {}

        def target():
            try:
                result["value"] = self._load_trial_from_sheet(user_profile)
            except Exception as e:
                error["value"] = e

        t = threading.Thread(target=target, daemon=True)
        t.start()
        t.join(timeout_seconds)

        if t.is_alive():
            print(f"[TRIAL] Online trial load timed out after {timeout_seconds} seconds.")
            return None, "timeout"

        if "value" in error:
            print(f"[TRIAL] Online trial load raised error: {error['value']}")
            return None, "error"

        return result.get("value"), None    
        
    def get_trial_location_diagnostics(self, user_profile):
        """
        Return a list of per-location diagnostics for trial data.
        Each entry has: index, path, trial_status.
        trial_status will be one of:
            - OK
            - MISSING
            - MACHINE_MISMATCH
            - INVALID_DATA
            - DECRYPT_ERROR:<ExceptionName>
            - UNEXPECTED:<ExceptionName>
        This function is defensive: it should NEVER raise, only report status.
        """
        import os
        import json

        results = []

        try:
            locations = list(getattr(self, "storage_locations", []))
        except Exception:
            locations = []

        # Adjust filenames if your trial files have different names
        filenames = [".trial_data.dat", ".trial_backup.dat"]

        for idx, location in enumerate(locations, start=1):
            status = "MISSING"
            any_file = False

            try:
                for filename in filenames:
                    trial_path = os.path.join(location, filename)
                    if os.path.exists(trial_path):
                        any_file = True
                        try:
                            with open(trial_path, "rb") as f:
                                encrypted = f.read()

                            # If for some reason self.fernet is missing, catch it
                            try:
                                decrypted = self.fernet.decrypt(encrypted)
                            except Exception as e:
                                status = f"DECRYPT_ERROR:{type(e)._name_}"
                                continue  # try other file in this location

                            try:
                                trial_data = json.loads(decrypted.decode("utf-8", errors="ignore"))
                            except Exception as e:
                                status = f"DECRYPT_ERROR:{type(e)._name_}"
                                continue

                            # Basic validation similar to your loader
                            file_mid = trial_data.get("machine_id")
                            if file_mid != getattr(self, "machine_id", None):
                                status = "MACHINE_MISMATCH"
                            elif "trial_start" not in trial_data or "trial_end" not in trial_data:
                                status = "INVALID_DATA"
                            else:
                                status = "OK"
                                # One good file is enough to mark this location OK
                                break
                        except Exception as e_inner:
                            # Error reading this particular file
                            status = f"DECRYPT_ERROR:{type(e_inner)._name_}"

                if not any_file:
                    status = "MISSING"

            except Exception as e_outer:
                status = f"UNEXPECTED:{type(e_outer)._name_}"

            results.append(
                {
                    "index": idx,
                    "path": location,
                    "trial_status": status,
                }
            )

        return results
        
    def get_offline_trial_status(self, user_profile):
        """
        Return a summary of where trial files exist and how many are valid.
        Does NOT change any logic, only for diagnostics.
        """
        total_locations = len(self.storage_locations)
        any_trial_locations = 0      # locations where ANY trial file exists
        valid_trial_locations = 0    # locations where decrypted + valid trial exists

        filenames = [".trial_data.dat", ".trial_backup.dat"]
        uid = user_profile.get("uid")

        for location in self.storage_locations:
            loc_has_any = False
            loc_has_valid = False

            for filename in filenames:
                trial_file = os.path.join(location, filename)
                if os.path.exists(trial_file):
                    loc_has_any = True
                    try:
                        with open(trial_file, "rb") as f:
                            encrypted = f.read()
                        decrypted = self.fernet.decrypt(encrypted)
                        trial_data = json.loads(decrypted.decode("utf-8"))

                        # Basic validation ‚Äì same style as _load_trial_from_all_locations
                        if (
                            trial_data.get("machine_id") == self.machine_id
                            and "trial_start" in trial_data
                            and "trial_end" in trial_data
                        ):
                            loc_has_valid = True
                            break  # no need to check other file in this location
                    except Exception:
                        # ignore errors ‚Äì just means this particular file is not valid
                        pass

            if loc_has_any:
                any_trial_locations += 1
            if loc_has_valid:
                valid_trial_locations += 1

        # For trial, 1 valid location is usually enough;
        # this flag just tells you "do we have at least one sane copy?"
        trial_ok = valid_trial_locations >= 1

        return {
            "trial_ok": trial_ok,
            "valid_trial_locations": valid_trial_locations,
            "any_trial_locations": any_trial_locations,
            "total_locations": total_locations,
        }
        
    def update_time_checkpoints(self):
        """Update time checkpoint files to current time"""
        current_time = time.time()
        
        for location in self.storage_locations:
            try:
                time_file = os.path.join(location, ".time_check")
                with open(time_file, 'w') as f:
                    f.write(str(current_time))
            except Exception as e:
                print(f"[TRIAL] Failed to update time checkpoint in {location}: {e}")
        
        print(f"[TRIAL] Updated time checkpoints to: {datetime.fromtimestamp(current_time)}")
        
    def dev_nuclear_cleanup(self):
        """DEV ONLY - Delete ALL trial + tamper data (safe, won't touch source folder)"""
        import shutil
        print("[DEV] Starting nuclear cleanup...")

        # 1. Delete from all storage locations (only specific files)
        for location in self.storage_locations:
            try:
                if os.path.exists(location) and os.path.isdir(location):
                    for filename in os.listdir(location):
                        # only delete trial/license type files
                        if any(x in filename.lower() for x in ['.trial', '.st_', '.time_', '.integrity', '.backup']):
                            file_path = os.path.join(location, filename)
                            os.remove(file_path)
                            print(f"[DEV] Deleted: {file_path}")
            except Exception as e:
                print(f"[DEV] Error cleaning {location}: {e}")

        # 2. Delete Windows Registry keys
        if platform.system() == "Windows":
            try:
                import winreg
                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, r"SOFTWARE\\StudyTimerPro")
                print("[DEV] Deleted registry key")
            except Exception:
                pass

        # 3. Delete AppData folders
        appdata_locations = [
            os.path.join(os.getenv('APPDATA', ''), 'StudyTimer'),
            os.path.join(os.getenv('APPDATA', ''), '.st_hidden'),
            os.path.join(os.getenv('LOCALAPPDATA', ''), 'StudyTimer'),
        ]
        for loc in appdata_locations:
            try:
                if os.path.exists(loc):
                    shutil.rmtree(loc)
                    print(f"[DEV] Deleted: {loc}")
            except Exception as e:
                print(f"[DEV] Error deleting {loc}: {e}")

        # 4. Delete ProgramData locations
        if platform.system() == "Windows":
            programdata = os.environ.get("PROGRAMDATA", "")
            pd_locations = [
                os.path.join(programdata, "StudyTimerPro"),
                os.path.join(programdata, "STData"),
            ]
            for loc in pd_locations:
                try:
                    if os.path.exists(loc):
                        shutil.rmtree(loc)
                        print(f"[DEV] Deleted: {loc}")
                except Exception as e:
                    print(f"[DEV] Error deleting {loc}: {e}")

        # 5. Delete trial salt file
        try:
            salt_file = app_paths.trial_salt_file
            if os.path.exists(salt_file):
                os.remove(salt_file)
                print(f"[DEV] Deleted salt file")
        except Exception as e:
            print(f"[DEV] Error deleting salt: {e}")

        # 6. üßπ NEW ‚Äî Tamper folders cleanup (important after secret conversion)
        tamper_locations = [
            r"C:\ProgramData\.stp",
            r"C:\Users\krish\AppData\Local\Temp\.st1",
            r"C:\Users\krish\AppData\Local\.st2",
            r"C:\Users\krish\.st3",
            r"C:\Windows\Temp\.st4"
        ]
        for loc in tamper_locations:
            try:
                if os.path.exists(loc):
                    shutil.rmtree(loc)
                    print(f"[DEV] Deleted tamper folder: {loc}")
            except Exception as e:
                print(f"[DEV] Error deleting tamper folder {loc}: {e}")

        print("[DEV] Nuclear cleanup complete ‚úÖ (Trial + Tamper data wiped, source safe)")
        
    def _get_advanced_machine_fingerprint(self):
        """Generate a more robust machine fingerprint"""
        try:
            identifiers = [
                platform.system(),
                platform.machine(),
                platform.processor(),
                str(uuid.getnode()),  # MAC address
                platform.node(),  # Computer name
            ]
            
            # Add Windows-specific identifiers
            if platform.system() == "Windows":
                try:
                    # Get Windows Product ID
                    key = winreg.OpenKey(
                        winreg.HKEY_LOCAL_MACHINE,
                        r"SOFTWARE\Microsoft\Windows NT\CurrentVersion"
                    )
                    product_id = winreg.QueryValueEx(key, "ProductId")[0]
                    identifiers.append(product_id)
                    winreg.CloseKey(key)
                except:
                    pass
                
                # Get BIOS serial number
                try:
                    import subprocess
                    result = subprocess.run(
                        ["wmic", "bios", "get", "serialnumber"],
                        capture_output=True, text=True
                    )
                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        if len(lines) > 1:
                            identifiers.append(lines[1].strip())
                except:
                    pass
            
            # Add disk serial
            try:
                for disk in psutil.disk_partitions():
                    if disk.device and 'cdrom' not in disk.opts:
                        identifiers.append(disk.device)
                        break
            except:
                pass
            
            combined = '|'.join(str(i) for i in identifiers if i)
            return hashlib.sha256(combined.encode()).hexdigest()
            
        except Exception as e:
            print(f"[TRIAL] Fingerprint generation error: {e}")
            return hashlib.sha256(str(uuid.getnode()).encode()).hexdigest()
    
    def _get_all_storage_locations(self):
        """5 separate locations that survive folder deletion"""
        locations = []
        system = platform.system()
        
        if system == "Windows":
            # 1. ProgramData (survives uninstall)
            locations.append(os.path.join(os.environ.get("PROGRAMDATA", "C:\\ProgramData"), ".stp"))
            
            # 2. User temp (survives folder delete)
            locations.append(os.path.join(tempfile.gettempdir(), ".st1"))
            
            # 3. LocalAppData (survives folder delete)
            locations.append(os.path.join(os.environ.get("LOCALAPPDATA", ""), ".st2"))
            
            # 4. User profile root (survives folder delete)
            locations.append(os.path.join(os.path.expanduser("~"), ".st3"))
            
            # 5. Windows System32 temp (survives everything)
            locations.append(os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "Temp", ".st4"))
        
        # Create and hide all locations
        for loc in locations:
            try:
                os.makedirs(loc, exist_ok=True)
                if system == "Windows":
                    import ctypes
                    ctypes.windll.kernel32.SetFileAttributesW(loc, 2)  # Hidden
            except:
                pass
        
        return locations
    
    
    def start_trial(self, user_profile):
        """Initialize a new 7-day trial"""
        try:
            # ‚úÖ STEP 1: Check if trial was EVER started
            if user_profile.get('trial_ever_started'):
                print("[TRIAL] Trial was already started before")
                
                if self.unified_manager._check_internet():
                    online_trial = self._load_trial_from_sheet(user_profile)
                    if online_trial:
                        try:
                            trial_end = datetime.fromisoformat(online_trial['trial_end'])
                            now = datetime.now()
                            
                            if now > trial_end:
                                return False, "Your trial has expired. Please purchase a license to continue."
                            else:
                                days_remaining = (trial_end - now).days
                                print("[TRIAL] Trial already exists - restoring local files")
                                self._save_trial_data_everywhere(online_trial)
                                return True, f"Trial restored. {days_remaining} days remaining."
                        except:
                            return False, "Trial data error. Please contact support."
                # ‚úÖ Offline and files deleted - mark as tampered
                user_profile['trial_tampered'] = True
                user_profile['tamper_reason'] = 'Trial files deleted'
                self._save_profile_helper(user_profile)
                return False, "Trial already used. Please connect to internet or purchase a license."
            
            # ‚úÖ STEP 2: Check if trial already exists online
            if self.unified_manager._check_internet():
                online_trial = self._load_trial_from_sheet(user_profile)
                if online_trial:
                    try:
                        trial_end = datetime.fromisoformat(online_trial['trial_end'])
                        now = datetime.now()
                        
                        if now > trial_end:
                            return False, "Your trial has expired. Please purchase a license to continue."
                        else:
                            days_remaining = (trial_end - now).days
                            print("[TRIAL] Trial already exists - restoring local files")
                            self._save_trial_data_everywhere(online_trial)
                            
                            # ‚úÖ Mark that trial was started
                            user_profile['trial_ever_started'] = True
                            self._save_profile_helper(user_profile)
                            
                            return True, f"Trial restored. {days_remaining} days remaining."
                    except:
                        return False, "Trial data error. Please contact support."
            
            # ‚úÖ STEP 3: Create new trial
            print("[TRIAL] Creating new trial")
            start_time = datetime.now()
            end_time = start_time + timedelta(days=self.TRIAL_DAYS)
            
            trial_data = {
                'machine_id': self.machine_id,
                'user_uid': user_profile.get('uid', ''),
                'user_name': user_profile.get('user_name', ''),
                'trial_start': start_time.isoformat(),
                'trial_end': end_time.isoformat(),
                'trial_days': self.TRIAL_DAYS,
                'install_id': str(uuid.uuid4()),
                'creation_timestamp': time.time(),
                'time_checkpoints': [time.time()],
                'version': 1
            }
            # ‚úÖ DEBUG: Print storage locations before save
            print("[TRIAL-DEBUG] About to save to these locations:")
            for i, loc in enumerate(self.storage_locations, 1):
                exists = "‚úÖ EXISTS" if os.path.exists(loc) else "‚ùå MISSING"
                print(f"[TRIAL-DEBUG]   {i}. {exists} - {loc}")
            success = self._save_trial_data_everywhere(trial_data)
            
            if not success:
                return False, "Failed to save trial data to sufficient locations"
            
            self._save_trial_to_sheet(trial_data, user_profile)
            
            # ‚úÖ Mark that trial was started
            user_profile['trial_ever_started'] = True
            self._save_profile_helper(user_profile)
            print("[TRIAL] Marked trial_ever_started = True in profile")
            
            return True, f"7-day trial started. Expires on {end_time.strftime('%Y-%m-%d %H:%M')}"
            
        except Exception as e:
            print(f"[TRIAL] Error starting trial: {e}")
            import traceback
            traceback.print_exc()
            return False, f"Failed to start trial: {str(e)}"

    def _save_profile_helper(self, user_profile):
        """Helper to save profile from trial manager"""
        try:
            import json
            appdata_path = os.path.join(os.getenv('APPDATA', os.path.expanduser('~')), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            os.makedirs(appdata_path, exist_ok=True)
            
            with open(profile_path, 'w') as f:
                json.dump(user_profile, f, indent=2)
            print("[TRIAL] Profile saved")
        except Exception as e:
            print(f"[TRIAL] Error saving profile: {e}")
    
    def _save_trial_data_everywhere(self, trial_data):
        """Save trial data to all storage locations"""
        encrypted_data = self.fernet.encrypt(json.dumps(trial_data).encode())
        success_count = 0
        
        for location in self.storage_locations:
            try:
                os.makedirs(location, exist_ok=True)
                if platform.system() == "Windows":
                    try:
                        import ctypes
                        ctypes.windll.kernel32.SetFileAttributesW(location, 2)
                    except:
                        pass
                
                # ‚úÖ FIX: Use just the filename, not full path
                trial_file = os.path.join(location, ".trial_data.dat")
                with open(trial_file, 'wb') as f:
                    f.write(encrypted_data)
                
                backup_file = os.path.join(location, ".trial_backup.dat")
                with open(backup_file, 'wb') as f:
                    f.write(encrypted_data)
                
                time_file = os.path.join(location, ".time_check")
                with open(time_file, 'w') as f:
                    f.write(str(time.time()))
                
                success_count += 1
                print(f"[TRIAL] ‚úÖ Saved to: {location}")
                
            except Exception as e:
                print(f"[TRIAL] ‚ùå Failed: {location}: {e}")
        
        print(f"[TRIAL] Successfully saved to {success_count}/{len(self.storage_locations)} locations")
        return success_count >= 3
    
    def validate_trial(self, user_profile):
        """
        FINAL TRIAL LOGIC (matching license pattern):

        1) Detect tampering first (offline).
        2) Load local trial from all locations.
        3) If internet is available:
             -> Try to load online trial with 5s timeout.
             -> If timeout/error: ignore online and rely on offline only.
        4) If online_trial exists but local_trial is missing:
             -> If trial expired online: expired (no restore).
             -> If still valid: restore trial files to ALL locations from online.
        5) If no trial anywhere: 'no_trial'.
        6) If local_trial exists but online_trial does not and internet is OK:
             -> Push local trial to sheet (first-time sync).
        7) If both exist:
             -> Check consistency.
             -> Use most restrictive (earliest end).
        8) Check machine_id and expiry.
        9) If valid and not expired:
             -> Update time checkpoints.
             -> Refresh trial files in ALL 5 locations (repair partial deletions).
        """
        from datetime import datetime

        # ---------- STEP 1: TAMPERING CHECK ----------
        try:
            tamper_result = self._detect_tampering()
        except Exception as e:
            print(f"[TRIAL] Tamper detection error: {e}")
            tamper_result = {"tampered": False, "reason": ""}

        if tamper_result.get("tampered"):
            reason = tamper_result.get("reason", "Trial tampering detected")
            print(f"[TRIAL] Tampering detected: {reason}")
            return "tampered", reason, 0

        # ---------- STEP 2: LOAD OFFLINE TRIAL ----------
        try:
            local_trial = self._load_trial_from_all_locations()
        except Exception as e:
            print(f"[TRIAL] Error loading local trial: {e}")
            local_trial = None

        # ---------- STEP 3: INTERNET / ONLINE TRIAL WITH TIMEOUT ----------
        internet_available = False
        online_trial = None
        online_error = None

        try:
            if hasattr(self, "unified_manager") and self.unified_manager:
                internet_available = self.unified_manager._check_internet()
            else:
                internet_available = False
        except Exception as e:
            print(f"[TRIAL] _check_internet error: {e}")
            internet_available = False

        if internet_available:
            online_trial, online_error = self._load_online_trial_with_timeout(
                user_profile,
                timeout_seconds=5
            )
            # If timeout or error -> treat as "no online" for this run
            if online_error in ("timeout", "error"):
                online_trial = None
        else:
            online_error = "no_internet"

        # ---------- STEP 4: ONLINE EXISTS, LOCAL MISSING (DELETED FILES CASE) ----------
        if online_trial and not local_trial:
            print("[TRIAL] Trial exists online but not locally - local files deleted.")

            try:
                trial_end = datetime.fromisoformat(online_trial["trial_end"])
            except Exception:
                print("[TRIAL] Invalid trial_end format in online data.")
                return "tampered", "Invalid trial data", 0

            now = datetime.now()
            if now > trial_end:
                # Trial expired online -> DO NOT restore, just expired.
                print("[TRIAL] Online trial expired - not restoring local files.")
                return "expired", "Trial period has expired", 0

            # Trial still valid -> restore to ALL 5 locations from online.
            print("[TRIAL] Online trial still valid - restoring local trial files.")
            try:
                self._save_trial_data_everywhere(online_trial)
            except Exception as e:
                print(f"[TRIAL] Error while restoring trial data everywhere: {e}")
            local_trial = online_trial

        # ---------- STEP 5: NO TRIAL ANYWHERE ----------
        if not local_trial and not online_trial:
            print("[TRIAL] No trial found (offline or online).")
            return "no_trial", "No trial found", 0

        # ---------- STEP 6: LOCAL EXISTS, ONLINE MISSING ----------
        if local_trial and not online_trial and internet_available and online_error is None:
            # First-time sync: push local trial to sheet
            try:
                print("[TRIAL] Local trial exists but no online record - syncing to sheet.")
                self._save_trial_to_sheet(local_trial, user_profile)
            except Exception as e:
                print(f"[TRIAL] Failed to sync local trial to sheet: {e}")

        # ---------- STEP 7: COMBINE LOCAL + ONLINE ----------
        trial_data = None

        if local_trial and online_trial:
            # Consistency check
            try:
                if not self._validate_consistency(local_trial, online_trial):
                    print("[TRIAL] Local/online trial inconsistency detected.")
                    return "tampered", "Trial data inconsistency detected", 0
            except Exception as e:
                print(f"[TRIAL] Error in trial consistency check: {e}")
                return "tampered", "Trial data inconsistency detected", 0

            # Use most restrictive (earliest end date)
            try:
                trial_data = self._get_most_restrictive_trial(local_trial, online_trial)
            except Exception as e:
                print(f"[TRIAL] Error choosing most restrictive trial: {e}")
                return "tampered", "Invalid trial data", 0

        elif local_trial:
            trial_data = local_trial
        else:
            trial_data = online_trial

        if not trial_data:
            # Very defensive; should not normally hit this
            print("[TRIAL] No valid trial_data after combination.")
            return "no_trial", "No trial found", 0

        # ---------- STEP 8: MACHINE + EXPIRY CHECK ----------
        try:
            trial_machine = trial_data.get("machine_id")
            if trial_machine != getattr(self, "machine_id", None):
                print(f"[TRIAL] Machine mismatch: trial_machine={trial_machine}, current={self.machine_id}")
                return "tampered", "Trial transferred from different machine", 0

            trial_end = datetime.fromisoformat(trial_data["trial_end"])
        except Exception as e:
            print(f"[TRIAL] Invalid trial data structure: {e}")
            return "tampered", "Invalid trial data", 0

        now = datetime.now()
        if now > trial_end:
            print("[TRIAL] Trial period has expired based on combined data.")
            return "expired", "Trial period has expired", 0

        days_remaining = max(0, (trial_end - now).days)

        # ---------- STEP 9: TIME CHECKPOINTS + REPAIR OFFLINE FILES ----------
        try:
            self.update_time_checkpoints()
        except Exception as e:
            print(f"[TRIAL] Error updating time checkpoints: {e}")

        # IMPORTANT: Refresh trial data to ALL locations
        # This repairs partial deletions while still respecting trial_end.
        try:
            self._save_trial_data_everywhere(trial_data)
            print("[TRIAL] Trial data refreshed to all locations (repair/consistency).")
        except Exception as e:
            print(f"[TRIAL] Failed to refresh trial data everywhere: {e}")

        # ---------- STEP 10: RETURN VALID STATUS ----------
        print(f"[TRIAL] Trial valid. Days remaining: {days_remaining}")
        return "valid", f"Trial active: {days_remaining} days remaining", days_remaining
    
    def _detect_tampering(self):
        """Detect various tampering attempts.

        We now focus on:
          1) System time moved backwards (via .time_check files)
          2) Selective deletion (suspiciously few files vs expected)

        We also UPDATE .time_check forward when time is OK so that
        going back in time later will be detected.
        """
        print("[TAMPER-DEBUG] ==================")
        print("[TAMPER-DEBUG] Starting tampering detection")

        tampering_indicators = []

        # ---------- Count actual files ----------
        actual_files = 0
        filenames = [".trial_data.dat", ".trial_backup.dat", ".time_check"]

        print(f"[TAMPER-DEBUG] Checking {len(self.storage_locations)} locations")

        for location in self.storage_locations:
            location_files = 0
            try:
                for name in filenames:
                    path = os.path.join(location, name)
                    if os.path.exists(path):
                        actual_files += 1
                        location_files += 1
                if location_files > 0:
                    print(f"[TAMPER-DEBUG] Found {location_files} files in: {location}")
            except Exception as e:
                print(f"[TAMPER-DEBUG] Error counting files in {location}: {e}")

        print(f"[TAMPER-DEBUG] Total files found: {actual_files}")

        # Early exit for fresh start
        if actual_files == 0:
            print("[TAMPER-DEBUG] No files - not tampering (fresh start)")
            print("[TAMPER-DEBUG] ==================")
            return {"tampered": False, "reason": None}

        # ---------- 1. Check system time backwards movement ----------
        print("[TAMPER-DEBUG] === Checking Time Reversal ===")
        current_time = time.time()
        print(f"[TAMPER-DEBUG] Current time: {current_time}")
        print(f"[TAMPER-DEBUG] Current datetime: {datetime.fromtimestamp(current_time)}")

        time_check_found = False

        for location in self.storage_locations:
            time_file = os.path.join(location, ".time_check")
            if os.path.exists(time_file):
                time_check_found = True
                try:
                    with open(time_file, "r") as f:
                        last_time = float(f.read())

                    time_diff = current_time - last_time
                    hours_diff = time_diff / 3600.0

                    print(f"[TAMPER-DEBUG] Location: {location}")
                    print(f"[TAMPER-DEBUG]   Last time: {last_time}")
                    print(f"[TAMPER-DEBUG]   Last datetime: {datetime.fromtimestamp(last_time)}")
                    print(f"[TAMPER-DEBUG]   Time difference: {time_diff:.2f} seconds ({hours_diff:.2f} hours)")

                    # If system time moved back by >5 minutes compared to stored time
                    if current_time < last_time - 300:
                        hours_back = (last_time - current_time) / 3600.0
                        print(f"[TAMPER-DEBUG] ‚ùå TIME MOVED BACKWARDS by {hours_back:.1f} hours!")
                        tampering_indicators.append(
                            f"System time moved backwards by {hours_back:.1f} hours"
                        )
                        break
                    else:
                        # ‚úÖ Time is OK -> push checkpoint forward if it's noticeably newer
                        if current_time > last_time + 1:
                            try:
                                with open(time_file, "w") as f:
                                    f.write(str(current_time))
                                print("[TAMPER-DEBUG] Updated time checkpoint for this location.")
                            except Exception as e:
                                print(f"[TAMPER-DEBUG] Failed to update time checkpoint: {e}")
                        else:
                            print("[TAMPER-DEBUG] ‚úÖ Time check passed for this location (no significant change)")
                except Exception as e:
                    print(f"[TAMPER-DEBUG] ‚ùå Error reading time file: {e}")
            else:
                print(f"[TAMPER-DEBUG] No .time_check file in: {location}")

        if not time_check_found:
            print("[TAMPER-DEBUG] ‚ö† No .time_check files found in any location!")

        # ---------- 2. Check for selective deletion ----------
        print("[TAMPER-DEBUG] === Checking Selective Deletion ===")
        expected_files = len(self.storage_locations) * 3  # trial + backup + time_check
        threshold = expected_files * 0.3  # <30% of expected -> suspicious

        print(f"[TAMPER-DEBUG] Expected files: {expected_files}")
        print(f"[TAMPER-DEBUG] Actual files: {actual_files}")
        print(f"[TAMPER-DEBUG] Threshold (30%): {threshold}")

        if actual_files > 0 and actual_files < threshold:
            print("[TAMPER-DEBUG] ‚ùå Selective deletion detected!")
            tampering_indicators.append(
                f"Selective deletion ({actual_files}/{expected_files} files)"
            )
        else:
            print("[TAMPER-DEBUG] ‚úÖ Selective deletion check passed")

        print("[TAMPER-DEBUG] === Final Result ===")
        print(f"[TAMPER-DEBUG] Tampering indicators: {tampering_indicators}")
        print("[TAMPER-DEBUG] ==================")

        if tampering_indicators:
            return {"tampered": True, "reason": "; ".join(tampering_indicators)}

        return {"tampered": False, "reason": None}
    
    def _load_trial_from_all_locations(self):
        """Load and validate trial data from all local storage locations"""
        valid_trials = []
        
        # ‚úÖ FIX: Use just the filenames
        filenames = [".trial_data.dat", ".trial_backup.dat"]
        
        for location in self.storage_locations:
            for filename in filenames:
                trial_file = os.path.join(location, filename)
                
                if os.path.exists(trial_file):
                    try:
                        with open(trial_file, 'rb') as f:
                            encrypted_data = f.read()
                        
                        decrypted = self.fernet.decrypt(encrypted_data)
                        trial_data = json.loads(decrypted.decode())
                        
                        # Validate structure
                        if all(k in trial_data for k in ['machine_id', 'trial_start', 'trial_end']):
                            valid_trials.append(trial_data)
                            print(f"[TRIAL] ‚úÖ Loaded trial from: {location}")
                            break  # Found valid trial in this location, move to next
                    except Exception as e:
                        print(f"[TRIAL] ‚ùå Failed to load from {location}: {e}")
        
        if not valid_trials:
            print("[TRIAL] No valid trials found in any location")
            return None
        
        print(f"[TRIAL] Found {len(valid_trials)} valid trial(s)")
        
        # Return the most restrictive (earliest end date)
        return min(valid_trials, key=lambda x: x.get('trial_end', '9999'))
    
    def _get_most_restrictive_trial(self, local_trial, online_trial):
        """Return the trial with the earliest end date"""
        if not local_trial:
            return online_trial
        if not online_trial:
            return local_trial
        
        local_end = datetime.fromisoformat(local_trial['trial_end'])
        online_end = datetime.fromisoformat(online_trial['trial_end'])
        
        return local_trial if local_end <= online_end else online_trial
    
    def _validate_consistency(self, local_trial, online_trial):
        """Check consistency between local and online trial data"""
        try:
            # Key fields must match
            for field in ['machine_id', 'user_uid', 'install_id']:
                if local_trial.get(field) != online_trial.get(field):
                    return False
            
            # Trial start times should be within 1 hour
            local_start = datetime.fromisoformat(local_trial['trial_start'])
            online_start = datetime.fromisoformat(online_trial['trial_start'])
            
            if abs((local_start - online_start).total_seconds()) > 3600:
                return False
            
            return True
        except:
            return False
    
    # Google Sheets integration
    def _connect_to_sheet(self):
        """Connect to Google Sheets (reuse existing connection)"""
        self.ws = self.unified_manager.ws
    
    def _save_trial_to_sheet(self, trial_data, user_profile):
        """Save trial data to user's row - use Machine_ID as primary"""
        if not self.ws:
            print("[TRIAL] No worksheet connection")
            return False
        
        try:
            # ‚úÖ Use unified manager's method which now uses Machine_ID
            row_num = self.unified_manager._get_or_create_user_row(user_profile)
            if not row_num:
                print("[TRIAL] Failed to get/create user row")
                return False
            
            print(f"[TRIAL] Saving to row {row_num}")
            
            headers = self.ws.row_values(1)
            updates = []
            
            # Trial_Start
            if 'Trial_Start' in headers:
                col = headers.index('Trial_Start') + 1
                updates.append({
                    'range': f'{self._col_to_letter(col)}{row_num}',
                    'values': [[trial_data.get('trial_start', '')]]
                })
            
            # Trial_End
            if 'Trial_End' in headers:
                col = headers.index('Trial_End') + 1
                updates.append({
                    'range': f'{self._col_to_letter(col)}{row_num}',
                    'values': [[trial_data.get('trial_end', '')]]
                })
            
            # Trial_Status
            if 'Trial_Status' in headers:
                col = headers.index('Trial_Status') + 1
                updates.append({
                    'range': f'{self._col_to_letter(col)}{row_num}',
                    'values': [['active']]
                })
            
            # Install_ID
            if 'Install_ID' in headers:
                col = headers.index('Install_ID') + 1
                updates.append({
                    'range': f'{self._col_to_letter(col)}{row_num}',
                    'values': [[trial_data.get('install_id', '')]]
                })
            
            if updates:
                self.ws.batch_update(updates)
                print(f"[TRIAL] Successfully saved to row {row_num}")
                return True
            
            return False
            
        except Exception as e:
            print(f"[TRIAL] Sheet save error: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _load_trial_from_sheet(self, user_profile):
        """Load trial data from Google Sheet"""
        if not self.ws:
            return None
        
        try:
            records = self.ws.get_all_records()
            
            user_uid = user_profile.get('uid', '')
            
            # ‚úÖ NEW: If no UID, search by machine ID only
            if not user_uid:
                print("[TRIAL] No UID in profile - searching by machine ID only")
                for record in records:
                    if record.get('Machine_ID') == self.machine_id:
                        print("[TRIAL] Found existing trial by machine ID")
                        
                        # ‚úÖ RESTORE THE UID TO PROFILE
                        user_profile['uid'] = record.get('UID', '')
                        import json
                        appdata_path = os.path.join(os.getenv('APPDATA', os.path.expanduser('~')), 'StudyTimer')
                        profile_path = os.path.join(appdata_path, 'profile.json')
                        os.makedirs(appdata_path, exist_ok=True)
                        with open(profile_path, 'w') as f:
                            json.dump(user_profile, f, indent=2)
                        print(f"[TRIAL] Restored UID to profile: {user_profile['uid']}")
                        
                        # Return trial data if exists
                        if record.get('Trial_Start') and record.get('Trial_End'):
                            return {
                                'machine_id': self.machine_id,
                                'user_uid': user_profile.get('uid', ''),
                                'trial_start': record.get('Trial_Start'),
                                'trial_end': record.get('Trial_End'),
                                'install_id': record.get('Install_ID', ''),
                                'status': record.get('Trial_Status', 'unknown')
                            }
            
            # ‚úÖ Original logic: Search by both Machine ID and UID
            for record in records:
                if (record.get('Machine_ID') == self.machine_id and 
                    record.get('UID') == user_uid):
                    
                    if record.get('Trial_Start') and record.get('Trial_End'):
                        return {
                            'machine_id': self.machine_id,
                            'user_uid': user_profile.get('uid', ''),
                            'trial_start': record.get('Trial_Start'),
                            'trial_end': record.get('Trial_End'),
                            'install_id': record.get('Install_ID', ''),
                            'status': record.get('Trial_Status', 'unknown')
                        }
            
            return None
            
        except Exception as e:
            print(f"[TRIAL] Sheet load error: {e}")
            return None
    
    def _col_to_letter(self, col_num):
        """Convert column number to letter (1=A, 2=B, etc.)"""
        result = ""
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + 65) + result
            col_num //= 26
        return result
    
    def cleanup_trial_on_payment(self, user_profile):
        """Thoroughly remove ALL trial data after successful payment"""
        try:
            print("[TRIAL] Starting comprehensive trial cleanup after payment...")

            # Remove from ALL local storage locations
            for location in self.storage_locations:
                try:
                    if os.path.exists(location) and os.path.isdir(location):
                        for filename in os.listdir(location):
                            if filename.startswith('.trial') or \
                               filename.startswith('.st_') or \
                               filename.startswith('.time_') or \
                               filename == '.integrity':
                                file_path = os.path.join(location, filename)
                                try:
                                    os.remove(file_path)
                                    print(f"[TRIAL] Removed: {file_path}")
                                except:
                                    pass
                        try:
                            if not os.listdir(location):
                                os.rmdir(location)
                        except:
                            pass
                except Exception as e:
                    print(f"[TRIAL] Error cleaning {location}: {e}")

            # ‚úÖ Update Google Sheet - mark trial as converted
            if self.ws:
                try:
                    row_num = self.unified_manager._find_user_row(user_profile)
                    if row_num:
                        headers = self.ws.row_values(1)
                        updates = []
                        if 'Trial_Status' in headers:
                            col = headers.index('Trial_Status') + 1
                            updates.append({
                                'range': f'{self._col_to_letter(col)}{row_num}',
                                'values': [['converted_to_paid']]  # ‚úÖ Mark as converted
                            })
                        if updates:
                            self.ws.batch_update(updates)
                            print("[TRIAL] Google Sheet updated - trial marked as converted")
                except Exception as e:
                    print(f"[TRIAL] Sheet update error: {e}")

            # Remove salt file
            try:
                salt_file = app_paths.trial_salt_file
                if os.path.exists(salt_file):
                    os.remove(salt_file)
                    print("[TRIAL] Removed trial salt file")
            except:
                pass

            print("[TRIAL] Trial data cleanup completed successfully")
            return True

        except Exception as e:
            print(f"[TRIAL] Cleanup error: {e}")
            return False

            # 3. Clear trial salt file
            salt_file = app_paths.trial_salt_file
            if os.path.exists(salt_file):
                try:
                    os.remove(salt_file)
                    print("[TRIAL] Removed trial salt file")
                except:
                    pass

            print("[TRIAL] Trial data cleanup completed successfully")
            return True

        except Exception as e:
            print(f"[TRIAL] Cleanup error: {e}")
            return False


    def _get_or_create_salt(self):
        """Get or create encryption salt"""
        salt_file = app_paths.trial_salt_file
        if os.path.exists(salt_file):
            with open(salt_file, 'rb') as f:
                return f.read()
        else:
            salt = os.urandom(32)
            with open(salt_file, 'wb') as f:
                f.write(salt)
            return salt
            
    def _derive_key(self):
        """Derive encryption key from machine fingerprint"""
        password = f"TrialKey{self.machine_id}Secret2024".encode()
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt,
            iterations=100000
        )
        return base64.urlsafe_b64encode(kdf.derive(password))
    
# Razorpay Payment Integration for Study Timer App
import razorpay
import webbrowser
import threading
from flask import Flask, request, render_template_string, jsonify
import json
import time
from datetime import datetime



PAYMENT_AMOUNT = 19900  # Amount in paise 19900
import requests
import urllib3
from requests.adapters import HTTPAdapter
from urllib3.util.ssl_ import create_urllib3_context

# Disable SSL warnings
urllib3.disable_warnings()

# Create custom session that ignores SSL issues
class CustomHTTPAdapter(HTTPAdapter):
    def init_poolmanager(self, *args, **kwargs):
        ctx = create_urllib3_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        kwargs['ssl_context'] = ctx
        return super().init_poolmanager(*args, **kwargs)

session = requests.Session()
session.mount('https://', CustomHTTPAdapter())

# Monkey patch requests to use our session
requests.get = session.get
requests.post = session.post

# Now initialize Razorpay - it will use the patched requests
razorpay_client = razorpay.Client(auth=(RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET))

# Initialize Razorpay client
razorpay_client = razorpay.Client(auth=(RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET))
from secrets_util import get_encrypted_gspread_client


class UnifiedLicenseManager:
    """Clean unified manager for both payments and licenses in single Google Sheet row"""
    
    def __init__(self, gsheet_credentials, gsheet_id):
        self.gsheet_credentials = gsheet_credentials
        self.gsheet_id = gsheet_id
        from config_paths import app_paths
        self.license_file = app_paths.get_data_file("app_license.dat")
        self.payment_file = app_paths.get_data_file("payment_status.json")
        self.machine_id = self._get_machine_fingerprint()
        
        # Encryption setup
        self.salt = self._get_or_create_salt()
        self.encryption_key = self._derive_key()
        self.fernet = Fernet(self.encryption_key)
        
        # Define multiple hidden storage locations
        self.storage_locations = self._get_storage_locations()
        
        # Single worksheet connection
        self.ws = None
        self._connect_unified_gsheet()
        self.gspread_client = get_encrypted_gspread_client()
        
    def get_location_diagnostics(self, user_profile):
        """
        Return a list of per-location diagnostics dictionaries.
        Each entry describes payment_status and license_status for one storage path.
        """
        results = []
        uid = user_profile.get("uid")

        for idx, location in enumerate(getattr(self, "storage_locations", []), start=1):
            info = {
                "index": idx,
                "path": location,
                "payment_status": "MISSING",   # default
                "license_status": "MISSING",   # default
            }

            # ---- Payment file diagnostics ----
            try:
                payment_path = os.path.join(location, "payment_status.json")
                if not os.path.exists(payment_path):
                    info["payment_status"] = "MISSING"
                else:
                    try:
                        with open(payment_path, "r", encoding="utf-8") as f:
                            data = json.load(f)

                        file_mid   = data.get("machine_id")
                        file_uid   = data.get("uid")
                        file_stat  = data.get("status")
                        payment_id = data.get("payment_id")
                        checksum   = data.get("checksum", "")

                        if file_mid != self.machine_id:
                            info["payment_status"] = "MACHINE_MISMATCH"
                        elif file_uid != uid:
                            info["payment_status"] = "UID_MISMATCH"
                        elif file_stat != "paid":
                            info["payment_status"] = f"STATUS_{file_stat}"
                        elif not self._verify_checksum(payment_id, checksum):
                            info["payment_status"] = "CHECKSUM_FAIL"
                        else:
                            info["payment_status"] = "OK"
                    except Exception as e:
                        info["payment_status"] = f"READ_ERROR:{type(e)._name_}"
            except Exception as e:
                info["payment_status"] = f"UNEXPECTED:{type(e)._name_}"

            # ---- License file diagnostics ----
            try:
                license_path = os.path.join(location, "app_license.dat")
                if not os.path.exists(license_path):
                    info["license_status"] = "MISSING"
                else:
                    try:
                        with open(license_path, "rb") as f:
                            encrypted = f.read()
                        decrypted = self.fernet.decrypt(encrypted)
                        license_info = json.loads(decrypted.decode("utf-8", errors="ignore"))

                        file_mid    = license_info.get("machine_id")
                        license_key = license_info.get("license_key", "")
                        checksum    = license_info.get("checksum", "")

                        if file_mid != self.machine_id:
                            info["license_status"] = "MACHINE_MISMATCH"
                        elif not license_key:
                            info["license_status"] = "EMPTY_KEY"
                        elif not self._verify_checksum(license_key, checksum):
                            info["license_status"] = "CHECKSUM_FAIL"
                        else:
                            info["license_status"] = "OK"
                    except Exception as e:
                        info["license_status"] = f"DECRYPT_ERROR:{type(e)._name_}"
            except Exception as e:
                info["license_status"] = f"UNEXPECTED:{type(e)._name_}"

            results.append(info)

        return results
        
    def _check_online_status_with_timeout(self, user_profile, timeout_seconds=5):
        """
        Run check_online_status() in a background thread with a timeout.
        If it takes too long or errors, we fall back to offline validation.
        Returns: (online_status_dict or None, error_reason or None)
        """
        result = {}
        error = {}

        def target():
            try:
                result["value"] = self.check_online_status(user_profile)
            except Exception as e:
                error["value"] = e

        t = threading.Thread(target=target, daemon=True)
        t.start()
        t.join(timeout_seconds)

        if t.is_alive():
            print(f"[LICENSE] Online check timed out after {timeout_seconds} seconds.")
            return None, "timeout"

        if "value" in error:
            print(f"[LICENSE] Online check raised error: {error['value']}")
            return None, "error"

        return result.get("value"), None
    
    def _get_storage_locations(self):
        """Get multiple hidden locations across the system for license storage"""
        import tempfile
        import platform
        
        locations = []
        system = platform.system()
        
        # Location 1: App directory (existing)
        locations.append(os.path.dirname(os.path.abspath(__file__)))
        
        # Location 2: User temp directory with hidden subfolder
        temp_dir = os.path.join(tempfile.gettempdir(), ".studytimer_cache")
        os.makedirs(temp_dir, exist_ok=True)
        if system == "Windows":
            # Hide the folder on Windows
            import ctypes
            ctypes.windll.kernel32.SetFileAttributesW(temp_dir, 2)
        locations.append(temp_dir)
        
        # Location 3: User home directory hidden folder
        home_dir = os.path.expanduser("~")
        hidden_home = os.path.join(home_dir, ".studytimer_data")
        os.makedirs(hidden_home, exist_ok=True)
        if system == "Windows":
            import ctypes
            ctypes.windll.kernel32.SetFileAttributesW(hidden_home, 2)
        locations.append(hidden_home)
        
        # Location 4: System-specific location
        if system == "Windows":
            # Windows: ProgramData
            programdata = os.environ.get("PROGRAMDATA", r"C:\ProgramData")
            system_dir = os.path.join(programdata, "StudyTimerPro")
            try:
                os.makedirs(system_dir, exist_ok=True)
                # Hide it
                import ctypes
                ctypes.windll.kernel32.SetFileAttributesW(system_dir, 2)
                locations.append(system_dir)
            except:
                pass
        else:
            # Unix-like: /var/tmp
            system_dir = os.path.join("/var/tmp", ".studytimer")
            try:
                os.makedirs(system_dir, exist_ok=True)
                locations.append(system_dir)
            except:
                pass
        
        # Location 5: AppData/Local (Windows) or .local (Unix)
        if system == "Windows":
            local_app = os.environ.get("LOCALAPPDATA", "")
            if local_app:
                app_local = os.path.join(local_app, "StudyTimerPro", ".data")
                try:
                    os.makedirs(app_local, exist_ok=True)
                    import ctypes
                    ctypes.windll.kernel32.SetFileAttributesW(app_local, 2)
                    locations.append(app_local)
                except:
                    pass
        else:
            local_dir = os.path.join(home_dir, ".local", "share", "studytimer")
            try:
                os.makedirs(local_dir, exist_ok=True)
                locations.append(local_dir)
            except:
                pass
        
        # Add checksums to verify integrity
        for loc in locations:
            checksum_file = os.path.join(loc, app_paths.integrity_file)
            if not os.path.exists(checksum_file):
                with open(checksum_file, 'w') as f:
                    f.write(self.machine_id)
        
        return locations
        
    def check_license_in_sheet(self, user_profile):
        """Check if user has license key in Google Sheet"""
        if not self.ws:
            return False
        
        try:
            records = self.ws.get_all_records()
            
            for record in records:
                if (record.get('Machine_ID') == self.machine_id and 
                    record.get('UID') == user_profile.get('uid', '')):
                    
                    license_key = record.get('License_Key', '').strip()
                    status = record.get('Status', '').lower()
                    
                    # Check if has license key and status is not deactivated
                    if license_key and status != 'deactivated':
                        print(f"[GSHEET] License found: {license_key[:8]}... Status: {status}")
                        return True
                    else:
                        print(f"[GSHEET] No valid license. Key: {bool(license_key)}, Status: {status}")
                        return False
            
            print("[GSHEET] User not found in sheet")
            return False
            
        except Exception as e:
            print(f"[GSHEET] Error checking license: {e}")
            return False
        
    def save_license_locally(self, license_key, user_profile):
        """Save license to all hidden locations"""
        license_info = {
            'machine_id': self.machine_id,
            'license_key': license_key,
            'user_name': user_profile.get('user_name', ''),
            'created_at': datetime.now().isoformat(),
            'checksum': self._generate_checksum(license_key)
        }
        
        encrypted_data = self.fernet.encrypt(json.dumps(license_info).encode())
        
        success_count = 0
        for location in self.storage_locations:
            try:
                license_path = os.path.join(location, "app_license.dat")  # ‚úÖ Fixed filename
                with open(license_path, 'wb') as f:
                    f.write(encrypted_data)
                
                success_count += 1
                print(f"[LICENSE] ‚úÖ Saved license to: {location}")
            except Exception as e:
                print(f"[LICENSE] ‚ùå Failed to save to {location}: {e}")
        
        print(f"[LICENSE] License saved to {success_count}/{len(self.storage_locations)} locations")
        return success_count >= 3
        
        
    # Local file methods
    def save_payment_locally(self, payment_data, user_profile):
        """Save payment to all hidden locations"""
        amount = payment_data.get('amount', 0) or 0
        method = (
            payment_data.get('method')
            or payment_data.get('payment_method')
            or payment_data.get('bank')
            or ''
        )

        data = {
            'machine_id': self.machine_id,
            'uid': user_profile.get('uid', ''),
            'payment_id': payment_data.get('id', ''),
            'payment_method': method,
            'payment_amount': amount,
            'status': 'paid',
            'paid_at': datetime.now().isoformat(),
            'checksum': self._generate_checksum(payment_data.get('id', ''))
        }
        
        success_count = 0
        for location in self.storage_locations:
            try:
                # ‚úÖ FIX: Use just the filename
                payment_path = os.path.join(location, "payment_status.json")
                with open(payment_path, 'w') as f:
                    json.dump(data, f, indent=2)
                
                success_count += 1
                print(f"[PAYMENT] ‚úÖ Saved payment to: {location}")
            except Exception as e:
                print(f"[PAYMENT] ‚ùå Failed to save to {location}: {e}")
        
        print(f"[PAYMENT] Payment saved to {success_count}/{len(self.storage_locations)} locations")
        return success_count >= 3
        
        
    def check_offline_status(self, user_profile):
        """Check offline files from all locations"""
        payment_valid_count = 0
        license_valid_count = 0
        total_locations = len(self.storage_locations)
        
        for location in self.storage_locations:
            # Check payment file
            try:
                # ‚úÖ FIX: Use just the filename
                payment_path = os.path.join(location, "payment_status.json")
                if os.path.exists(payment_path):
                    with open(payment_path, 'r') as f:
                        data = json.load(f)
                    
                    if (data.get('machine_id') == self.machine_id and 
                        data.get('uid') == user_profile.get('uid', '') and
                        data.get('status') == 'paid'):
                        
                        if self._verify_checksum(data.get('payment_id', ''), data.get('checksum', '')):
                            payment_valid_count += 1
                            print(f"[OFFLINE] ‚úÖ Valid payment in: {location}")
            except Exception as e:
                print(f"[OFFLINE] ‚ùå Payment check failed in {location}: {e}")
            
            # Check license file
            try:
                # ‚úÖ FIX: Use just the filename
                license_path = os.path.join(location, "app_license.dat")
                if os.path.exists(license_path):
                    with open(license_path, 'rb') as f:
                        encrypted_data = f.read()
                    
                    decrypted_data = self.fernet.decrypt(encrypted_data)
                    license_info = json.loads(decrypted_data.decode())
                    
                    if (license_info.get('machine_id') == self.machine_id and
                        license_info.get('license_key')):
                        
                        if self._verify_checksum(license_info.get('license_key', ''), 
                                               license_info.get('checksum', '')):
                            license_valid_count += 1
                            print(f"[OFFLINE] ‚úÖ Valid license in: {location}")
            except Exception as e:
                print(f"[OFFLINE] ‚ùå License check failed in {location}: {e}")
        
        # Require majority of locations
        required_count = max(3, total_locations // 2 + 1)
        
        print(f"[OFFLINE] Payment: {payment_valid_count}/{total_locations}, License: {license_valid_count}/{total_locations}")
        
        return {
            "payment": payment_valid_count >= required_count,
            "license": license_valid_count >= required_count,
            "payment_count": payment_valid_count,
            "license_count": license_valid_count,
            "total_locations": total_locations
        }
        
    def _generate_checksum(self, data):
        """Generate a checksum for data verification"""
        combined = f"{self.machine_id}:{data}:{self.salt.hex()}"
        return hashlib.sha256(combined.encode()).hexdigest()
    
    def _verify_checksum(self, data, checksum):
        """Verify data checksum"""
        expected = self._generate_checksum(data)
        return expected == checksum
    
    def comprehensive_validation(self, user_profile):
        """
        FINAL LOGIC:
        - If internet is available and server responds in time:
            -> ONLINE is source of truth.
            -> If valid online, refresh offline files from server.
        - If internet is NOT available or server times out / errors:
            -> OFFLINE validation only.
        """
        internet_available = self._check_internet()
        offline_status = self.check_offline_status(user_profile)

        # ---------- STEP 1: INTERNET AVAILABLE -> ONLINE FIRST ----------
        if internet_available:
            online_status, online_error = self._check_online_status_with_timeout(
                user_profile,
                timeout_seconds=5  # you can tweak this
            )

            # If the sheet isn't reachable (e.g., timezone/region blocks),
            # treat it as an online failure and fall back to offline validation
            if online_status and online_status.get("error"):
                print(f"[LICENSE] Online validation error: {online_status['error']} - falling back to OFFLINE validation.")
                online_error = online_status.get("error") if isinstance(online_status, dict) else "error"
                online_status = None

            if online_status is not None:
                # 1A) Online says this is a brand-new / first-time user (no license row yet)
                if online_status.get("first_time_user"):
                    print("[LICENSE] Online: first-time user (no license row yet).")
                    return False, "first_time_user"

                # 1B) Online says license is valid
                if online_status.get("payment") and online_status.get("license"):
                    print("[LICENSE] Online license valid - server is source of truth.")

                    # Refresh / repair offline files from server so offline mode stays correct
                    try:
                        self.recover_offline_files_from_online(user_profile)
                        print("[LICENSE] Offline files refreshed from server.")
                    except Exception as e:
                        print(f"[LICENSE] Failed to refresh offline files: {e}")

                    return True, "License valid (online)"

                # 1C) Online explicitly says license is NOT valid
                print("[LICENSE] Online check: license NOT valid (payment or license missing/invalid).")
                return False, "Online license invalid"

            # If we are here: timeout or error in online check, fall back to offline
            print(f"[LICENSE] Online validation unavailable ({online_error}); falling back to OFFLINE validation.")

        # ---------- STEP 2: NO RELIABLE ONLINE -> OFFLINE ONLY ----------
        print("[LICENSE] Using OFFLINE validation only.")

        if offline_status.get("payment") and offline_status.get("license"):
            print("[LICENSE] Offline license valid (quorum satisfied).")
            return True, "License valid (offline)"

        # If no offline license at all:
        #   - either completely fresh user -> will be handled as trial/first-time elsewhere
        #   - or no valid license for this machine.
        print("[LICENSE] No valid offline license found.")
        return False, "No license found"
        
    def _sync_offline_to_online(self, user_profile, offline_status):
        """Sync offline license to Google Sheets"""
        if not self.ws:
            return False
        
        try:
            # Read license key from offline files
            license_key = None
            payment_id = None
            
            for location in self.storage_locations:
                try:
                    # Get license key
                    license_path = os.path.join(location, "app_license.dat")
                    if os.path.exists(license_path):
                        with open(license_path, 'rb') as f:
                            encrypted_data = f.read()
                        
                        decrypted_data = self.fernet.decrypt(encrypted_data)
                        license_info = json.loads(decrypted_data.decode())
                        
                        if license_info.get('machine_id') == self.machine_id:
                            license_key = license_info.get('license_key')
                            break
                except:
                    pass
            
            for location in self.storage_locations:
                try:
                    # Get payment ID
                    payment_path = os.path.join(location, "payment_status.json")
                    if os.path.exists(payment_path):
                        with open(payment_path, 'r') as f:
                            payment_data = json.load(f)
                        
                        if payment_data.get('machine_id') == self.machine_id:
                            payment_id = payment_data.get('payment_id')
                            break
                except:
                    pass
            
            if not license_key or not payment_id:
                print("[SYNC] Could not read offline files")
                return False
            
            # Update Google Sheet
            row_num = self._get_or_create_user_row(user_profile)
            if not row_num:
                print("[SYNC] Could not get sheet row")
                return False
            
            updates = [
                {'range': f'D{row_num}', 'values': [['active']]},  # Status
                {'range': f'G{row_num}', 'values': [[payment_id]]},  # Payment_ID
                {'range': f'J{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]},  # Payment_Date
                {'range': f'K{row_num}', 'values': [[license_key]]},  # License_Key
                {'range': f'L{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]},  # License_Date
            ]
            
            self.ws.batch_update(updates)
            print(f"[SYNC] ‚úÖ Synced offline license to sheet row {row_num}")
            return True
            
        except Exception as e:
            print(f"[SYNC] Sync failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _remove_all_local_files(self):
        """Remove all license and payment files from ALL locations"""
        print("[LICENSE] Removing all local files due to deactivation...")
        
        for location in self.storage_locations:
            try:
                # Remove license file
                license_path = os.path.join(location, self.license_file)
                if os.path.exists(license_path):
                    os.remove(license_path)
                    print(f"[LICENSE] Removed license from {location}")
                
                # Remove payment file
                payment_path = os.path.join(location, self.payment_file)
                if os.path.exists(payment_path):
                    os.remove(payment_path)
                    print(f"[LICENSE] Removed payment from {location}")
                
                # Remove verification files
                for file in os.listdir(location):
                    if file.startswith(".verify_") or file == app_paths.integrity_file:
                        os.remove(os.path.join(location, file))
                
            except Exception as e:
                print(f"[LICENSE] Error removing files from {location}: {e}")
    
    def _cleanup_invalid_files(self):
        """Remove files that fail validation"""
        for location in self.storage_locations:
            try:
                # Check integrity file
                integrity_path = os.path.join(location, app_paths.integrity_file)
                if os.path.exists(integrity_path):
                    with open(integrity_path, 'r') as f:
                        stored_id = f.read().strip()
                    
                    if stored_id != self.machine_id:
                        # Wrong machine - remove all files in this location
                        for file in os.listdir(location):
                            os.remove(os.path.join(location, file))
                        print(f"[LICENSE] Cleaned invalid files from {location}")
            except Exception:
                pass
    
    def _resync_local_files(self, user_profile):
        """Resync valid files to all locations if some are missing"""
        offline_status = self.check_offline_status(user_profile)
        
        # If not all locations have files, find a valid one and copy
        if offline_status["payment_count"] < len(self.storage_locations):
            valid_payment_data = None
            for location in self.storage_locations:
                try:
                    payment_path = os.path.join(location, self.payment_file)
                    if os.path.exists(payment_path):
                        with open(payment_path, 'r') as f:
                            data = json.load(f)
                        if self._verify_checksum(data.get('payment_id', ''), data.get('checksum', '')):
                            valid_payment_data = data
                            break
                except Exception:
                    pass
            
            # Resync to missing locations
            if valid_payment_data:
                for location in self.storage_locations:
                    payment_path = os.path.join(location, self.payment_file)
                    if not os.path.exists(payment_path):
                        try:
                            with open(payment_path, 'w') as f:
                                json.dump(valid_payment_data, f, indent=2)
                        except Exception:
                            pass
    
    def _connect_unified_gsheet(self):
        """Connect to unified Google Sheet"""
        try:
            # Try encrypted credentials first
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Fallback to original file-based method
                if not os.path.exists(self.gsheet_credentials):
                    self.ws = None
                    return
                
                import gspread
                from oauth2client.service_account import ServiceAccountCredentials
                
                scope = ["https://www.googleapis.com/auth/spreadsheets", 
                        "https://www.googleapis.com/auth/drive"]
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.gsheet_credentials, scope)
                gc = gspread.authorize(creds)
            
            if self.gsheet_id.startswith("http"):
                sheet = gc.open_by_url(self.gsheet_id)
            else:
                sheet = gc.open_by_key(self.gsheet_id)
            
            try:
                self.ws = sheet.worksheet("UserRecords")
            except gspread.WorksheetNotFound:
                self.ws = sheet.add_worksheet(title="UserRecords", rows="1000", cols="15")
                headers = [
                    'Machine_ID', 'User_Name', 'UID', 'Status', 'Date_Created', 'Last_Updated',
                    'Payment_ID', 'Payment_Method', 'Payment_Amount', 'Payment_Date', 
                    'License_Key', 'License_Date', 'Last_Validated', 'Email', 'Phone'
                ]
                self.ws.append_row(headers)
                
        except Exception as e:
            print(f"[UNIFIED] Connection failed: {e}")
            self.ws = None
    
    def _find_user_row(self, user_profile):
        """Find existing user row or return None"""
        if not self.ws:
            return None
        
        try:
            records = self.ws.get_all_records()
            for i, record in enumerate(records, start=2):
                if (record.get('Machine_ID') == self.machine_id and 
                    record.get('UID') == user_profile.get('uid', '')):
                    return i
            return None
        except Exception as e:
            print(f"[UNIFIED] Error finding user row: {e}")
            return None
    
    def _create_user_row(self, user_profile):
        """Create new user row"""
        if not self.ws:
            return None
        
        try:
            row = [
                self.machine_id,                                    # Machine_ID
                user_profile.get('user_name', ''),                 # User_Name
                user_profile.get('uid', ''),                       # UID
                'inactive',                                         # Status
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),      # Date_Created
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),      # Last_Updated
                '', '', '', '',                                     # Payment fields (empty)
                '', '', '',                                         # License fields (empty)
                '', ''                                              # Email, Phone (empty)
            ]
            
            self.ws.append_row(row)
            
            # Return the row number of newly created row
            records = self.ws.get_all_records()
            return len(records) + 1
            
        except Exception as e:
            print(f"[UNIFIED] Error creating user row: {e}")
            return None
    
    def _get_or_create_user_row(self, user_profile):
        """Get or create user row - use Machine_ID as primary key"""
        if not self.ws:
            return None
        
        try:
            records = self.ws.get_all_records()
            
            # ‚úÖ PRIMARY: Search by Machine_ID first
            for idx, record in enumerate(records, start=2):
                if record.get('Machine_ID') == self.machine_id:
                    print(f"[UNIFIED] Found existing row {idx} by Machine_ID")
                    
                    # ‚úÖ Update UID if it changed
                    stored_uid = record.get('UID', '')
                    current_uid = user_profile.get('uid', '')
                    
                    if stored_uid != current_uid and current_uid:
                        print(f"[UNIFIED] UID changed - updating from {stored_uid} to {current_uid}")
                        headers = self.ws.row_values(1)
                        if 'UID' in headers:
                            uid_col = headers.index('UID') + 1
                            self.ws.update_cell(idx, uid_col, current_uid)
                            user_profile['uid'] = current_uid
                            
                    return idx
            
            # ‚úÖ SECONDARY: Search by UID (legacy support)
            user_uid = user_profile.get('uid', '')
            if user_uid:
                for idx, record in enumerate(records, start=2):
                    if record.get('UID') == user_uid:
                        print(f"[UNIFIED] Found existing row {idx} by UID (updating Machine_ID)")
                        
                        headers = self.ws.row_values(1)
                        if 'Machine_ID' in headers:
                            mid_col = headers.index('Machine_ID') + 1
                            self.ws.update_cell(idx, mid_col, self.machine_id)
                        
                        return idx
            
            # ‚úÖ Not found - create new row
            print(f"[UNIFIED] Creating new row for Machine_ID: {self.machine_id}")
            
            # Ensure UID exists
            if not user_profile.get('uid'):
                import uuid
                user_profile['uid'] = str(uuid.uuid4())
            
            # ‚úÖ CORRECT: ALL 19 columns in exact order
            new_row = [
                self.machine_id,                                    # A: Machine_ID
                user_profile.get('user_name', ''),                 # B: User_Name
                user_profile.get('uid'),                           # C: UID
                'inactive',                                         # D: Status
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),      # E: Date_Created ‚úÖ
                '',                                                 # F: Last_Updated
                '',                                                 # G: Payment_ID
                '',                                                 # H: Payment_Method
                '',                                                 # I: Payment_Amount
                '',                                                 # J: Payment_Date
                '',                                                 # K: License_Key
                '',                                                 # L: License_Date
                '',                                                 # M: Last_Validated
                '',                                                 # N: Email ‚úÖ ADDED
                '',                                                 # O: Phone ‚úÖ ADDED
                '',                                                 # P: Trial_Start
                '',                                                 # Q: Trial_End
                '',                                                 # R: Trial_Status
                ''                                                  # S: Install_ID
            ]
            
            self.ws.append_row(new_row)
            return len(records) + 2
            
        except Exception as e:
            print(f"[UNIFIED] Error in _get_or_create_user_row: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    # Payment Methods
    def create_payment_order(self, user_profile):
        """Create Razorpay payment order securely via backend API (with auto anonymous login)"""
        from api_client import api  # ‚úÖ ensure imported once at top of file

        try:
            # 1Ô∏è‚É£  If no token, do anonymous login first
            if not api.id_token:
                print("[PAYMENT] No token found, logging in anonymously...")
                login_resp = api.anonymous_login()
                print("[DEBUG] Anonymous login response:", login_resp)  # üëÄ Check what comes back

                if login_resp.get("success") and login_resp.get("idToken"):
                    api.set_auth_token(login_resp["idToken"])
                    print("[PAYMENT] ‚úÖ Anonymous token set")
                else:
                    print("[PAYMENT] ‚ùå Anonymous login failed")
                    return False, "Anonymous login failed"

            # 2Ô∏è‚É£  Confirm header is set properly (debug)
            print("[DEBUG] Headers being sent:", api._headers())

            # 3Ô∏è‚É£  Payment amount
            amount = PAYMENT_AMOUNT  # example: 199
            currency = 'INR'

            # 4Ô∏è‚É£  Create order from backend
            order_response = api.create_payment(amount=amount, currency=currency)
            print("[DEBUG] Order response from backend:", order_response)

            if order_response.get('success'):
                print("[PAYMENT] ‚úÖ Order created successfully")
                return True, order_response
            else:
                error_msg = order_response.get('error', 'Unknown error')

                # 5Ô∏è‚É£  If Unauthorized, try refreshing token once
                if "Unauthorized" in str(error_msg):
                    print("[PAYMENT] Token may have expired. Retrying anonymous login...")
                    api.id_token = None
                    retry_login = api.anonymous_login()
                    if retry_login.get("success") and retry_login.get("idToken"):
                        api.set_auth_token(retry_login["idToken"])
                        print("[PAYMENT] ‚úÖ New anonymous token set")
                        order_response = api.create_payment(amount=amount, currency=currency)
                        print("[DEBUG] Order response after retry:", order_response)
                        if order_response.get('success'):
                            return True, order_response
                        else:
                            return False, f"Order creation failed after retry: {order_response.get('error')}"
                    else:
                        return False, "Failed to refresh token"

                print(f"[PAYMENT] ‚ùå Order creation failed: {error_msg}")
                return False, f"Order creation failed: {error_msg}"

        except Exception as e:
            print(f"[PAYMENT] ‚ùå Exception: {str(e)}")
            return False, f"Order creation failed: {str(e)}"

    
    def save_payment_to_sheet(self, payment_data, user_profile):
        """Save payment to existing user row"""
        if not self.ws:
            return False
        
        try:
            row_num = self._get_or_create_user_row(user_profile)
            if not row_num:
                return False
            
            raw_amount = payment_data.get('amount')
            if raw_amount is None or raw_amount == '':
                raw_amount = payment_data.get('payment_amount', 0)

            try:
                raw_amount = float(raw_amount)
            except Exception:
                raw_amount = 0

            # Razorpay returns amount in paise; assume paise for large values
            amount = raw_amount / 100 if raw_amount > 1000 else raw_amount

            method = (
                payment_data.get('method')
                or payment_data.get('payment_method')
                or payment_data.get('bank')
                or ''
            )

            # Update payment columns in existing row
            updates = [
                {'range': f'D{row_num}', 'values': [['payment_completed']]},           # Status
                {'range': f'F{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]}, # Last_Updated
                {'range': f'G{row_num}', 'values': [[payment_data.get('id', '')]]},   # Payment_ID
                {'range': f'H{row_num}', 'values': [[method]]}, # Payment_Method
                {'range': f'I{row_num}', 'values': [[amount]]}, # Payment_Amount
                {'range': f'J{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]}, # Payment_Date
                {'range': f'N{row_num}', 'values': [[payment_data.get('email', '')]]}, # Email
                {'range': f'O{row_num}', 'values': [[payment_data.get('contact', '')]]}, # Phone
            ]
            
            self.ws.batch_update(updates)
            print(f"[UNIFIED] Payment saved to row {row_num}")
            if hasattr(self, 'main_app_instance'):
                self.main_app_instance.after(2000, self.main_app_instance.check_sheet_and_remove_overlays)
            return True
            
        except Exception as e:
            print(f"[UNIFIED] Payment save failed: {e}")
            return False
    
    def save_license_to_sheet(self, license_key, user_profile):
        """Save license to existing user row"""
        if not self.ws:
            return False
        
        try:
            row_num = self._get_or_create_user_row(user_profile)
            if not row_num:
                return False
            
            # Update license columns in existing row
            updates = [
                {'range': f'D{row_num}', 'values': [['active']]},                     # Status = active
                {'range': f'F{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]}, # Last_Updated
                {'range': f'K{row_num}', 'values': [[license_key]]},                 # License_Key
                {'range': f'L{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]}, # License_Date
                {'range': f'M{row_num}', 'values': [[datetime.now().strftime('%Y-%m-%d %H:%M:%S')]]}, # Last_Validated
            ]
            
            self.ws.batch_update(updates)
            print(f"[UNIFIED] License saved to row {row_num}")
            if hasattr(self, 'main_app_instance'):
                self.main_app_instance.after(2000, self.main_app_instance.check_sheet_and_remove_overlays)
            return True
            
        except Exception as e:
            print(f"[UNIFIED] License save failed: {e}")
            return False
    
    # Validation Methods
    def check_online_status(self, user_profile):
        """Check online status - use Machine_ID as primary key"""
        if not self.ws:
            return {"payment": False, "license": False, "error": "No connection"}
        
        try:
            records = self.ws.get_all_records()
            
            # ‚úÖ PRIMARY: Search by Machine_ID
            for record in records:
                if record.get('Machine_ID') == self.machine_id:
                    print(f"[VALIDATION] Found record by Machine_ID")
                    
                    # ‚úÖ Update UID in profile if different
                    stored_uid = record.get('UID', '')
                    if stored_uid and stored_uid != user_profile.get('uid'):
                        user_profile['uid'] = stored_uid
                        _save_profile(user_profile)
                        print(f"[VALIDATION] Restored UID: {stored_uid}")
                    
                    # Check status
                    status = record.get('Status', '').lower()
                    payment_id = record.get('Payment_ID', '').strip()
                    license_key = record.get('License_Key', '').strip()
                    
                    if status == 'deactivated':
                        return {
                            "payment": False, 
                            "license": False, 
                            "online_check": True, 
                            "deactivated": True,
                            "user_exists": True
                        }
                    
                    payment_valid = bool(payment_id and status != 'inactive')
                    license_valid = bool(license_key and status == 'active')
                    
                    return {
                        "payment": payment_valid,
                        "license": license_valid,
                        "online_check": True,
                        "user_exists": True
                    }
            
            # Not found by Machine_ID
            return {
                "payment": False, 
                "license": False, 
                "online_check": True,
                "user_exists": False
            }
            
        except Exception as e:
            print(f"[UNIFIED] Online check error: {e}")
            return {"payment": False, "license": False, "error": str(e)}
    
    def append_diagnostics(self, user_profile, diagnostics):
        """
        Append a diagnostics snapshot row into a 'Diagnostics' worksheet.
        ORDER:
          1) User info
          2) Trial-related (status + offline + location details)
          3) License/payment-related (status + offline + online + location details)
        """
        try:
            # ---------- COMMON HEADERS (used for both new + existing sheet) ----------
            headers = [
                # ---------- USER INFO ----------
                "Timestamp",               # 1
                "UID",                     # 2
                "User_Name",               # 3
                "Install_ID",              # 4
                "Machine_ID",              # 5

                # ---------- TRIAL (LOGIC + OFFLINE + LOCATIONS) ----------
                "Trial_Status",            # 6
                "Trial_Message",           # 7
                "Trial_Days_Remaining",    # 8
                "Offline_Trial_OK",        # 9
                "Offline_Trial_Valid_Locations",   # 10
                "Offline_Trial_Any_Locations",     # 11
                "Offline_Trial_Total_Locations",   # 12
                "Trial_Location_Details",          # 13

                # ---------- LICENSE/PAYMENT (LOGIC + OFFLINE + ONLINE + LOCATIONS) ----------
                "License_Valid",           # 14
                "License_Message",         # 15
                "Internet_Available",      # 16
                "Offline_Payment_OK",      # 17
                "Offline_License_OK",      # 18
                "Offline_Payment_Count",   # 19
                "Offline_License_Count",   # 20
                "Offline_Total_Locations", # 21
                "Online_Payment_File",     # 22  # from online_status['payment']
                "Online_License_File",     # 23  # from online_status['license']
                "Online_File_Error",       # 24  # error while checking sheet / files
                "Location_Details",        # 25  # per-location payment/license status
            ]

            # 1) Get gspread client (encrypted first, then file-based fallback)
            gc = get_encrypted_gspread_client()
            if not gc:
                if not os.path.exists(self.gsheet_credentials):
                    print("[DIAG] No valid credentials available for diagnostics.")
                    return False

                import gspread
                from oauth2client.service_account import ServiceAccountCredentials

                scope = [
                    "https://www.googleapis.com/auth/spreadsheets",
                    "https://www.googleapis.com/auth/drive",
                ]
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.gsheet_credentials, scope
                )
                gc = gspread.authorize(creds)

            # 2) Open sheet by ID or URL
            if self.gsheet_id.startswith("http"):
                sheet = gc.open_by_url(self.gsheet_id)
            else:
                sheet = gc.open_by_key(self.gsheet_id)

            # 3) Get or create Diagnostics worksheet
            import gspread  # ensure we have the update() method etc.
            try:
                ws = sheet.worksheet("Diagnostics")
            except Exception:
                # Sheet doesn't exist -> create with enough columns/rows and add headers
                ws = sheet.add_worksheet(title="Diagnostics", rows="2000", cols="40")
                ws.append_row(headers)
            else:
                # Sheet exists -> ensure header row is present and correct
                try:
                    existing_headers = ws.row_values(1)
                except Exception:
                    existing_headers = []

                # If row1 is empty or doesn't start with "Timestamp", rewrite headers
                if (not existing_headers) or (len(existing_headers) == 0) or (existing_headers[0] != "Timestamp"):
                    # Write headers directly into first row
                    ws.update("A1", [headers])

            # 4) Build row in same order as headers above
            row = [
                # ---------- USER INFO ----------
                diagnostics.get("timestamp", ""),                   # Timestamp
                diagnostics.get("uid", ""),                         # UID
                diagnostics.get("user_name", ""),                   # User_Name
                diagnostics.get("install_id", ""),                  # Install_ID
                diagnostics.get("machine_id", ""),                  # Machine_ID

                # ---------- TRIAL ----------
                diagnostics.get("trial_status", ""),                        # Trial_Status
                diagnostics.get("trial_message", ""),                       # Trial_Message
                diagnostics.get("trial_days_remaining", ""),                # Trial_Days_Remaining
                str(diagnostics.get("offline_trial_ok", "")),               # Offline_Trial_OK
                diagnostics.get("offline_trial_valid_locations", ""),       # Offline_Trial_Valid_Locations
                diagnostics.get("offline_trial_any_locations", ""),         # Offline_Trial_Any_Locations
                diagnostics.get("offline_trial_total_locations", ""),       # Offline_Trial_Total_Locations
                diagnostics.get("trial_location_details", ""),              # Trial_Location_Details

                # ---------- LICENSE / PAYMENT ----------
                str(diagnostics.get("license_valid", "")),                  # License_Valid
                diagnostics.get("license_message", ""),                     # License_Message
                str(diagnostics.get("internet_available", "")),             # Internet_Available
                str(diagnostics.get("offline_payment_ok", "")),             # Offline_Payment_OK
                str(diagnostics.get("offline_license_ok", "")),             # Offline_License_OK
                diagnostics.get("offline_payment_count", ""),               # Offline_Payment_Count
                diagnostics.get("offline_license_count", ""),               # Offline_License_Count
                diagnostics.get("offline_total_locations", ""),             # Offline_Total_Locations
                str(diagnostics.get("online_status_payment", "")),          # Online_Payment_File
                str(diagnostics.get("online_status_license", "")),          # Online_License_File
                diagnostics.get("online_status_error", ""),                 # Online_File_Error
                diagnostics.get("location_details", ""),                    # Location_Details
            ]

            ws.append_row(row)
            print("[DIAG] Diagnostics snapshot appended to Diagnostics sheet.")
            return True

        except Exception as e:
            print(f"[DIAG] Failed to append diagnostics: {e}")
            return False
               
    def recover_offline_files_from_online(self, user_profile):
        """Recover missing offline files from Google Sheets when internet is available"""
        if not self.ws:
            return False
            
        try:
            # Check what exists online for this user
            online_status = self.check_online_status(user_profile)
            
            if online_status.get("error"):
                return False
            
            # Check current offline status
            offline_status = self.check_offline_status(user_profile)
            
            files_recovered = False
            
            # Recover payment file if exists online but missing locally
            if online_status["payment"]:
                if offline_status["payment_count"] < len(self.storage_locations):
                    # Create payment data from online status
                    payment_data = {
                        'id': 'recovered_from_sheet',
                        'method': 'online_recovery',
                        'amount': PAYMENT_AMOUNT
                    }
                    
                    # Save to all locations
                    success = self.save_payment_locally(payment_data, user_profile)
                    if success:
                        print("[RECOVERY] Payment files recovered from Google Sheets to all locations")
                        files_recovered = True
            
            # Recover license file if exists online but missing locally
            if online_status["license"]:
                if offline_status["license_count"] < len(self.storage_locations):
                    # Generate license key for recovery
                    license_data = f"{self.machine_id}{user_profile.get('uid', '')}{int(time.time())}"
                    license_key = hashlib.sha256(license_data.encode()).hexdigest()[:32].upper()
                    license_key = f"{license_key[:8]}-{license_key[8:16]}-{license_key[16:24]}-{license_key[24:32]}"
                    
                    # Save to all locations
                    success = self.save_license_locally(license_key, user_profile)
                    if success:
                        print("[RECOVERY] License files recovered from Google Sheets to all locations")
                        files_recovered = True
            
            return files_recovered
            
        except Exception as e:
            print(f"[RECOVERY] Recovery failed: {e}")
            return False
    
    
    def activate_license(self, user_profile):  # FIXED: Added user_profile parameter
        """Generate and activate license"""
        try:
            # Generate license key
            license_data = f"{self.machine_id}{user_profile.get('uid', '')}{int(time.time())}"
            license_key = hashlib.sha256(license_data.encode()).hexdigest()[:32].upper()
            license_key = f"{license_key[:8]}-{license_key[8:16]}-{license_key[16:24]}-{license_key[24:32]}"
            
            # Save to sheet and locally
            sheet_success = self.save_license_to_sheet(license_key, user_profile)
            local_success = self.save_license_locally(license_key, user_profile)
            
            if sheet_success or local_success:
                return True, f"License activated: {license_key[:8]}..."
            else:
                return False, "Failed to save license"
                
        except Exception as e:
            return False, f"License activation failed: {str(e)}"
    
    # Helper methods (keeping your existing implementations)
    def _get_machine_fingerprint(self):
        try:
            identifiers = [
                platform.system(),
                platform.machine(),
                str(uuid.getnode())
            ]
            combined = '|'.join(str(i) for i in identifiers if i)
            return hashlib.sha256(combined.encode()).hexdigest()[:16]
        except:
            return "unknown_machine"
    
    def _get_or_create_salt(self):
        salt_file = app_paths.get_data_file("license.salt")
        if os.path.exists(salt_file):
            with open(salt_file, 'rb') as f:
                return f.read()
        else:
            salt = os.urandom(32)
            with open(salt_file, 'wb') as f:
                f.write(salt)
            return salt
    
    def _derive_key(self):
        """Derive encryption key from machine fingerprint"""
        password = f"TrialKey{self.machine_id}Secret2024".encode()
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt,
            iterations=100000
        )
        return base64.urlsafe_b64encode(kdf.derive(password))
    
    def _check_internet(self):
        try:
            import requests
            requests.get("https://www.google.com", timeout=3)
            return True
        except:
            return False
            
class PaymentWizard(tk.Toplevel):
    """Enhanced payment wizard with professional UI"""

    def __init__(self, app, unified_manager, allow_skip=True):
        super().__init__(app)
        self.app = app
        
        self.unified_manager = unified_manager
        self.allow_skip = allow_skip
        self.title("Study Timer Pro - Activation Required")
        self._skipped_payment = False
        self._skip_exit = False
        
        # Professional color scheme
        self.bg_color = "#4d4d4d"  # grey background
        self.card_bg = "#2d3139"   # Card background
        self.accent_color = "#4f46e5"  # Indigo accent
        self.success_color = "#10b981"  # Green
        self.warning_color = "#f59e0b"  # Amber
        self.error_color = "#ef4444"  # Red
        self.text_primary = "#ffffff"
        self.text_secondary = "#9ca3af"
        
        self.configure(bg=self.bg_color)

        # Slightly bigger size to accommodate all features
        self.width = 480
        self.height = 650
        self.geometry(f"{self.width}x{self.height}")
        self.resizable(False, False)
        self.transient(app)
        self.grab_set()

        # Center window
        self.update_idletasks()
        x = (self.winfo_screenwidth() - self.width) // 2
        y = (self.winfo_screenheight() - self.height) // 2
        self.geometry(f"{self.width}x{self.height}+{x}+{y}")

        self.payment_completed = False
        self.license_activated = False

        self._build_ui()
        self.protocol('WM_DELETE_WINDOW', self._on_close)

    def _build_ui(self):
        # Main container
        main_container = tk.Frame(self, bg=self.bg_color)
        main_container.pack(fill="both", expand=True)

        self._create_header(main_container)
        self._create_progress_display(main_container)
        self._create_features_showcase(main_container)
        self._create_action_buttons(main_container)
        self._create_footer(main_container)

    def _create_header(self, parent):
        # Header with gradient effect
        header_frame = tk.Frame(parent, bg=self.card_bg, height=90)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        # Center container
        center_container = tk.Frame(header_frame, bg=self.card_bg)
        center_container.place(relx=0.5, rely=0.5, anchor="center")
        
        
        # Title
        tk.Label(center_container, text="Study Timer Pro",
                font=("Segoe UI", 17, "bold"), bg=self.card_bg, 
                fg=self.text_primary).pack(pady=(8, 4))
        
        # Badge
        badge_frame = tk.Frame(center_container, bg=self.error_color, padx=10, pady=3)
        badge_frame.pack()
        tk.Label(badge_frame, text="ACTIVATION REQUIRED",
                font=("Segoe UI", 9, "bold"), bg=self.error_color, 
                fg="white").pack()

    def _create_progress_display(self, parent):
        # Status container
        status_container = tk.Frame(parent, bg=self.bg_color)
        status_container.pack(fill="x", padx=22, pady=16)
        
        # Status card
        status_card = tk.Frame(status_container, bg=self.card_bg)
        status_card.pack(fill="x")
        
        inner_frame = tk.Frame(status_card, bg=self.card_bg)
        inner_frame.pack(padx=16, pady=12)
        
        self.status_var = tk.StringVar(value="Please complete payment to activate your license")
        self.status_label = tk.Label(inner_frame, textvariable=self.status_var,
                                    wraplength=self.width-80, justify="center",
                                    fg=self.text_primary, font=("Segoe UI", 10),
                                    bg=self.card_bg)
        self.status_label.pack()

    def update_status(self, message, state="info"):
        colors = {
            "info": self.text_primary,
            "success": self.success_color,
            "error": self.error_color
        }
        self.status_var.set(message)
        self.status_label.config(fg=colors.get(state, self.text_primary))

        if state == "success":
            if hasattr(self, "later_btn"):
                self.later_btn.pack_forget()
            if self.license_activated:
                self.status_var.set("‚úÖ License activated successfully! Enjoy Study Timer Pro üöÄ")
                self.status_label.config(fg=self.success_color)
                self.after(1800, self.destroy)

    def _create_features_showcase(self, parent):
        # Features container - reduced gap
        features_container = tk.Frame(parent, bg=self.bg_color)
        features_container.pack(fill="both", expand=True, padx=22, pady=(0, 8))
        
        # Title row
        title_row = tk.Frame(features_container, bg=self.bg_color)
        title_row.pack(fill="x", pady=(0, 0))
        
        tk.Label(title_row, text="Premium Features",
                font=("Segoe UI", 13, "bold"),
                fg=self.text_primary, bg=self.bg_color).pack(side="left")
        
        price_label = tk.Label(title_row, text="Get Instant Access",
                              font=("Segoe UI", 11, "bold"),
                              fg=self.success_color, bg=self.bg_color)
        price_label.pack(side="right")
        
        # Features grid
        features_frame = tk.Frame(features_container, bg=self.bg_color)
        features_frame.pack(fill="both", expand=True)
        
        # ALL 8 FEATURES RESTORED
        features_list = [
            ("üìä", "Analytics", "Advanced study analytics"),
            ("üèÜ", "Leaderboard", "Live global ranking"),
            ("üì±", "Telegram", "Instant notifications"),
            ("üìÑ", "PDF Reports", "Professional reports"),
            ("üéØ", "Goals", "Track study goals"),
            ("‚òÅ", "Cloud Sync", "Multi-device sync"),
            ("üìà", "Daily Reports", "Auto summaries"),
            ("‚è±", "Tracking", "Wastage analysis"),
        ]
        
        # Create 2-column grid
        for i, (icon, title, desc) in enumerate(features_list):
            row = i // 2
            col = i % 2
            
            # Feature card
            card = tk.Frame(features_frame, bg=self.card_bg)
            card.grid(row=row, column=col, padx=3, pady=3, sticky="ew")
            
            # Card content
            content = tk.Frame(card, bg=self.card_bg)
            content.pack(padx=10, pady=7)
            
            # Icon and title
            top_row = tk.Frame(content, bg=self.card_bg)
            top_row.pack(fill="x")
            
            tk.Label(top_row, text=icon, font=("Arial", 13),
                    fg=self.accent_color, bg=self.card_bg).pack(side="left", padx=(0, 6))
            tk.Label(top_row, text=title, font=("Segoe UI", 9, "bold"),
                    fg=self.text_primary, bg=self.card_bg).pack(side="left")
            
            # Description
            tk.Label(content, text=desc, font=("Segoe UI", 8),
                    fg=self.text_secondary, bg=self.card_bg,
                    justify="left").pack(anchor="w", pady=(2, 0))
        
        # Configure grid weights
        features_frame.grid_columnconfigure(0, weight=1)
        features_frame.grid_columnconfigure(1, weight=1)
        
    def _create_action_buttons(self, parent):
        # Get user profile to check referral status
        user_profile = _load_profile()
        referral_applied = user_profile.get('referral_code') is not None
        
        # ADD REFERRAL SECTION (only if no code applied) - reduced gap
        if not referral_applied:
            referral_frame = tk.Frame(parent, bg=self.bg_color)
            referral_frame.pack(fill="x", padx=22, pady=(0, 0))
            
            tk.Label(referral_frame, text="üí∞ Have a referral code? Save ‚Çπ150!",
                    font=("Segoe UI", 9, "bold"),
                    fg=self.text_primary, bg=self.bg_color).pack(anchor="w", pady=(0, 4))
            
            input_row = tk.Frame(referral_frame, bg=self.bg_color)
            input_row.pack(fill="x")
            
            self.popup_referral_entry = tk.Entry(input_row, font=("Segoe UI", 9),
                                               relief="solid", bd=1, width=15)
            self.popup_referral_entry.pack(side="left", padx=(0, 8), ipady=4)
            
            popup_apply_btn = tk.Button(input_row, text="Apply Code",
                                      command=lambda: self.handle_apply_code_popup(),
                                      bg=self.accent_color, fg="white",
                                      font=("Segoe UI", 8, "bold"),
                                      relief="flat", bd=0, padx=12, pady=4)
            popup_apply_btn.pack(side="left")
            
            self.popup_status_label = tk.Label(referral_frame, text="",
                                             font=("Segoe UI", 8), bg=self.bg_color,
                                             fg=self.text_primary)
            self.popup_status_label.pack(anchor="w", pady=(4, 0))
        
        # Button container - reduced gap from referral section
        button_container = tk.Frame(parent, bg=self.bg_color)
        button_container.pack(fill="x", padx=22, pady=(0, 0))
        
        # Add referral status label above buttons
        if referral_applied:
            status_text = "‚úÖ Referral code applied - You save ‚Çπ150!"
            status_color = "#059862"
        else:
            status_text = "üí° No referral code - Standard pricing"
            status_color = "#666666"
        
        status_label = tk.Label(button_container, text=status_text,
                                font=("Segoe UI", 9, "bold"),
                                fg=status_color, bg=self.bg_color)
        status_label.pack(pady=(0, 8))

        # Main buttons row
        main_row = tk.Frame(button_container, bg=self.bg_color)
        main_row.pack(fill="x", pady=(0, 8))

        # Payment button - Update text to show price, fix height
        price_text = "‚Çπ199" if referral_applied else "‚Çπ349"
        button_text = f"üí≥ Complete Payment ({price_text})"
        
        self.payment_btn = tk.Button(main_row, text=button_text,
                                    command=self._start_payment_process,
                                    bg=self.success_color, fg="white",
                                    font=("Segoe UI", 10, "bold"),
                                    relief="flat", bd=0,
                                    padx=16, pady=10,
                                    cursor="hand2",
                                    activebackground="#059669",
                                    activeforeground="white",
                                    height=1)
        self.payment_btn.pack(side="left", fill="x", expand=True, padx=(0, 4))

        # License button
        self.license_btn = tk.Button(main_row, text="üîê Activate License",
                                    command=self.activate_license,
                                    bg=self.accent_color, fg="white",
                                    state="disabled",
                                    font=("Segoe UI", 10, "bold"),
                                    relief="flat", bd=0,
                                    padx=16, pady=10,
                                    cursor="hand2",
                                    activebackground="#4338ca",
                                    activeforeground="white")
        self.license_btn.pack(side="right", fill="x", expand=True, padx=(4, 0))

        # Secondary button
        if self.allow_skip:
            self.later_btn = tk.Button(
                button_container,
                text="Skip for now",
                command=self._later_clicked,
                bg="#000000",
                fg="#ffffff",
                font=("Segoe UI", 9),
                relief="flat", bd=0,
                cursor="hand2",
                activebackground="#333333",
                activeforeground="#ffffff"
            )
            self.later_btn.pack(side="right")

    # ADD THIS SIMPLE METHOD - Use correct attribute name
    def handle_apply_code_popup(self):
        """Handle referral code from popup - use correct main app reference"""
        referral_code = self.popup_referral_entry.get().strip().upper()
        
        if not referral_code:
            self.popup_status_label.config(text="Please enter a referral code", fg=self.error_color)
            return
        
        self.popup_status_label.config(text="Validating...", fg=self.text_primary)
        
        def validate_task():
            try:
                # Try different ways to access the main app
                main_app = None
                if hasattr(self, 'main_app'):
                    main_app = self.main_app
                elif hasattr(self, 'parent'):
                    main_app = self.parent
                elif hasattr(self, 'master'):
                    main_app = self.master
                elif hasattr(self, 'root'):
                    main_app = self.root
                else:
                    # Get the root window (StudyTimerApp)
                    main_app = self.winfo_toplevel()
                
                # Create ReferralValidator instance
                validator = ReferralValidator(main_app)
                
                # Step 1: Validate the referral code
                result = validator.validate_referral_id_online(referral_code)
                
                if result is None:
                    self.after(0, lambda: self.popup_status_label.config(text="No internet connection", fg=self.error_color))
                elif result.get('valid'):
                    # Step 2: Get user profile  
                    profile = validator.load_user_profile()
                    user_info = profile.get('machine_fingerprint', '')[:8]
                    
                    # Step 3: Update referral stats with duplicate check
                    success = validator.update_referral_stats_online(referral_code, user_info, "install")
                    
                    if success:
                        # Step 4: Save locally and send notification
                        validator.save_referral_locally(referral_code)
                        validator.send_notification_to_referrer(result, user_info, "install")
                        
                        # Step 5: Update UI with success
                        self.after(0, lambda: [
                            self.popup_status_label.config(text="‚úÖ Applied! Discount activated", fg=self.success_color),
                            self.payment_btn.config(text="üí≥ Complete Payment (‚Çπ199)"),
                            self.popup_referral_entry.config(state="disabled")
                        ])
                    else:
                        # Duplicate fingerprint or other validation failure
                        self.after(0, lambda: self.popup_status_label.config(text="Verification failed - Device already registered", fg=self.error_color))
                else:
                    # Invalid referral code
                    self.after(0, lambda: self.popup_status_label.config(text="Invalid referral code", fg=self.error_color))
                    
            except Exception as e:
                print(f"Error in popup referral validation: {e}")
                print(f"Available attributes: {[attr for attr in dir(self) if not attr.startswith('_')]}")
                import traceback
                traceback.print_exc()
                self.after(0, lambda: self.popup_status_label.config(text="Error occurred", fg=self.error_color))
        
        import threading
        threading.Thread(target=validate_task, daemon=True).start()

    def _create_footer(self, parent):
        # Footer
        footer = tk.Frame(parent, bg=self.bg_color)
        footer.pack(side="bottom", fill="x", pady=8)
        
        badges_row = tk.Frame(footer, bg=self.bg_color)
        badges_row.pack()
        
        tk.Label(badges_row, text="üîí Secure Payment ‚Ä¢ üíé Lifetime Access ‚Ä¢ ‚úÖ Instant Activation",
                font=("Segoe UI", 8),
                fg=self.text_secondary, bg=self.bg_color).pack()
        
    def _later_clicked(self):
        """Close payment popup without exiting app"""
        self.skip_trial_exit = True
        self.destroy()
            
    def _skip_payment_popup(self):
        """Allow skipping without triggering the exit logic."""
        self.protocol('WM_DELETE_WINDOW', lambda: None)
        self.destroy()
    
    def _start_payment_process(self):
        """
        Start payment process with referral-based pricing (via backend API).
        Works for both signed-in and guest (anonymous) users.
        """
        from api_client import api
        import time

        try:
            print("=" * 60)
            print("[PAYMENT] Starting payment process...")

            # Load local profile
            user_profile = _load_profile()
            id_token = user_profile.get("id_token")
            token_timestamp = user_profile.get("token_timestamp", 0)

            # Check if token exists and is expired
            current_time = time.time()
            token_age = current_time - token_timestamp
            # Treat negative age (clock changes) as expired to force refresh
            token_expired = token_age < 0 or token_age > 3300  # 55 minutes

            print(f"[PAYMENT] Token exists: {bool(id_token)}")
            print(f"[PAYMENT] Token age: {token_age:.0f} seconds")
            if token_age < 0:
                print("[PAYMENT] ‚ö† Token timestamp is in the future; refreshing token")
            print(f"[PAYMENT] Token expired: {token_expired}")

            # ‚úÖ Refresh or get new token if missing/expired
            if not id_token or token_expired:
                if token_expired:
                    print("[PAYMENT] Token expired, refreshing...")
                else:
                    print("[PAYMENT] No token found, logging in anonymously...")

                self.status_var.set("Initializing payment...")
                self.update()

                login_resp = api.anonymous_login()
                print(f"[PAYMENT] Login response: {login_resp}")

                if login_resp.get("success") and login_resp.get("idToken"):
                    id_token = login_resp.get("idToken")
                    print(f"[PAYMENT] ‚úÖ Received new token: {id_token[:30]}...")

                    # Set token in API client
                    api.set_auth_token(id_token)

                    # Save token + timestamp
                    user_profile["id_token"] = id_token
                    user_profile["token_timestamp"] = current_time
                    _save_profile(user_profile)
                    print("[PAYMENT] ‚úÖ Token saved to profile")
                else:
                    error_msg = login_resp.get('error', 'Unknown error')
                    print(f"[PAYMENT] ‚ùå Anonymous login failed: {error_msg}")
                    self.status_var.set(f"‚ùå Login failed: {error_msg}")
                    self.payment_btn.config(state="normal", text="üí≥ Complete Payment")
                    return
            else:
                # Token exists and is valid
                print(f"[PAYMENT] Using existing token: {id_token[:30]}...")
                api.set_auth_token(id_token)

            # ‚úÖ Double-check token set
            if not api.id_token:
                print("[PAYMENT] ‚ö† CRITICAL: api.id_token is None after setting!")
                self.status_var.set("‚ùå Token error. Please try again.")
                self.payment_btn.config(state="normal", text="üí≥ Complete Payment")
                return

            print(f"[PAYMENT] ‚úÖ Token confirmed in API: {api.id_token[:30]}...")

            # ‚úÖ Continue payment flow
            self.status_var.set("Creating payment order...")
            self.payment_btn.config(state="disabled", text="‚è≥ Processing...")
            self.update()

            # ‚úÖ Check referral discount
            referral_applied = bool(user_profile.get('referral_code'))
            payment_amount = 199 if referral_applied else 349
            print(f"[PAYMENT] Payment amount: ‚Çπ{payment_amount} (referral: {referral_applied})")

            # ‚úÖ Create payment order via backend API
            print("[PAYMENT] Calling create_payment...")
            order_response = api.create_payment(amount=payment_amount, currency='INR')
            print(f"[PAYMENT] Order response: {order_response}")

            if not order_response.get('success'):
                error_msg = order_response.get('error', 'Unknown error')
                print(f"[PAYMENT] ‚ùå Order creation failed: {error_msg}")
                self.status_var.set(f"‚ùå Order failed: {error_msg}")
                self.payment_btn.config(state="normal", text="üí≥ Complete Payment")
                return

            print(f"[PAYMENT] ‚úÖ Order created: {order_response.get('order_id')}")

            # ‚úÖ Start local payment server & browser checkout
            self._start_payment_server(order_response, user_profile)
            self.payment_btn.config(text="‚è≥ Complete payment...")
            self.status_var.set(f"üí≥ Complete payment in browser (‚Çπ{payment_amount})")

            # ‚úÖ Check payment completion
            self._check_payment_completion()

            print("=" * 60)

        except Exception as e:
            print(f"[PAYMENT] ‚ùå Exception: {type(e)._name_}: {e}")
            import traceback
            traceback.print_exc()
            self.status_var.set(f"‚ùå Payment error: {str(e)}")
            self.payment_btn.config(state="normal", text="üí≥ Complete Payment")

    
    def _start_payment_server(self, order, user_profile):
        """Start Flask payment server"""
        from flask import Flask, request, render_template_string, jsonify
        import threading
        import webbrowser
        os.environ['FLASK_SKIP_DOTENV'] = '1'
        payment_html = """
<!DOCTYPE html>
<html>
<head>
    <title>Study Timer Pro - Payment</title>
    <script src="https://checkout.razorpay.com/v1/checkout.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; display: flex; justify-content: center; align-items: center;
            padding: 20px; position: relative;
        }
        
        .background-pattern {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.1;
            background-image: radial-gradient(circle at 25% 25%, white 2px, transparent 2px),
                              radial-gradient(circle at 75% 75%, white 2px, transparent 2px);
            background-size: 50px 50px; pointer-events: none;
        }
        
        .payment-container {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px);
            border-radius: 24px; box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            padding: 50px; max-width: 480px; width: 100%; text-align: center;
            position: relative; border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .app-logo {
            width: 80px; height: 80px; background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 20px; margin: 0 auto 20px; display: flex;
            align-items: center; justify-content: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        
        .app-logo span { color: white; font-size: 36px; font-weight: 600; }
        
        .app-title {
            color: #2d3748; font-size: 28px; font-weight: 700;
            margin-bottom: 8px; letter-spacing: -0.5px;
        }
        
        .app-subtitle {
            color: #667eea; font-size: 16px; font-weight: 500; margin-bottom: 15px;
        }
        
        .user-name {
            color: #4a5568; 
            font-size: 14px; 
            font-weight: 600; 
            margin-bottom: 30px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .price-section {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border-radius: 16px; padding: 30px; margin-bottom: 30px;
            border: 1px solid #e2e8f0;
        }
        
        .price-label {
            color: #718096; font-size: 14px; font-weight: 500; margin-bottom: 8px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        
        .price {
            color: #2d3748; font-size: 48px; font-weight: 700; margin-bottom: 8px;
            background: linear-gradient(135deg, #48bb78, #38a169);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .price-description { color: #718096; font-size: 14px; font-weight: 400; }
        
        .features-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
            margin-bottom: 30px; text-align: left;
        }
        
        .feature-item {
            display: flex; align-items: center; color: #4a5568;
            font-size: 13px; font-weight: 500;
        }
        
        .feature-item::before {
            content: "‚úì"; color: #48bb78; font-weight: 700;
            margin-right: 8px; font-size: 14px;
        }
        
        .pay-button {
            background: linear-gradient(135deg, #48bb78, #38a169); color: white;
            border: none; padding: 18px 40px; font-size: 16px; font-weight: 600;
            border-radius: 12px; cursor: pointer; width: 100%; margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.3);
            transition: all 0.3s ease; font-family: inherit;
        }
        
        .pay-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(72, 187, 120, 0.4);
        }
        
        .pay-button:disabled {
            background: #cbd5e0; color: #a0aec0; cursor: not-allowed;
            transform: none; box-shadow: none;
        }
        
        .security-badges {
            display: flex; justify-content: center; align-items: center;
            gap: 20px; margin-bottom: 25px;
        }
        
        .security-badge {
            display: flex; align-items: center; color: #718096;
            font-size: 12px; font-weight: 500;
        }
        
        .security-badge::before { content: "üîí"; margin-right: 6px; }
        
        .status {
            margin-top: 20px; padding: 15px; border-radius: 8px;
            font-weight: 500; font-size: 14px; display: none;
        }
        
        .status.success {
            background: #f0fff4; color: #38a169; border: 1px solid #9ae6b4; display: block;
        }
        
        .status.error {
            background: #fed7d7; color: #e53e3e; border: 1px solid #feb2b2; display: block;
        }
        
        .loading {
            display: none; color: #667eea; font-weight: 500;
            font-size: 14px; margin-top: 15px;
        }
        
        .loading.active { display: block; animation: pulse 1.5s infinite; }
        
        .powered-by {
            margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0;
            color: #a0aec0; font-size: 12px; font-weight: 500;
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        @media (max-width: 480px) {
            .payment-container { padding: 30px; margin: 20px; }
            .features-grid { grid-template-columns: 1fr; gap: 10px; }
            .price { font-size: 40px; }
        }
    </style>
</head>
<body>
    <div class="background-pattern"></div>
    
    <div class="payment-container">
        <div class="app-logo"><span>üìö</span></div>
        <h1 class="app-title">Study Timer Pro</h1>
        <p class="app-subtitle">Premium License Activation</p>
        <p class="user-name">RAJENDRANBALAKRISHNAN</p>
        
        <div class="price-section">
            <div class="price-label">Payment</div>
            <div class="price">‚Çπ349</div>
            <div class="price-description">Enjoy your studies! ‚Ä¢ Stay connected for further updates!!</div>
        </div>
        
        <div class="features-grid">
            <div class="feature-item">Complete time tracking</div>
            <div class="feature-item">Live leaderboard sync</div>
            <div class="feature-item">Daily progress reports</div>
            <div class="feature-item">Telegram notifications</div>
            <div class="feature-item">Advanced analytics</div>
            <div class="feature-item">PDF report generation</div>
            <div class="feature-item">Session optimization</div>
            <div class="feature-item">Goal monitoring</div>
        </div>
        
        <button class="pay-button" onclick="startPayment()" id="payButton">
            Pay ‚Çπ349 & Activate License
        </button>
        
        <div class="security-badges">
            <div class="security-badge">256-bit SSL Encryption</div>
            <div class="security-badge">Secure Payment Gateway</div>
        </div>
        
        <div class="loading" id="loading">Processing your payment securely...</div>
        <div class="status" id="status"></div>
        
        <div class="powered-by">
            Powered by Razorpay ‚Ä¢ Trusted by millions of businesses
        </div>
    </div>

    <script>
        // Get referral status from template variable
        const hasReferral = {{ 'true' if has_referral else 'false' }};

        let user_profile = {
            referral_code: hasReferral ? 'applied' : null
        };

        // Initialize options with default amount
        var options = {
            "key": "{{ razorpay_key }}",
            "amount": 34900, // Default amount, will be updated by updatePriceDisplay()
            "currency": "INR",
            "name": "Study Timer Pro",
            "description": "Premium License Activation",
            "order_id": "{{ order_id }}",
            "handler": function (response) {
                showLoading(true);
                fetch('/verify_payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        payment_id: response.razorpay_payment_id,
                        order_id: response.razorpay_order_id,
                        signature: response.razorpay_signature
                    })
                })
                .then(response => response.json())
                .then(data => {
                    showLoading(false);
                    if (data.success) {
                        showStatus('success', '‚úÖ Payment successful! Your license has been activated.');
                        document.getElementById('payButton').disabled = true;
                        document.getElementById('payButton').innerHTML = '‚úÖ Payment Completed';
                        setTimeout(() => window.close(), 3000);
                    } else {
                        showStatus('error', '‚ùå Payment verification failed: ' + data.error);
                    }
                })
                .catch(error => {
                    showLoading(false);
                    showStatus('error', '‚ùå Network error occurred. Please try again.');
                });
            },
            "prefill": { "name": "Study Timer User" },
            "theme": { "color": "#667eea" },
            "method": { "upi": true, "card": true, "netbanking": true, "wallet": true }
        };

        // Function to update price based on referral status
        function updatePriceDisplay() {
            const referral_applied = user_profile?.referral_code !== null;
            const priceElement = document.querySelector('.price');
            const payButton = document.querySelector('.pay-button');
            
            if (referral_applied) {
                priceElement.textContent = "‚Çπ199";
                payButton.textContent = "Pay ‚Çπ199 & Activate License";
                // Update the amount for Razorpay (199 * 100 = 19900 paise)
                options.amount = 19900;
            } else {
                priceElement.textContent = "‚Çπ349";
                payButton.textContent = "Pay ‚Çπ349 & Activate License";
                // Update the amount for Razorpay (349 * 100 = 34900 paise)
                options.amount = 34900;
            }
        }

        function startPayment() {
            var rzp = new Razorpay(options);
            rzp.on('payment.failed', function (response) {
                showStatus('error', '‚ùå Payment failed: ' + response.error.description);
            });
            rzp.open();
        }
        
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) { loading.classList.add('active'); } 
            else { loading.classList.remove('active'); }
        }
        
        function showStatus(type, message) {
            const status = document.getElementById('status');
            status.className = "status " + type;
            status.innerHTML = message;
        }

        // Call this function when page loads
        document.addEventListener('DOMContentLoaded', updatePriceDisplay);
    </script>
</body>
</html>
        """
        
        self.flask_app = Flask(__name__)
        
        @self.flask_app.route('/')
        def payment_page():
            """Serve the payment page with order details from backend API."""
            from api_client import api  # ‚úÖ ensure imported at top of file

            # Load user profile and check referral
            user_profile = _load_profile()
            referral_applied = user_profile.get('referral_code') is not None

            # Block payment flow when system time is outside allowable drift
            time_ok, drift_seconds = is_system_time_valid()
            if not time_ok:
                drift_minutes = (drift_seconds or 0) / 60
                message = (
                    f"‚ùå System clock out of sync by {drift_minutes:.1f} minutes. "
                    "Please correct your date/time (¬±5 minutes allowed) and reopen the payment page."
                )
                return message, 400

            # Decide amount based on referral
            payment_amount = 199 if referral_applied else 349

            # ‚úÖ Create payment order via backend
            order_response = api.create_payment(amount=payment_amount, currency='INR')

            if not order_response.get('success'):
                return f"‚ùå Failed to create payment order: {order_response.get('error', 'Unknown error')}", 500

            # Extract order info for Razorpay Checkout
            order_id = order_response['order_id']
            amount_in_paise = order_response['amount'] * 100 if order_response['amount'] < 1000 else order_response['amount']
            razorpay_key = order_response['key_id']  # returned by backend

            # ‚úÖ Render the payment page with new backend order data
            return render_template_string(
                payment_html,
                razorpay_key=razorpay_key,  # frontend uses this
                amount=amount_in_paise,
                order_id=order_id,
                has_referral=referral_applied
            )

        
        @self.flask_app.route('/verify_payment', methods=['POST'])
        def verify_payment():
            """Verify Razorpay payment securely via backend API."""
            from api_client import api  # ‚úÖ ensure imported at top of file
            try:
                data = request.get_json()
                payment_id = data['payment_id']
                order_id = data['order_id']
                signature = data['signature']

                # ‚úÖ Verify signature & capture status via backend
                verify_response = api.verify_payment(order_id, payment_id, signature)

                # Guard against unexpected None/invalid responses
                if not isinstance(verify_response, dict):
                    return jsonify({'success': False, 'error': 'Invalid response from verification server'})

                if not verify_response.get('success'):
                    return jsonify({'success': False, 'error': verify_response.get('error', 'Verification failed')})

                time_ok, drift_seconds = is_system_time_valid()
                if not time_ok:
                    drift_minutes = (drift_seconds or 0) / 60
                    return jsonify({
                        'success': False,
                        'error': f'System time is off by {drift_minutes:.1f} minutes. Please correct your clock and retry payment.'
                    })

                # ‚úÖ Payment verified successfully
                payment = verify_response.get('payment') or {}

                # Normalize key names so sheet/offline storage always receive values
                payment.setdefault('id', payment_id)

                raw_amount = (
                    payment.get('amount')
                    or payment.get('payment_amount')
                    or verify_response.get('amount')
                    or verify_response.get('payment_amount')
                )

                payment['amount'] = raw_amount

                payment['method'] = (
                    payment.get('method')
                    or payment.get('payment_method')
                    or payment.get('bank')
                    or verify_response.get('method')
                    or verify_response.get('payment_method')
                )

                # Save payment (unchanged)
                user_profile = _load_profile()
                sheet_success = self.unified_manager.save_payment_to_sheet(payment, user_profile)
                local_success = self.unified_manager.save_payment_locally(payment, user_profile)

                if sheet_success or local_success:
                    return jsonify({'success': True})
                else:
                    return jsonify({'success': False, 'error': 'Failed to save payment'})

            except Exception as e:
                return jsonify({'success': False, 'error': str(e)})

        
        # Start server
        def run_server():
            import os
            os.environ['FLASK_SKIP_DOTENV'] = '1'
            self.flask_app.run(host='localhost', port=5001, debug=False, use_reloader=False)

        self.server_thread = threading.Thread(target=run_server, daemon=True)
        self.server_thread.start()
        time.sleep(2)

        webbrowser.open('http://localhost:5001')
    
    def _check_payment_completion(self):
        try:
            user_profile = _load_profile()
            offline_status = self.unified_manager.check_offline_status(user_profile)
            
            if offline_status.get("payment", False):
                self.payment_completed = True
                self.status_var.set("‚úÖ Payment completed! Click 'Activate License' to continue.")
                self.payment_btn.config(text="‚úÖ Payment Done", state="disabled",
                                      bg="#065f46")  # Darker green for completed state
                self.license_btn.config(state="normal", text="üîê Activate License")
                print("[WIZARD] Payment completed - license button enabled")
                return
            
            self.after(2000, self._check_payment_completion)
            
        except Exception as e:
            print(f"[WIZARD] Payment check error: {e}")
            self.after(5000, self._check_payment_completion)
    
    def activate_license(self):
        """Generate and activate license - with proper trial cleanup"""
        print("[WIZARD] Activate License button clicked!")
        try:
            # Update status immediately
            self.update_status("Activating license...", "info")
            self.license_btn.config(state="disabled", text="‚è≥ Activating...")
            self.update()
            
            # Check payment completion first
            if not getattr(self, "payment_completed", False):
                self.update_status("‚ùå Please complete payment before activating.", "error")
                self.license_btn.config(state="normal", text="üîê Activate License")
                return False, "‚ùå Please complete payment before activating."

            # Load user profile
            user_profile = _load_profile()
            if not user_profile:
                self.update_status("‚ùå Failed to load user profile.", "error")
                self.license_btn.config(state="normal", text="üîê Activate License")
                return False, "‚ùå Failed to load user profile."

            # Use the unified_manager to activate license
            success, message = self.unified_manager.activate_license(user_profile)
            
            if success:
                self.license_activated = True
                
                # Clean up ALL trial data after successful activation
                if hasattr(self.app, 'trial_manager') and self.app.trial_manager:
                    print("[WIZARD] Cleaning up trial data after payment...")
                    self.app.trial_manager.cleanup_trial_on_payment(user_profile)
                
                # Clear any tampering flags
                if 'trial_tampered' in user_profile:
                    del user_profile['trial_tampered']
                    _save_profile(user_profile)
                
                # DEBUG: Update referral subscription stats - FIXED
                print("[DEBUG] Attempting to update referral subscription stats...")
                if hasattr(self.app, 'referral_validator') and self.app.referral_validator:
                    print("[DEBUG] Referral validator found, calling update_to_subscription...")
                    
                    # Debug profile data before calling
                    print(f"[DEBUG] Profile referral data:")
                    print(f"  - referral_code: {user_profile.get('referral_code')}")
                    print(f"  - used_referral: {user_profile.get('used_referral')}")
                    print(f"  - referral_id_used: {user_profile.get('referral_id_used')}")
                    
                    try:
                        # Call the method on referral_validator, not referral_manager
                        referral_result = self.app.referral_validator.update_to_subscription()
                        print(f"[DEBUG] Referral update result: {referral_result}")
                        
                        if referral_result:
                            print("[DEBUG] ‚úÖ Referral subscription stats updated successfully")
                        else:
                            print("[DEBUG] ‚ùå Referral subscription stats update failed")
                            
                    except Exception as ref_error:
                        print(f"[DEBUG] Referral update error: {ref_error}")
                        import traceback
                        traceback.print_exc()
                else:
                    print("[DEBUG] No referral_validator found on app")
                
                self.update_status("üéâ License activated successfully! Enjoy your Study Timer Pro üöÄ", "success")
                self.license_btn.config(text="‚úÖ License Activated", state="disabled",
                                      bg=self.success_color)
                
                # Close the wizard after a brief delay
                self.after(2000, self.destroy)
                
                return True, message
            else:
                self.update_status(f"‚ùå Activation failed: {message}", "error")
                self.license_btn.config(state="normal", text="üîê Activate License")
                return False, message
                
        except Exception as e:
            error_msg = f"‚ùå License activation failed: {str(e)}"
            print(f"[WIZARD] License activation error: {e}")
            import traceback
            traceback.print_exc()
            
            self.update_status(error_msg, "error")
            self.license_btn.config(state="normal", text="üîê Activate License")
            return False, error_msg
    
    def _force_exit(self):
        """Force exit application"""
        try:
            self.app.destroy()
        except:
            pass
        import sys
        sys.exit(0)
    
    def _on_close(self):
        """Handle window close"""
        pass


import tkinter as tk
import json
import os
import time
from datetime import datetime, timedelta

class RunRateGraph(tk.Frame):
    """Professional run-rate chart with persistent local data storage."""
    def __init__(self, parent, width=680, height=300, exam_date=None, plan_name="Default"):
        super().__init__(parent, bg="#ffffff")
        self.w, self.h = width, height
        
        # Store plan name
        self.current_plan_name = plan_name
        
        # FIXED: Force frame size and prevent disappearing
        self.pack_propagate(False)
        self.configure(width=width, height=height)
        
        # Create main canvas with fixed size
        canvas_height = height - 40  # Make room for controls
        self.canvas = tk.Canvas(self, width=width, height=canvas_height,
                                bg="#ffffff", highlightthickness=0, bd=0)
        self.canvas.pack(side="top", fill="both", expand=False)  # FIXED: Don't expand canvas
        
        # Create control frame for zoom options
        self.control_frame = tk.Frame(self, bg="#ffffff", height=40)
        self.control_frame.pack(side="bottom", fill="x", padx=10, pady=5)
        self.control_frame.pack_propagate(False)  # FIXED: Prevent control frame from shrinking
        
        # Set exam date (string format: "YYYY-MM-DD" or datetime object)
        if isinstance(exam_date, str):
            self.exam_date = datetime.strptime(exam_date, "%Y-%m-%d")
        elif isinstance(exam_date, datetime):
            self.exam_date = exam_date
        else:
            # Default to 30 days from now if no exam date provided
            self.exam_date = datetime.now() + timedelta(days=30)
        
        self.samples = []           # list[(ts, short_min, long_min)]
        self.max_points = 10000     # Keep all points until exam date
        self.required_min = 0
        
        # Zoom settings
        self.zoom_var = tk.StringVar(value="1h")  # Default to 1h view
        self.create_zoom_controls()
        
        # Initialize persistent data file path (ONE file for all plans)
        try:
            self.data_file = app_paths.runrate_data_file
            print(f"[RUNRATE] Using shared data file: {self.data_file}")
        except (NameError, AttributeError):
            # Fallback if app_paths is not available
            import os
            self.data_file = os.path.join(os.path.expanduser("~"), "AppData", "Local", "StudyTimer", "runrate_data.json")
            print(f"[RUNRATE] Using fallback data file: {self.data_file}")
        
        # Graph area margins - adjusted for new layout
        self.margin_left = 65
        self.margin_right = 20
        self.margin_top = 30
        self.margin_bottom = 120
        
        self.graph_width = self.w - self.margin_left - self.margin_right
        self.graph_height = canvas_height - self.margin_top - self.margin_bottom
        
        # For real-time updates
        self.last_update = 0
        self.update_interval = 1.0
        
        # FIXED: Initialize with error handling
        self.initialization_complete = False
        try:
            # Load existing data on startup
            print(f"[RUNRATE] Initializing with exam date: {self.exam_date.strftime('%Y-%m-%d')}")
            self._load_historical_data()
            
            # Save initial state to ensure file exists
            if not self.samples:
                print("[RUNRATE] No samples loaded, creating initial cache file")
                self._save_to_cache()
                
            print(f"[RUNRATE] Loaded {len(self.samples)} historical data points")
            print(f"[RUNRATE] Exam date set to: {self.exam_date.strftime('%Y-%m-%d')}")
            
            self.initialization_complete = True
            
        except Exception as e:
            print(f"[RUNRATE] Initialization error: {e}")
            self.samples = []
            self.initialization_complete = True
        
        # FIXED: Delayed initial draw to ensure widget is ready
        self.after(100, self._safe_initial_draw)
        
    def refresh_for_new_plan(self, plan_name, schedule, exam_date=None):
        """Refresh graph data when plan is switched."""
        try:
            print(f"[RUNRATE] Refreshing graph for plan: {plan_name}")
            
            # Update plan name
            self.current_plan_name = plan_name
            
            # Update exam date if provided
            if exam_date:
                if isinstance(exam_date, str):
                    self.exam_date = datetime.strptime(exam_date, "%Y-%m-%d")
                elif isinstance(exam_date, datetime):
                    self.exam_date = exam_date
            
            # ‚úÖ NO need to change data_file - it stays the same!
            # Just reload data for the new plan from the shared file
            print(f"[RUNRATE] Using shared data file: {self.data_file}")
            
            # Clear and reload from same file but different plan section
            self.samples = []
            self._load_historical_data()
            
            # Recalculate required rate based on new schedule
            if schedule:
                total_minutes = 0
                for sess in schedule:
                    if isinstance(sess, (list, tuple)) and len(sess) >= 3:
                        try:
                            if not sess[1] or not sess[2]:
                                continue
                            start = parse_time(sess[1])
                            end = parse_time(sess[2])
                            if start and end:
                                from datetime import datetime, date, timedelta
                                st_dt = datetime.combine(date.today(), start)
                                en_dt = datetime.combine(date.today(), end)
                                if en_dt <= st_dt:
                                    en_dt += timedelta(days=1)
                                total_minutes += int((en_dt - st_dt).total_seconds() // 60)
                        except Exception as e:
                            print(f"[RUNRATE] Error calculating session time: {e}")
                            continue
                
                self.required_min = total_minutes
                print(f"[RUNRATE] Required minutes for new plan: {total_minutes}")
            
            # Redraw the graph
            try:
                # ‚úÖ Try different method names
                if hasattr(self, 'draw'):
                    self.draw()
                elif hasattr(self, '_safe_initial_draw'):
                    self._safe_initial_draw()
                elif hasattr(self, 'update'):
                    self.update()
                else:
                    print("[RUNRATE] No draw method found - triggering widget update")
                    self.update_idletasks()
            except Exception as e:
                print(f"[RUNRATE] Error drawing graph: {e}")
            
            print(f"[RUNRATE] Graph refreshed with {len(self.samples)} samples")
            
        except Exception as e:
            print(f"[RUNRATE] Error refreshing graph: {e}")
            import traceback
            traceback.print_exc()
        
    def save_snapshot_programmatic(self):
        """Generate graph programmatically and save as snapshot - works from any tab"""
        try:
            from PIL import Image, ImageDraw
            import matplotlib
            matplotlib.use('Agg')
            import matplotlib.pyplot as plt
            import matplotlib.ticker as ticker
            import io
            
            snapshot_path = app_paths.get_data_file("last_runrate.png")
            
            # Get zoom setting
            try:
                zoom_setting = self.zoom_var.get()
            except:
                zoom_setting = "overall"
            
            # Filter samples
            if not self.samples:
                print("[RUNRATE] No samples to save")
                return False
                
            if zoom_setting == "1h":
                one_hour_ago = time.time() - (1 * 60 * 60)
                filtered_samples = [(ts, short, long) for ts, short, long in self.samples 
                                   if ts > one_hour_ago]
            else:
                filtered_samples = list(self.samples)
            
            if len(filtered_samples) <= 1:
                print("[RUNRATE] Not enough samples")
                return False

            # Extract data - keep as MINUTES (don't divide by 60 yet)
            timestamps = [ts for ts, _, _ in filtered_samples]
            short_vals = [short for _, short, _ in filtered_samples]  # minutes
            long_vals = [long for _, _, long in filtered_samples]      # minutes
            
            current_time = time.time()
            time_labels = [(current_time - ts) / 3600 for ts in timestamps]
            
            # Create figure
            fig, ax = plt.subplots(figsize=(6.8, 3.0), dpi=100)
            
            # Plot
            ax.plot(time_labels, short_vals, color='#e53935', linewidth=2, label='Short-term')
            ax.plot(time_labels, long_vals, color='#1e88e5', linewidth=2, label='Long-term')
            
            if self.required_min > 0:
                ax.axhline(y=self.required_min, color='#888888', linestyle='--', 
                          linewidth=2, label=f'Required: {self.required_min:.0f}min')
            
            # FIXED: Set Y-axis to start from lower value
            all_values = short_vals + long_vals
            if self.required_min > 0:
                all_values.append(self.required_min)
            
            y_min = max(0, min(all_values) * 0.9)  # Start from 90% of minimum value
            y_max = max(all_values) * 1.1           # End at 110% of maximum value
            ax.set_ylim(y_min, y_max)
            
            # FIXED: Custom Y-axis formatter - show minutes if < 60, otherwise hours
            def format_y_axis(value, pos):
                if value < 60:
                    return f'{int(value)}m'
                else:
                    hours = value / 60
                    return f'{hours:.1f}h'
            
            ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_y_axis))
            
            ax.set_xlabel('Hours Ago', fontsize=10)
            ax.set_ylabel('Rate Required', fontsize=10)
            ax.set_title('Study Run-Rate Analysis', fontsize=12, pad=10)
            ax.legend(loc='best', fontsize=9, frameon=False)
            ax.grid(True, alpha=0.3, linestyle='--')
            ax.invert_xaxis()
            
            plt.tight_layout()
            
            # Save
            plt.savefig(snapshot_path, format='PNG', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close(fig)
            
            print(f"[RUNRATE] Programmatic snapshot saved with {len(filtered_samples)} points")
            return True

        except Exception as e:
            print(f"[RUNRATE] Snapshot generation failed: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _safe_initial_draw(self):
        """Safely perform initial draw after widget is fully initialized"""
        try:
            if self.winfo_exists() and self.canvas.winfo_exists():
                self._redraw()
                print("[RUNRATE] Initial draw completed successfully")
            else:
                print("[RUNRATE] Widget not ready, retrying initial draw...")
                self.after(100, self._safe_initial_draw)
        except Exception as e:
            print(f"[RUNRATE] Initial draw error: {e}")
            # Try again after a delay
            self.after(500, self._safe_initial_draw)

    def create_zoom_controls(self):
        """Create zoom control radio buttons"""
        try:
            tk.Label(self.control_frame, text="View:", bg="#ffffff", font=("Segoe UI", 9)).pack(side="left", padx=(0, 10))
            
            # 1h zoom
            tk.Radiobutton(self.control_frame, text="Zoom In (1h)", variable=self.zoom_var, 
                          value="1h", command=self._safe_redraw, bg="#ffffff", 
                          font=("Segoe UI", 9)).pack(side="left", padx=(0, 15))
            
            # Overall view
            tk.Radiobutton(self.control_frame, text="Zoom Out (Overall)", variable=self.zoom_var, 
                          value="overall", command=self._safe_redraw, bg="#ffffff",
                          font=("Segoe UI", 9)).pack(side="left", padx=(0, 20))
                          
        except Exception as e:
            print(f"[RUNRATE] Error creating zoom controls: {e}")

    def _safe_redraw(self):
        """Safely redraw with error handling"""
        try:
            if self.initialization_complete and self.winfo_exists() and self.canvas.winfo_exists():
                self._redraw()
            else:
                print("[RUNRATE] Widget not ready for redraw, scheduling retry...")
                self.after(100, self._safe_redraw)
        except Exception as e:
            print(f"[RUNRATE] Safe redraw error: {e}")

    def _load_historical_data(self):
        """Load historical data for current plan from shared JSON cache"""
        try:
            # Ensure data file path exists
            if not hasattr(self, 'data_file') or not self.data_file:
                try:
                    self.data_file = app_paths.runrate_data_file
                except:
                    self.data_file = "runrate_data.json"
            
            # Create directory if it doesn't exist
            data_dir = os.path.dirname(os.path.abspath(self.data_file))
            if data_dir and not os.path.exists(data_dir):
                os.makedirs(data_dir, exist_ok=True)
            
            if not os.path.exists(self.data_file):
                print(f"[RUNRATE] No existing data file found, starting fresh")
                return
                
            with open(self.data_file, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                if not content:
                    print("[RUNRATE] Data file is empty, starting fresh")
                    return
                all_data = json.loads(content)
            
            # ‚úÖ Get data for current plan only
            plan_data = all_data.get('plans', {}).get(self.current_plan_name, {})
            
            if not plan_data:
                print(f"[RUNRATE] No data found for plan '{self.current_plan_name}', starting fresh")
                return
            
            # Load samples for this plan
            cached_samples = plan_data.get('samples', [])
            
            # Validate sample data format
            valid_samples = []
            for sample in cached_samples:
                if (isinstance(sample, (list, tuple)) and len(sample) == 3 and
                    all(isinstance(x, (int, float)) for x in sample)):
                    valid_samples.append(tuple(sample))
            
            # Handle exam date for this plan
            saved_exam_date = plan_data.get('exam_date')
            if saved_exam_date:
                try:
                    saved_date = datetime.fromisoformat(saved_exam_date)
                    date_diff_days = abs((saved_date - self.exam_date).days)
                    if date_diff_days > 3:
                        print(f"[RUNRATE] Exam date changed by {date_diff_days} days, resetting data for this plan")
                        self.samples = []
                        return
                    else:
                        print(f"[RUNRATE] Using saved exam date for plan '{self.current_plan_name}': {saved_date.strftime('%Y-%m-%d')}")
                        self.exam_date = saved_date
                except Exception as e:
                    print(f"[RUNRATE] Invalid exam date format in cache: {e}")
            
            # Keep data management
            current_time = time.time()
            exam_timestamp = self.exam_date.timestamp()
            
            if current_time > exam_timestamp + (30 * 24 * 60 * 60):
                print("[RUNRATE] Exam was over 30 days ago, keeping only recent data")
                week_ago = current_time - (7 * 24 * 60 * 60)
                self.samples = [(ts, short, long) for ts, short, long in valid_samples 
                               if ts > week_ago]
            else:
                self.samples = valid_samples
            
            # Load other settings for this plan
            self.required_min = plan_data.get('required_min', 0)
            
            print(f"[RUNRATE] Successfully loaded {len(self.samples)} samples for plan '{self.current_plan_name}'")
            
        except Exception as e:
            print(f"[RUNRATE] Failed to load cache: {e}")
            self.samples = []

    def _save_to_cache(self):
        """Save current plan's data to shared JSON cache"""
        try:
            if not self.samples and self.required_min == 0:
                return
                
            if not hasattr(self, 'data_file') or not self.data_file:
                try:
                    self.data_file = app_paths.runrate_data_file
                except:
                    self.data_file = "runrate_data.json"
            
            # ‚úÖ Load existing data for all plans
            all_data = {'plans': {}}
            
            if os.path.exists(self.data_file):
                try:
                    with open(self.data_file, 'r', encoding='utf-8') as f:
                        content = f.read().strip()
                        if content:
                            all_data = json.loads(content)
                            if 'plans' not in all_data:
                                all_data['plans'] = {}
                except Exception as e:
                    print(f"[RUNRATE] Error loading existing data: {e}")
            
            # ‚úÖ Update data for current plan only
            all_data['plans'][self.current_plan_name] = {
                'samples': self.samples,
                'required_min': self.required_min,
                'exam_date': self.exam_date.isoformat(),
                'last_updated': time.time(),
                'version': '1.2'
            }
            
            # Create directory if needed
            data_dir = os.path.dirname(os.path.abspath(self.data_file))
            if data_dir and not os.path.exists(data_dir):
                os.makedirs(data_dir, exist_ok=True)
            
            # Save with temp file for safety
            temp_file = self.data_file + ".tmp"
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(all_data, f, indent=2, ensure_ascii=False)
            
            # Create backup
            if os.path.exists(self.data_file):
                backup_file = self.data_file + ".bak"
                try:
                    if os.path.exists(backup_file):
                        os.remove(backup_file)
                    os.rename(self.data_file, backup_file)
                except Exception as backup_error:
                    print(f"[RUNRATE] Backup failed (continuing anyway): {backup_error}")
            
            # Move temp to actual file
            os.rename(temp_file, self.data_file)
            print(f"[RUNRATE] Successfully saved {len(self.samples)} samples for plan '{self.current_plan_name}'")
                
        except Exception as e:
            print(f"[RUNRATE] Failed to save cache: {e}")
            import traceback
            traceback.print_exc()

    def set_exam_date(self, exam_date):
        """Update exam date"""
        old_exam_date = self.exam_date
        
        if isinstance(exam_date, str):
            self.exam_date = datetime.strptime(exam_date, "%Y-%m-%d")
        elif isinstance(exam_date, datetime):
            self.exam_date = exam_date
        
        date_diff_days = abs((old_exam_date - self.exam_date).days)
        if date_diff_days > 1:
            print(f"[RUNRATE] Exam date changed by {date_diff_days} days, resetting all data")
            self.samples = []
        
        self._save_to_cache()
        self._safe_redraw()

    def update_required(self, minutes: int):
        """Update required rate"""
        old_required = self.required_min
        self.required_min = max(0, int(minutes))
        
        rate_diff = abs(old_required - self.required_min)
        if rate_diff > 30:
            print(f"[RUNRATE] Required rate changed by {rate_diff} minutes, resetting data")
            self.samples = []
        
        self._save_to_cache()
        self._safe_redraw()

    def add_sample(self, short_minutes: float, long_minutes: float):
        """Add sample with automatic persistence"""
        try:
            now = time.time()
            self.samples.append((now, float(short_minutes), float(long_minutes)))
            
            if len(self.samples) > self.max_points:
                self.samples = self.samples[-self.max_points:]
            
            self._save_to_cache()
            self._safe_redraw()
            
            print(f"[RUNRATE] Added sample: Short={short_minutes:.1f}min, Long={long_minutes:.1f}min")
        except Exception as e:
            print(f"[RUNRATE] Error adding sample: {e}")

    def force_save(self):
        """Force save current data to cache"""
        print(f"[RUNRATE] Force saving {len(self.samples)} samples...")
        self._save_to_cache()

    def start_auto_update(self, get_data_callback):
        """Start automatic updates using a callback function"""
        def auto_update():
            try:
                if (hasattr(self, 'canvas') and self.canvas.winfo_exists() and 
                    self.initialization_complete):
                    
                    short_min, long_min = get_data_callback()
                    
                    if short_min is not None and long_min is not None:
                        now = time.time()
                        should_add_sample = not self.samples or (now - self.samples[-1][0]) >= 30
                        
                        if should_add_sample:
                            self.samples.append((now, float(short_min), float(long_min)))
                            
                            if len(self.samples) > self.max_points:
                                self.samples = self.samples[-self.max_points:]
                            
                            self._save_to_cache()
                        
                        should_redraw = (now - self.last_update) >= self.update_interval
                        if should_redraw:
                            self._safe_redraw()
                            self.last_update = now
                    
                    self.after(30000, auto_update)
                    
            except Exception as e:
                print(f"[RUNRATE] Auto-update error: {e}")
                if hasattr(self, 'canvas'):
                    self.after(30000, auto_update)
        
        # Start after initialization is complete
        if self.initialization_complete:
            auto_update()
        else:
            self.after(200, lambda: auto_update())

    def clear_cache(self):
        """Clear cached data"""
        self.samples = []
        if hasattr(self, 'data_file') and os.path.exists(self.data_file):
            os.remove(self.data_file)
        print("[RUNRATE] Cache cleared")
        self._safe_redraw()

    def _get_filtered_samples(self):
        """Get samples based on current zoom setting"""
        if not self.samples:
            return []
        
        if self.zoom_var.get() == "1h":
            one_hour_ago = time.time() - (1 * 60 * 60)
            return [(ts, short, long) for ts, short, long in self.samples 
                    if ts > one_hour_ago]
        else:
            return self.samples

    def _format_time_smart(self, seconds_ago):
        """Smart time formatting"""
        if seconds_ago < 3600:
            minutes = seconds_ago // 60
            return f"{int(minutes)}m"
        else:
            hours = seconds_ago // 3600
            if hours >= 24:
                days = hours // 24
                return f"{int(days)}d"
            else:
                return f"{int(hours)}h"

    def _fmt_time_hours_only(self, minutes):
        """Format minutes as decimal hours"""
        hours = minutes / 60.0
        return f"{hours:.1f}h"

    def _get_nice_scale(self, max_val):
        """Get nice round numbers for Y-axis scale - FIXED"""
        buffered_max = max_val * 1.3  # Increased buffer to 30%
        
        if buffered_max <= 60:
            step = 15
        elif buffered_max <= 180:
            step = 30
        elif buffered_max <= 360:
            step = 60
        else:
            step = 120
        
        scale_max = ((int(buffered_max) + step - 1) // step) * step
        
        if scale_max <= max_val:
            scale_max += step
        
        return scale_max, step

    def _draw_grid_and_axes(self, scale_max, step, filtered_samples):
        """Draw the graph grid and axes"""
        c = self.canvas
        
        x_axis = self.margin_left
        y_top = self.margin_top
        y_bottom = self.margin_top + self.graph_height
        
        c.create_line(x_axis, y_top, x_axis, y_bottom, fill="#333333", width=2)
        c.create_line(x_axis, y_bottom, x_axis + self.graph_width, y_bottom, 
                     fill="#333333", width=2)
        
        if self.required_min > 0:
            req_y = y_bottom - (self.required_min / scale_max) * self.graph_height
            c.create_text(x_axis - 5, req_y, text=self._fmt_time_hours_only(self.required_min), 
                         anchor="e", fill="#888888", font=("Segoe UI", 9, "bold"))
            c.create_line(x_axis, req_y, x_axis + self.graph_width, req_y, 
                         fill="#e0e0e0", width=1, dash=(4, 4))
        
        if not filtered_samples or len(filtered_samples) <= 1:
            return
            
        num_time_marks = 6
        current_time = time.time()
        
        for i in range(num_time_marks + 1):
            x = x_axis + (i / num_time_marks) * self.graph_width
            c.create_line(x, y_bottom, x, y_bottom - 5, fill="#333333", width=1)
            
            t0 = filtered_samples[0][0]
            t1 = filtered_samples[-1][0]
            t = t1 - (t1 - t0) * (i / num_time_marks)
            time_ago_seconds = int(current_time - t)
            
            label = self._format_time_smart(time_ago_seconds)
            c.create_text(x, y_bottom + 15, text=label, 
                         anchor="center", fill="#666666", font=("Segoe UI", 8))

    def _draw_legend(self, filtered_samples):
        """Draw the legend below the graph"""
        c = self.canvas
        legend_y = self.margin_top + self.graph_height + 40
        
        zoom_text = "1 hour view" if self.zoom_var.get() == "1h" else "overall view"
        c.create_text(self.w // 2, legend_y, text=f"Progress until exam date ({zoom_text})", 
                     anchor="center", fill="#333", font=("Segoe UI", 9))
        
        legend_y += 20
        legend_height = 55
        
        legend_bg_y = legend_y - 5
        c.create_rectangle(15, legend_bg_y, self.w - 15, legend_y + legend_height, 
                          fill="#f8f9fa", outline="#e0e0e0", width=1)
        
        # Required rate line
        line1_y = legend_y + 3
        c.create_line(25, line1_y, 45, line1_y, 
                     fill="#888888", width=2, dash=(5, 5))
        c.create_text(50, line1_y, text=f"Required Rate: {self._fmt_time_hours_only(self.required_min)}", 
                     anchor="w", fill="#333", font=("Segoe UI", 10))
        
        # Short-term line
        line2_y = legend_y + 21
        short_color = "#e53935"
        c.create_line(25, line2_y, 45, line2_y, fill=short_color, width=2)
        c.create_text(50, line2_y, text="Short-term:", anchor="w", fill="#333", font=("Segoe UI", 10))
        
        if filtered_samples:
            _, s_last, l_last = filtered_samples[-1]
            c.create_text(130, line2_y, text=self._fmt_time_hours_only(s_last), 
                         anchor="w", fill=short_color, font=("Segoe UI", 10))
        
        # Long-term line
        line3_y = legend_y + 39
        long_color = "#1e88e5"
        c.create_line(25, line3_y, 45, line3_y, fill=long_color, width=2)
        c.create_text(50, line3_y, text="Long-term:", anchor="w", fill="#333", font=("Segoe UI", 10))
        
        if filtered_samples:
            c.create_text(130, line3_y, text=self._fmt_time_hours_only(l_last), 
                         anchor="w", fill=long_color, font=("Segoe UI", 10))

    def _redraw(self):
        """Redraw the entire graph - MAIN DRAWING FUNCTION"""
        try:
            # FIXED: Check if widgets still exist before drawing
            if not self.winfo_exists() or not self.canvas.winfo_exists():
                print("[RUNRATE] Widgets destroyed, skipping redraw")
                return
                
            c = self.canvas
            c.delete("all")
            
            # Add title
            c.create_text(self.w // 2, 5, 
                          text="Short/Long Term Graph Analysis",
                          anchor="n", fill="#333333", font=("Segoe UI", 9))
            
            # Get filtered samples
            filtered_samples = self._get_filtered_samples()
            
            if not filtered_samples:
                c.create_text(self.w//2, self.h//2, 
                              text="No data available. Add samples to start tracking.",
                              fill="#9aa3ad", font=("Segoe UI", 10))
                return

            # Calculate scale
            all_values = []
            if self.required_min > 0:
                all_values.append(self.required_min)
            
            for _, short_val, long_val in filtered_samples:
                all_values.extend([short_val, long_val])
            
            if not all_values:
                max_val = 60
            else:
                max_val = max(all_values)
                max_val = max(max_val, 30)
            
            scale_max, step = self._get_nice_scale(max_val)

            # Draw grid and axes
            self._draw_grid_and_axes(scale_max, step, filtered_samples)
            
            # Draw data if we have enough points
            if len(filtered_samples) <= 1:
                self._draw_legend(filtered_samples)
                return
                
            t0 = filtered_samples[0][0]
            t1 = filtered_samples[-1][0]
            time_range = max(1.0, t1 - t0)
            
            x_start = self.margin_left
            y_bottom = self.margin_top + self.graph_height
            
            # Draw required rate line
            if self.required_min > 0:
                req_ratio = min(1.0, self.required_min / scale_max)
                req_y = y_bottom - req_ratio * self.graph_height
                c.create_line(x_start, req_y, x_start + self.graph_width, req_y, 
                             fill="#888888", width=2, dash=(8, 4))
            
            # Prepare data points
            short_points = []
            long_points = []
            
            for t, short_val, long_val in filtered_samples:
                x = x_start + ((t - t0) / time_range) * self.graph_width
                
                # FIXED: Clamp ratios to prevent overflow
                short_ratio = min(1.0, max(0.0, short_val / scale_max))
                long_ratio = min(1.0, max(0.0, long_val / scale_max))
                
                y_short = y_bottom - short_ratio * self.graph_height
                y_long = y_bottom - long_ratio * self.graph_height
                
                short_points.extend([x, y_short])
                long_points.extend([x, y_long])
            
            # Draw lines
            short_color = "#e53935"
            long_color = "#1e88e5"
            
            if len(short_points) >= 4:
                c.create_line(*short_points, fill=short_color, width=3, smooth=True)
            
            if len(long_points) >= 4:
                c.create_line(*long_points, fill=long_color, width=3, smooth=True)
            
            # Add Y-axis label
            c.create_text(25, self.margin_top + self.graph_height // 2, 
                         text="Time (Hours)", angle=90, anchor="center", 
                         fill="#333", font=("Segoe UI", 10))
            
            # Draw legend
            self._draw_legend(filtered_samples)
            
        except Exception as e:
            print(f"[RUNRATE] Redraw error: {e}")
            # Try to recover by showing error message
            try:
                if self.canvas.winfo_exists():
                    self.canvas.delete("all")
                    self.canvas.create_text(self.w//2, self.h//2, 
                                          text=f"Graph error: {str(e)[:50]}...", 
                                          fill="#cc0000", font=("Segoe UI", 10))
            except:
                pass
        
# ---------------- Network Tracker ----------------
class NetworkTracker:
    total_bytes = 0  # class variable to count all requests globally

    @classmethod
    def add_request(cls, request_bytes, response_bytes):
        cls.total_bytes += request_bytes + response_bytes

    @classmethod
    def get_usage(cls):
        kb = cls.total_bytes / 1024
        if kb < 1024:
            return f"{kb:.2f} KB"
        else:
            return f"{kb / 1024:.2f} MB"

# ---------------- Monkey-Patch Requests ----------------
_original_get = requests.get
_original_post = requests.post

def tracked_get(*args, **kwargs):
    response = _original_get(*args, **kwargs)
    request_size = sum(len(str(k)) + len(str(v)) for k,v in response.request.headers.items())
    if response.request.body:
        request_size += len(response.request.body)
    response_size = len(response.content)
    NetworkTracker.add_request(request_size, response_size)
    return response

def tracked_post(*args, **kwargs):
    response = _original_post(*args, **kwargs)
    request_size = sum(len(str(k)) + len(str(v)) for k,v in response.request.headers.items())
    if response.request.body:
        request_size += len(response.request.body)
    response_size = len(response.content)
    NetworkTracker.add_request(request_size, response_size)
    return response

# Apply monkey-patch
requests.get = tracked_get
requests.post = tracked_post

import gspread
from datetime import datetime, timedelta
import json
import time

class WeeklyResetManager:
    """Manages weekly resets on Google Sheets - both leaderboard and top rankers"""
    
    def __init__(self, credentials_file, sheet_id, worksheet_name="Sheet1"):
        self.credentials_file = credentials_file
        self.sheet_id = sheet_id
        self.worksheet_name = worksheet_name
        self.ws = None
        self._connect()
    
    def _connect(self):
        """Connect to Google Sheets"""
        try:
            # Try encrypted credentials first
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Fallback to original file-based method
                import gspread
                from oauth2client.service_account import ServiceAccountCredentials
                
                scope = ["https://www.googleapis.com/auth/spreadsheets", 
                        "https://www.googleapis.com/auth/drive"]
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.credentials_file, scope)
                gc = gspread.authorize(creds)
            
            if self.sheet_id.startswith("http"):
                self.ws = gc.open_by_url(self.sheet_id).worksheet(self.worksheet_name)
            else:
                self.ws = gc.open_by_key(self.sheet_id).worksheet(self.worksheet_name)
                
        except Exception as e:
            print(f"[RESET] Connection failed: {e}")
            self.ws = None
    
    def get_current_week_key(self):
        """Get current week key in format YYYY-Wxx"""
        now = datetime.now()
        year, week, _ = now.isocalendar()
        return f"{year}-W{week:02d}"
    
    def is_reset_time(self):
        """Check if it's Sunday 11:59 PM (reset time)"""
        now = datetime.now()
        return (now.weekday() == 6 and  # Sunday
                now.hour == 23 and 
                now.minute == 59)
    
    def get_last_reset_week(self):
        """Get the week key of the last reset from Google Sheets"""
        if not self.ws:
            return None
            
        try:
            # Check reset tracker in column O
            reset_data = self.ws.get('O1')
            if reset_data and reset_data[0][0]:
                data = json.loads(reset_data[0][0])
                return data.get('last_reset_week')
        except Exception as e:
            print(f"[RESET] Error getting last reset: {e}")
        return None
    
    def perform_weekly_reset(self):
        """Perform the complete weekly reset"""
        if not self.ws:
            print("[RESET] No sheet connection for reset")
            return False
        
        current_week = self.get_current_week_key()
        last_reset = self.get_last_reset_week()
        
        if last_reset == current_week:
            print(f"[RESET] Already reset for week {current_week}")
            return False
        
        try:
            print(f"[RESET] Starting weekly reset for {current_week}")
            
            # Step 1: Save current top 3 before reset
            self._save_current_top3()
            
            # Step 2: Reset all user study hours (column F) to 0
            all_values = self.ws.get_all_values()
            if len(all_values) < 2:
                print("[RESET] No user data to reset")
                return False
            
            updates = []
            for i in range(2, len(all_values) + 1):  # Start from row 2
                if len(all_values[i-1]) > 5 and all_values[i-1][5]:  # Column F has data
                    updates.append({
                        'range': f'F{i}',  # Study Hours This Week column
                        'values': [['0.00']]
                    })
            
            if updates:
                self.ws.batch_update(updates)
                print(f"[RESET] Reset {len(updates)} user study hours")
            
            # Step 3: Update reset tracker
            reset_tracker = {
                'last_reset_week': current_week,
                'last_reset_time': datetime.now().isoformat(),
                'users_reset': len(updates)
            }
            
            self.ws.update('O1', [[json.dumps(reset_tracker)]])
            
            print(f"[RESET] Weekly reset completed for {current_week}")
            return True
            
        except Exception as e:
            print(f"[RESET] Reset failed: {e}")
            return False
    
    def _save_current_top3(self):
        """Save current week's top 3 to Google Sheets"""
        try:
            # Get all current data sorted by study hours
            all_data = self.ws.get_all_records()
            if not all_data:
                return False
            
            # Sort by Study Hours This Week (column F)
            valid_data = []
            for row in all_data:
                try:
                    hours = float(row.get('Study Hours This Week', 0))
                    if hours > 0:
                        valid_data.append({
                            'name': row.get('Name', ''),
                            'hours': hours,
                            'uid': row.get('UID', ''),
                            'avatar_id': row.get('Avatar ID', '1')
                        })
                except:
                    continue
            
            valid_data.sort(key=lambda x: x['hours'], reverse=True)
            top3 = valid_data[:3]
            
            if not top3:
                return False
            
            # Determine which column to store in (rotate L, M, N)
            current_week = self.get_current_week_key()
            week_num = int(current_week.split('-W')[1]) % 3
            if week_num == 0:
                week_num = 3
            
            columns = ['L', 'M', 'N']
            column = columns[week_num - 1]
            
            top3_data = {
                'week': current_week,
                'saved_at': datetime.now().isoformat(),
                'top3': []
            }
            
            for i, user in enumerate(top3):
                top3_data['top3'].append({
                    'rank': i + 1,
                    'name': user['name'],
                    'hours': user['hours'],
                    'uid': user['uid'],
                    'avatar_id': user['avatar_id']
                })
            
            # Save to Google Sheets
            self.ws.update(f'{column}1', [[json.dumps(top3_data)]])
            print(f"[RESET] Saved top 3 for week {current_week} to column {column}")
            return True
            
        except Exception as e:
            print(f"[RESET] Error saving top 3: {e}")
            return False
    
    def get_last_week_top3(self):
        """Get last week's top 3 rankers from Firebase"""
        try:
            # Check if db is initialized
            if not hasattr(self, 'db') or not self.db:
                print("[FIREBASE] Database not initialized")
                return []
            
            if not getattr(self, '_net_ok', False):
                print("[FIREBASE] Cannot fetch last week data - no connection")
                return []
            
            # Get last week data from _global node
            ref = self.db.reference('_global/lastWeekTop3')
            last_week_data = ref.get()
            
            if last_week_data and isinstance(last_week_data, list):
                print(f"[FIREBASE] Retrieved {len(last_week_data)} last week rankers")
                return last_week_data
            else:
                print("[FIREBASE] No last week data available")
                return []
                
        except Exception as e:
            print(f"[FIREBASE] Error fetching last week data: {e}")
            import traceback
            traceback.print_exc()
            return []
        
class SheetSync:
    HEADER = ["Name","Rank","Time","Status","Today Hours","Study Hours This Week","Today Target","Source","UID","Last Update","Avatar ID"]
    def __init__(self, profile_loader, profile_saver):
        self._updating = False
        self._load_prof = profile_loader
        self._save_prof = profile_saver
        self.ws = None
        self.uid = None
        self.row_index = None  # 1-based in Google Sheets
        self.enabled = False
        self._connect_and_prepare()
        self._last_reset_check = None
        if LB_CREDENTIALS and LB_SHEET_ID:
            self.reset_manager = WeeklyResetManager(
                LB_CREDENTIALS, LB_SHEET_ID, LB_WORKSHEET
            )
        else:
            self.reset_manager = None
            
    def test_connection(self):
        """Test method to verify encrypted connection works"""
        try:
            # Try encrypted connection
            gc = get_encrypted_gspread_client()
            if gc:
                print("‚úÖ Encrypted connection test successful")
                return True
            else:
                print("‚ö† Encrypted connection not available, using fallback")
                return False
        except Exception as e:
            print(f"‚ùå Connection test failed: {e}")
            return False
            
    def _check_and_perform_reset(self):
        """Check if reset is needed and perform it"""
        if not self.reset_manager:
            return
            
        try:
            now = datetime.now()
            # Only check once per minute
            if (not self._last_reset_check or 
                (now - self._last_reset_check).total_seconds() > 60):
                
                self._last_reset_check = now
                
                if self.reset_manager.is_reset_time():
                    current_week = self.reset_manager.get_current_week_key()
                    last_reset = self.reset_manager.get_last_reset_week()
                    
                    if last_reset != current_week:
                        print(f"[RESET] Triggering weekly reset at {now}")
                        self.reset_manager.perform_weekly_reset()
                        
        except Exception as e:
            print(f"[RESET] Check failed: {e}")        
        
    def _ensure_row(self):
        """Make sure self.row_index points to the row with our UID; create if missing."""
        if not getattr(self, "ws", None):
            return False
        try:
            # If we already have a row_index, verify it matches our UID
            if getattr(self, "row_index", None):
                try:
                    cell = self.ws.get(f"I{self.row_index}")
                    uid_in = (cell or [[""]])[0][0]
                    if str(uid_in).strip() == str(self.uid).strip():
                        return True
                except Exception:
                    pass  # fall through to re-scan

            # Re-scan column I for our UID
            col = self.ws.col_values(9) or []  # I = 9
            for i, val in enumerate(col, start=1):
                if i == 1:  # header
                    continue
                if str(val).strip() == str(self.uid).strip():
                    self.row_index = i
                    return True

            # Not found ‚Üí append a new row and seed UID
            rix = max(2, len(col) + 1)
            self.ws.update(f"I{rix}:I{rix}", [[self.uid]])
            self.row_index = rix
            return True
        except Exception as e:
            print("[GSYNC] _ensure_row failed:", e)
            return False

    def _connect_and_prepare(self):
        """Fixed version of _connect_and_prepare that handles None credentials"""
        print("[DEBUG] === FIXED CONNECT AND PREPARE START ===")
        
        # Get environment variables
        
        LB_SHEET_ID = get_secret("LB_SHEET_ID")
        LB_WORKSHEET = "Sheet1"
        
        print(f"[DEBUG] LB_CREDENTIALS: {LB_CREDENTIALS}")
        print(f"[DEBUG] LB_SHEET_ID: {LB_SHEET_ID}")
        
        # FIXED CONDITION: Only check if LB_SHEET_ID exists, since we don't need credentials file anymore
        if not LB_SHEET_ID:
            print(f"[GSYNC] Skipping: LB_SHEET_ID not set.")
            return
        
        try:
            import gspread
            
            # Try encrypted credentials first
            print("[DEBUG] Attempting encrypted connection...")
            gc = get_encrypted_gspread_client()
            
            if not gc:
                print("[DEBUG] Encrypted connection failed, trying file fallback...")
                # Only try file fallback if credentials file exists
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                        print("[DEBUG] File-based connection successful")
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                        print("[DEBUG] OAuth2 connection successful")
                else:
                    print("[DEBUG] ‚ùå No credentials available - encrypted failed and no file fallback")
                    self.ws = None
                    self.enabled = False
                    return

            print("[DEBUG] Opening spreadsheet...")
            self.ws = gc.open_by_url(LB_SHEET_ID) if LB_SHEET_ID.startswith("http") else gc.open_by_key(LB_SHEET_ID)
            self.ws = self.ws.worksheet(LB_WORKSHEET)
            print(f"[DEBUG] ‚úÖ Connected to worksheet: {self.ws.title}")
            
        except Exception as e:
            print(f"[GSYNC] connect failed: {e}")
            import traceback
            traceback.print_exc()
            self.ws = None
            self.enabled = False
            return

        # Rest of your existing code for headers, UID, etc...
        try:
            values = self.ws.get("A1:K1") or []
            header_present = values and [h.strip() for h in values[0]] == self.HEADER
            if not header_present:
                self.ws.update("A1:K1", [self.HEADER])
        except Exception as e:
            print("[GSYNC] header check failed:", e)

        # Ensure we have UID in profile.json
        prof = self._load_prof()
        self.uid = prof.get("uid")
        if not self.uid:
            import uuid
            self.uid = uuid.uuid4().hex
            prof["uid"] = self.uid
            self._save_prof(prof)

        # Find or create our row by UID (column I)
        try:
            vals = self.ws.get("I2:I")
            found_row = None
            if vals:
                for i, v in enumerate(vals, start=2):
                    if (v and len(v) > 0 and v[0].strip() == self.uid):
                        found_row = i
                        break
            if found_row is None:
                # Append new row
                prof = self._load_prof()
                name = prof.get("user_name","").strip() or "User"
                import time
                row = [name,"","", "Offline","0.00","0.00","","APP", self.uid, time.strftime("%Y-%m-%d %H:%M:%S"), str(prof.get("avatar_id", 1))]
                self.ws.append_row(row, value_input_option="USER_ENTERED")
                # Determine row index = last non-empty row
                data = self.ws.get_all_values()
                found_row = len(data)
            self.row_index = found_row
            self.enabled = True
            print(f"[GSYNC] ‚úÖ Ready. Row={self.row_index}, UID={self.uid}")
        except Exception as e:
            print("[GSYNC] prepare failed:", e)
            self.enabled = False

    def update(self, name=None, today_hours=None, week_hours=None, online=True, today_target=None, **kwargs):
        """
        Robust update: only writes "Today Hours" (E) or "Study Hours This Week" (F)
        if the caller passed a non-None value. Accept **kwargs for back-compat.
        """
        import traceback, time as _time, random

        if getattr(self, '_updating', False):
            print("[TRACE] Update already in progress, skipping.")
            return

        self._updating = True
        try:
            if not (getattr(self, "enabled", False) and getattr(self, "ws", None)):
                print("[TRACE] Not enabled or no worksheet, skipping update")
                return
            if not self._ensure_row():
                print("[TRACE] Could not ensure row, skipping update")
                return

            r = self.row_index
            vals = []

            # A: Name (only if provided)
            if name is not None:
                vals.append({"range": f"A{r}:A{r}", "values": [[name]]})

            # D: Status is safe to always write (caller intentionally sets online)
            status = "Online" if online else "Offline"
            vals.append({"range": f"D{r}:D{r}", "values": [[status]]})

            # E (Today Hours) - write ONLY if caller provided a value
            if today_hours is not None:
                today_str = f"{float(today_hours):.2f}"
                vals.append({"range": f"E{r}:E{r}", "values": [[today_str]]})

            # F (Study Hours This Week) - write ONLY if caller provided a value
            if week_hours is not None:
                week_str = f"{float(week_hours):.2f}"
                vals.append({"range": f"F{r}:F{r}", "values": [[week_str]]})

            # G: Today target (optional)
            if today_target is not None:
                vals.append({"range": f"G{r}:G{r}", "values": [[f"{float(today_target):.2f}"]]})

            # H/I/J/K meta (we keep H as a unique source-ID for traceability)
            unique_id = f"APP-{random.randint(10000,99999)}-{_time.strftime('%H%M%S')}"
            vals.append({"range": f"H{r}:H{r}", "values": [[unique_id]]})
            vals.append({"range": f"I{r}:I{r}", "values": [[self.uid]]})
            vals.append({"range": f"J{r}:J{r}", "values": [[_time.strftime('%Y-%m-%d %H:%M:%S')]]})

            # K: Avatar ID (if present)
            try:
                avatar_id = str((_load_profile().get("avatar_id") or ""))
                if avatar_id:
                    vals.append({"range": f"K{r}:K{r}", "values": [[avatar_id]]})
            except Exception:
                pass

            if not vals:
                print("[GSYNC] Nothing to write (no fields specified).")
                return

            print(f"[TRACE] About to write to Google Sheets (row {r}) with unique id {unique_id} ‚Äî fields: {len(vals)}")
            self.ws.batch_update(vals)
            print(f"[TRACE] Successfully wrote to row {r} with ID {unique_id}")

        except Exception as e:
            print("[GSYNC] update failed:", e)
            import traceback; traceback.print_exc()
        finally:
            self._updating = False
            
import firebase_admin
from firebase_admin import credentials, db
from datetime import datetime
import os

class FirebaseSync:
    def __init__(self, profile_loader, profile_saver, database_url=None, service_account_path=None):
        self._updating = False
        self._load_prof = profile_loader
        self._save_prof = profile_saver
        self.uid = None
        self.enabled = False
        self.database_url = database_url or "https://leaderboard-98e8c-default-rtdb.asia-southeast1.firebasedatabase.app"
        self.service_account_path = service_account_path or "E:/my-project/serviceAccountKey.json"
        self._connect_and_prepare()
        
    def get_last_week_top3(self):
        """Get last week's top 3 rankers from Firebase"""
        try:
            if not self._net_ok:
                print("[FIREBASE] Cannot fetch last week data - no connection")
                return []
            
            # Get last week data from _global node
            ref = self.db.reference('_global/lastWeekTop3')
            last_week_data = ref.get()
            
            if last_week_data and isinstance(last_week_data, list):
                print(f"[FIREBASE] Retrieved {len(last_week_data)} last week rankers")
                return last_week_data
            else:
                print("[FIREBASE] No last week data available")
                return []
                
        except Exception as e:
            print(f"[FIREBASE] Error fetching last week data: {e}")
            import traceback
            traceback.print_exc()
            return []
        
    def _connect_and_prepare(self):
        """Initialize Firebase connection and prepare user"""
        print("[FIREBASE-SYNC] === CONNECT AND PREPARE START ===")
        
        try:
            # Initialize Firebase Admin SDK if not already initialized
            if not firebase_admin._apps:
                # Use dictionary instead of file path
                if isinstance(self.service_account_path, dict):
                    cred = credentials.Certificate(self.service_account_path)
                else:
                    cred = credentials.Certificate(self.service_account_path)
                firebase_admin.initialize_app(cred, {
                    'databaseURL': self.database_url
                })
                print("[FIREBASE-SYNC] ‚úÖ Firebase initialized")
            else:
                print("[FIREBASE-SYNC] Firebase already initialized")
            # ‚úÖ ADD THIS LINE - Expose db reference
            self.db = db  # Make db accessible to other methods
            self._net_ok = True  # ‚úÖ ADD THIS TOO - Initialize connection status   
            
        except Exception as e:
            print(f"[FIREBASE-SYNC] Firebase init failed: {e}")
            self.enabled = False
            self._net_ok = False  # ‚úÖ ADD THIS
            return
        
        # Ensure we have UID in profile.json
        prof = self._load_prof()
        self.uid = prof.get("uid")
        
        if not self.uid:
            import uuid
            self.uid = uuid.uuid4().hex
            prof["uid"] = self.uid
            self._save_prof(prof)
            print(f"[FIREBASE-SYNC] Generated new UID: {self.uid}")
        
        # Check if user exists in Firebase, create if not
        try:
            ref = db.reference(f'leaderboard/{self.uid}')
            existing = ref.get()
            
            if not existing:
                # Create new user entry
                user_name = prof.get("user_name", "").strip() or "User"
                avatar_id = str(prof.get("avatar_id", "1"))
                
                initial_data = {
                    'name': user_name,
                    'uid': self.uid,
                    'weekHours': 0.0,
                    'todayHours': 0.0,
                    'score': 0,
                    'status': 'Offline',
                    'online': False,
                    'avatarId': avatar_id,
                    'active': True,
                    'history': {},
                    'perfType': 'medium',
                    'dailyTarget': 7.0,
                    'todayTarget': 0.0,
                    'lastUpdate': datetime.now().isoformat()
                }
                
                ref.set(initial_data)
                print(f"[FIREBASE-SYNC] Created new user entry for UID: {self.uid}")
            else:
                print(f"[FIREBASE-SYNC] User already exists: {self.uid}")
            
            self.enabled = True
            print(f"[FIREBASE-SYNC] ‚úÖ Ready. UID={self.uid}")
            
        except Exception as e:
            print(f"[FIREBASE-SYNC] User preparation failed: {e}")
            import traceback
            traceback.print_exc()
            self.enabled = False
    
    def update(self, name=None, today_hours=None, week_hours=None, online=True, today_target=None, **kwargs):
        """
        Update user's study data in Firebase.
        Only writes fields that are provided (non-None).
        
        CRITICAL: Respects weekly resets from Firebase function.
        """
        if getattr(self, '_updating', False):
            print("[FIREBASE-SYNC] Update already in progress, skipping.")
            return
        
        self._updating = True
        try:
            if not self.enabled or not self.uid:
                print("[FIREBASE-SYNC] Not enabled or no UID, skipping update")
                return
            
            ref = db.reference(f'leaderboard/{self.uid}')
            
            # ‚úÖ STEP 1: Check current Firebase state for reset detection
            current = ref.get() or {}
            weekly_reset_at = current.get('weeklyResetAt')
            firebase_week_hours = current.get('weekHours', -1)
            firebase_today_hours = current.get('todayHours', -1)
            
            print(f"[FIREBASE-CHECK] Current state: weekHours={firebase_week_hours}, todayHours={firebase_today_hours}, reset_flag={weekly_reset_at}")
            print(f"[FIREBASE-CHECK] App wants to write: weekHours={week_hours}, todayHours={today_hours}")
            
            
            
            # ‚úÖ STEP 3: Get history from Firebase (preserve any data we don't control)
            history = current.get('history', {})
            
            # Prepare updates
            updates = {}
            
            # ‚≠ê CRITICAL: Always mark app users as REAL users
            updates['userType'] = 'real'
            
            # Update name if provided
            if name is not None:
                updates['name'] = name
            
            # Update status
            updates['status'] = 'Online' if online else 'Offline'
            updates['online'] = online
            
            # ‚úÖ STEP 4: Update study hours (safe after reset check)
            if today_hours is not None:
                updates['todayHours'] = float(today_hours)
                # Update history with today's seconds
                today_key = datetime.now().strftime('%Y-%m-%d')
                history[today_key] = int(float(today_hours) * 3600)
                print(f"[FIREBASE-SYNC] Updating todayHours: {today_hours}h")
            
            if week_hours is not None:
                updates['weekHours'] = float(week_hours)
                updates['score'] = int(float(week_hours) * 100)
                print(f"[FIREBASE-SYNC] Updating weekHours: {week_hours}h")
            
            # Update today target if provided
            if today_target is not None:
                updates['todayTarget'] = float(today_target)
            
            # Always update history and timestamp
            if history:
                updates['history'] = history
            updates['lastUpdate'] = datetime.now().isoformat()
            
            # Add avatar ID from profile
            try:
                prof = self._load_prof()
                avatar_id = str(prof.get("avatar_id", "1"))
                if avatar_id:
                    updates['avatarId'] = avatar_id
            except Exception:
                pass
            
            # Add metadata
            updates['source'] = 'mobile_app'
            updates['appVersion'] = kwargs.get('app_version', '1.0.0')
            
            # ‚≠ê Remove fake user properties if they exist
            fake_props = ['perfType', 'studyPace', 'onlinePreference', 'isFakeInactive', 'dailyTarget']
            for prop in fake_props:
                if current.get(prop) is not None:
                    updates[prop] = None
            
            if not updates:
                print("[FIREBASE-SYNC] Nothing to write (no fields specified).")
                return
            
            # ‚úÖ STEP 5: Write to Firebase
            ref.update(updates)
            
            # Show summary
            key_fields = ['todayHours', 'weekHours', 'score', 'online']
            summary = {k: updates.get(k) for k in key_fields if k in updates}
            print(f"[FIREBASE-SYNC] ‚úÖ Updated UID {self.uid}: {summary}")
            
        except Exception as e:
            print(f"[FIREBASE-SYNC] ‚ùå update failed: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self._updating = False
    
    def pull(self):
        """Read data from Firebase (optional, for compatibility)"""
        if not self.enabled or not self.uid:
            return None
        
        try:
            ref = db.reference(f'leaderboard/{self.uid}')
            return ref.get()
        except Exception as e:
            print(f"[FIREBASE-SYNC] pull failed: {e}")
            return None
    
    def refresh(self):
        """Refresh data (optional, for compatibility)"""
        return self.pull()

# === Exam date + profile helpers (do not touch existing config.json) ===
def _load_exam_date_only():
    """Return the exam date for the *current exam* or None. Never prompts."""
    try:
        from datetime import datetime

        # Prefer exam-specific mapping (new format) and fall back to the legacy
        # single-date structure if present.
        mapping = _load_exam_date_mapping()

        try:
            exam_key = _get_exam_key_for_plans()
        except Exception:
            exam_key = "__GLOBAL__"

        date_str = mapping.get(exam_key) or mapping.get("__GLOBAL__")
        if date_str:
            return datetime.strptime(date_str, "%Y-%m-%d").date()

        # Legacy: {"exam_date": "YYYY-MM-DD"}
        date_str = mapping.get("exam_date") if isinstance(mapping, dict) else None
        if date_str:
            return datetime.strptime(date_str, "%Y-%m-%d").date()

        return None
    except Exception:
        return None
        
# ======== GOAL / MARKERS HELPERS ========
from datetime import date

def _get_daily_hours_fallback():
    """Daily hours from profile.json (fallback if schedule logic isn‚Äôt available)."""
    try:
        prof = _load_profile()
        return float(prof.get("daily_study_hours", 0.0))
    except Exception:
        return 0.0

def calculate_goal_duration_hours():
    """
    Total goal hours = days_left_until_exam √ó daily_hours.
    Uses exam_date.json and daily_study_hours (from profile).
    """
    exam = _load_exam_date_only()
    if not exam:
        return 0.0
    today = date.today()
    days_left = (exam - today).days
    if days_left < 0:
        days_left = 0
    daily = _get_daily_hours_fallback()
    if daily <= 0:
        return 0.0
    return days_left * daily

def compute_red_marker_hours_list():
    """
    Turn 'red marker every N days' into cumulative hours list for the progress bar.
    Example: daily=4h, every 6 days => markers at [24, 48, 72, ...].
    """
    daily = _get_daily_hours_fallback()
    try:
        prof = _load_profile()
        gap_days = int(prof.get("red_marker_days", 0))
    except Exception:
        gap_days = 0
    if daily <= 0 or gap_days <= 0:
        return []
    total = calculate_goal_duration_hours()
    step = daily * gap_days
    marks, h = [], step
    while h < total - 1e-9:
        marks.append(h)
        h += step
    return marks
# ======== END BLOCK ========

_PROFILE_FILE = app_paths.profile_file

def _week_key(dt=None):
    from datetime import datetime
    dt = dt or datetime.now()
    y, w, d = dt.isocalendar()
    return f"{y}-W{w:02d}"



def _save_profile(d):
    """Save profile locally only"""
    import json, uuid
    
    if not d.get("uid"):
        d["uid"] = str(uuid.uuid4())

    try:
        with open(app_paths.profile_file, "w", encoding="utf-8") as f:
            json.dump(d, f, indent=2)
        print("Profile saved locally")
    except Exception as e:
        print(f"Failed to save profile.json locally: {e}")

# === Onboarding wizard (Name + Exam Date + Avatar) ===

def app_load_profile_for_sync():
    try:
        with open(app_paths.profile_file,"r",encoding="utf-8") as f:
            import json; d = json.load(f)
            return d if isinstance(d, dict) else {}
    except Exception:
        return {}

def app_save_profile_for_sync(d):
    try:
        import json
        with open(app_paths.profile_file,"w",encoding="utf-8") as f:
            json.dump(d, f, indent=2)
    except Exception as e:
        print("profile.json save error:", e)



def _save_week_state(d):
    """Persist only the week-state; never touch profile.json here."""
    try:
        import json
        with open(WEEK_STATE_FILE, 'w', encoding='utf-8') as f:
            json.dump(d, f)
    except Exception:
        pass
def _save_week_state(d):
    try:
        import json
        with open(WEEK_STATE_FILE,'w',encoding='utf-8') as f:
            json.dump(d,f)
    except Exception:
        pass

    try:
        import json
        with open(app_paths.profile_file,"w",encoding="utf-8") as f:
            json.dump(d, f, indent=2)
    except Exception as e:
        print("profile.json save error:", e)
        
class AutoDropdown(tk.Frame):
    def __init__(self, parent, values, textvariable=None, width=20, font=("Segoe UI", 11)):
        super().__init__(parent, bg="white")

        self.values = values
        self.var = textvariable or tk.StringVar()
        self.font = font

        # Container frame to simulate a single box
        box = tk.Frame(self, bg="white", bd=1, relief="solid", highlightthickness=1,
                       highlightbackground="#ddd", highlightcolor="#4285f4")
        box.pack(fill="x", ipady=1)

        # Entry field
        self.entry = tk.Entry(
            box,
            textvariable=self.var,
            font=self.font,
            relief="flat",
            highlightthickness=0,
            bd=0
        )
        self.entry.pack(side="left", fill="x", expand=True, ipady=4, padx=(5, 0))

        # ‚úÖ Arrow button inside the same field (right side)
        self.arrow = tk.Label(
            box, text="‚ñº",
            bg="white",
            fg="#4285f4",
            font=("Segoe UI", 10),
            cursor="hand2",
            padx=6,
            pady=2
        )
        self.arrow.pack(side="right")

        # ‚úÖ Popup window
        self.popup = tk.Toplevel(self)
        self.popup.withdraw()
        self.popup.overrideredirect(True)
        self.popup.attributes("-topmost", True)

        self.listbox = tk.Listbox(
            self.popup,
            font=self.font,
            bg="white", fg="#333",
            selectbackground="#e8f0fe", selectforeground="#1a73e8",
            activestyle="dotbox"
        )
        self.listbox.pack(fill="both", expand=True)

        self.filtered = list(self.values)
        self._fill()

        # Bindings
        self.entry.bind("<KeyRelease>", self._on_key)
        self.entry.bind("<Down>", self._on_down)
        self.entry.bind("<Up>", self._on_up)
        self.entry.bind("<Return>", self._select)
        self.entry.bind("<Escape>", lambda e: self._hide())
        self.entry.bind("<FocusOut>", self._focus_out)
        self.arrow.bind("<Button-1>", lambda e: self.toggle())
        self.listbox.bind("<Button-1>", self._mouse_select)

    # Popup
    def _show(self):
        x = self.entry.winfo_rootx()
        y = self.entry.winfo_rooty() + self.entry.winfo_height() + 3
        w = self.entry.winfo_width() + self.arrow.winfo_width() + 6
        h = min(220, 24 * len(self.filtered))
        self.popup.geometry(f"{w}x{h}+{x}+{y}")
        self.popup.deiconify()
        self.entry.focus_set()

    def _hide(self):
        self.popup.withdraw()

    def toggle(self):
        if self.popup.winfo_viewable():
            self._hide()
        else:
            self.filtered = list(self.values)
            self._fill()
            self._show()

    # List mgmt
    def _fill(self):
        self.listbox.delete(0, "end")
        for v in self.filtered:
            self.listbox.insert("end", v)
        if self.filtered:
            self.listbox.selection_clear(0, "end")
            self.listbox.selection_set(0)

    def _on_key(self, event):
        if event.keysym in ("Up", "Down", "Return", "Escape", "Tab"):
            return
        txt = self.var.get().lower()
        self.filtered = [v for v in self.values if v.lower().startswith(txt)] or list(self.values)
        self._fill()
        self._show()

    def _mouse_select(self, event):
        idx = self.listbox.nearest(event.y)
        if 0 <= idx < len(self.filtered):
            self.var.set(self.filtered[idx])
        self._hide()
        self.entry.icursor("end")

    def _select(self, event):
        sel = self.listbox.curselection()
        if sel:
            self.var.set(self.filtered[sel[0]])
        self._hide()
        self.entry.icursor("end")
        return "break"

    def _on_down(self, event):
        self._show()
        sel = self.listbox.curselection()
        i = sel[0] + 1 if sel else 0
        i = min(i, len(self.filtered) - 1)
        self.listbox.selection_clear(0, "end")
        self.listbox.selection_set(i)
        self.listbox.activate(i)
        return "break"

    def _on_up(self, event):
        self._show()
        sel = self.listbox.curselection()
        i = sel[0] - 1 if sel else 0
        i = max(i, 0)
        self.listbox.selection_clear(0, "end")
        self.listbox.selection_set(i)
        self.listbox.activate(i)
        return "break"

    def _focus_out(self, event):
        self.after(100, lambda: self._hide()
                   if self.entry.focus_get() != self.listbox else None)



class OnboardingWizard(tk.Toplevel):
    def __init__(self, app):
        super().__init__(app)
        self.app = app
        self.title("Welcome to StudyTimer")
        self.configure(bg="#f5f7fa")
        self.geometry("460x580")
        self.transient(app)
        self.grab_set()
        
        self.resizable(False, False)
        
        # Center window
        self.update_idletasks()
        try:
            pw, ph = app.winfo_width(), app.winfo_height()
            px, py = app.winfo_rootx(), app.winfo_rooty()
            if pw > 1 and ph > 1:
                x = px + (pw - 460)//2
                y = py + (ph - 580)//2
            else:
                sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
                x = (sw - 420)//2; y = (sh - 580)//2
        except Exception:
            sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
            x = (sw - 420)//2; y = (sh - 580)//2
        self.geometry(f"460x580+{x}+{y}")
        
        # Remove always on top - only set it briefly then remove
        self.attributes('-topmost', True)
        self.after(100, lambda: self.attributes('-topmost', False))
        
        self.protocol('WM_DELETE_WINDOW', self.destroy)
        
        try:
            from PIL import Image, ImageTk, ImageDraw
            self._pil = (Image, ImageTk, ImageDraw)
        except Exception:
            self._pil = None
        
        # Auth state
        self.user_authenticated = False
        self.auth_user_data = None
        self.otp_attempts = 0
        self.last_otp_time = 0
        
        self._build()

    def _build(self):
        import glob, os
        from datetime import timedelta

        # Main container
        main_frame = tk.Frame(self, bg="#f5f7fa")
        main_frame.pack(fill="both", expand=True)

        # Header section
        header_frame = tk.Frame(main_frame, bg="#4285f4", height=80)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)

        tk.Label(header_frame, text="Welcome to StudyTimer", bg="#4285f4", fg="white",
                 font=("Segoe UI", 16, "bold")).pack(pady=(25, 0))
        tk.Label(header_frame, text="Let's personalize your experience", bg="#4285f4", fg="#e8f0fe",
                 font=("Segoe UI", 10)).pack()

        # Content container
        container = tk.Frame(main_frame, bg="white")
        container.pack(fill="both", expand=True, padx=20, pady=5)

        # ==========================
        # Top row: Name + Language
        top_row = tk.Frame(container, bg="white")
        top_row.pack(fill="x", pady=(0, 10))

        # Name field
        name_frame = tk.Frame(top_row, bg="white")
        name_frame.pack(side="left", fill="x", expand=True, padx=(0, 5))

        tk.Label(name_frame, text="Your Name", bg="white", fg="#333",
                 font=("Segoe UI", 10, "bold")).pack(anchor="w")

        prof = _load_profile()
        default_name = prof.get("user_name", "") or getattr(self.app, "user_name", "") or ""
        self.name_var = tk.StringVar(value=default_name)

        name_entry = tk.Entry(name_frame, textvariable=self.name_var, font=("Segoe UI", 11),
                              relief="solid", bd=1, highlightthickness=0)
        name_entry.pack(fill="x", pady=(5, 0), ipady=5)
        name_entry.configure(highlightbackground="#ddd", highlightcolor="#4285f4")

        # Language field
        lang_frame = tk.Frame(top_row, bg="white")
        lang_frame.pack(side="left", fill="x", expand=True, padx=(5, 0))

        tk.Label(
            lang_frame, text="Language", bg="white", fg="#333",
            font=("Segoe UI", 10, "bold")
        ).pack(anchor="w")

        languages = [
            "English", "Assamese", "Bengali", "Bodo", "Dogri", "Gujarati", "Hindi",
            "Kannada", "Kashmiri", "Konkani", "Maithili", "Malayalam",
            "Manipuri (Meitei)", "Marathi", "Nepali", "Odia", "Punjabi",
            "Sanskrit", "Santali", "Sindhi", "Tamil", "Telugu", "Urdu"
        ]

        default_lang = prof.get("language", "English") or "English"
        self.language_var = tk.StringVar(value=default_lang)

        # ‚úÖ Replace Combobox with custom dropdown
        lang_dropdown = AutoDropdown(lang_frame, languages, textvariable=self.language_var, width=18, font=("Segoe UI", 11))
        lang_dropdown.pack(fill="x", pady=(5, 0))

        # ==========================
        # Calculate default exam date BEFORE creating widgets (per exam)
        default_exam = None
        try:
            # exam name from profile (current exam when opening wizard)
            current_profile_exam = (prof.get("exam_name") or "").strip()
            # Helper is defined at top of this same file, just call it directly
            default_exam = get_exam_date_for_exam(current_profile_exam)
        except Exception as e:
            print(f"[EXAM] Failed to load per-exam date in wizard: {e}")
            default_exam = None


        if not default_exam and hasattr(self.app, 'progress_exam_date') and self.app.progress_exam_date:
            default_exam = self.app.progress_exam_date

        if not default_exam:
            default_exam = date.today() + timedelta(days=30)

        # ==========================
        # Row 2: Exam Name + Target Exam Date
        row2 = tk.Frame(container, bg="white")
        row2.pack(fill="x", pady=(0, 10))

        # Left: Exam Name
        exam_name_frame = tk.Frame(row2, bg="white")
        exam_name_frame.pack(side="left", fill="x", expand=True, padx=(0, 5))

        tk.Label(exam_name_frame, text="Exam Name", bg="white", fg="#333",
                 font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 2))

        self.exam_name_var = tk.StringVar(value=(prof.get("exam_name") or ""))
        exam_name_entry = tk.Entry(
            exam_name_frame, textvariable=self.exam_name_var,
            font=("Segoe UI", 11), relief="solid", bd=1, highlightthickness=0
        )
        exam_name_entry.pack(fill="x", pady=(0, 0), ipady=5)
        exam_name_entry.configure(highlightbackground="#ddd", highlightcolor="#4285f4")
        
        # Remember original exam name to detect change
        self._original_exam_name = (prof.get("exam_name") or "").strip()
        self._exam_date_cleared_for_new_exam = False

        # When exam name changes, clear the exam date field once
        def _on_exam_name_changed(*_args):
            current = (self.exam_name_var.get() or "").strip()
            if current and current != self._original_exam_name and not self._exam_date_cleared_for_new_exam:
                self._exam_date_cleared_for_new_exam = True
                # Clear exam date so user must enter a new one for this exam
                try:
                    self.exam_var.set("")
                except Exception:
                    pass

        self.exam_name_var.trace_add("write", _on_exam_name_changed)
        
        # Add matching spacer label to align with date field
        tk.Label(exam_name_frame, text=" ", bg="white", fg="#999",
                 font=("Segoe UI", 8)).pack(anchor="w", pady=(2, 0))

        # Right: Target Exam Date
        date_frame = tk.Frame(row2, bg="white")
        date_frame.pack(side="left", fill="x", expand=True, padx=(5, 0))

        tk.Label(date_frame, text="Target Exam Date", bg="white", fg="#333",
                 font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 2))

        self.exam_var = tk.StringVar(value=str(default_exam))
        exam_entry = tk.Entry(
            date_frame, textvariable=self.exam_var,
            font=("Segoe UI", 11), relief="solid", bd=1, highlightthickness=0
        )
        exam_entry.pack(fill="x", pady=(0, 0), ipady=5)
        exam_entry.configure(highlightbackground="#ddd", highlightcolor="#4285f4")

        tk.Label(date_frame, text="Format: YYYY-MM-DD", bg="white", fg="#999",
                 font=("Segoe UI", 8)).pack(anchor="w", pady=(2, 0))


        # Avatar selection with title
        avatar_frame = tk.Frame(container, bg="white")
        avatar_frame.pack(fill="x", pady=(0, 10))
        
        tk.Label(avatar_frame, text="Choose Your Avatar", bg="white", fg="#333",
                 font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 5))
        
        wrap = tk.Frame(avatar_frame, bg="white")
        wrap.pack()

        # Avatar loading logic (keeping original)
        avatars_dir = getattr(self.app, 'avatars_dir', None)
        if avatars_dir is None:
            try:
                import app_paths
                avatars_dir = app_paths.avatars_dir
            except:
                avatars_dir = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'avatars')
        
        os.makedirs(avatars_dir, exist_ok=True)
        
        cand = []
        for ext in (".png", ".jpg", ".jpeg", ".webp", "*.gif"):
            pattern = os.path.join(avatars_dir, ext)
            matches = glob.glob(pattern)
            cand.extend(matches)
        
        if not cand:
            try:
                all_files = os.listdir(avatars_dir)
                for file in all_files:
                    if file.lower().endswith(('.png', '.jpg', '.jpeg', '.webp', '.gif')):
                        cand.append(os.path.join(avatars_dir, file))
            except Exception:
                pass
        
        cand = sorted(cand)[:5]
        self.cand = []
        for i in range(5):
            self.cand.append(cand[i] if i < len(cand) else f"placeholder{i+1}")

        # Only set selected_idx if there's a saved avatar, otherwise None
        self.selected_idx = None
        prof = _load_profile()
        
        saved_avatar = prof.get("avatar_path", "")
        if saved_avatar:
            # Try to find the saved avatar in current candidates
            if saved_avatar in self.cand:
                try:
                    self.selected_idx = self.cand.index(saved_avatar)
                except Exception:
                    pass
            # Also check by avatar_id if available
            elif prof.get("avatar_id"):
                avatar_id = prof.get("avatar_id")
                if 1 <= avatar_id <= len(self.cand):
                    self.selected_idx = avatar_id - 1

        self.avatar_labels = []
        for i, fp in enumerate(self.cand):
            try:
                ph = None
                lbl = None
                
                if isinstance(fp, str) and not fp.startswith("placeholder") and os.path.exists(fp):
                    if self._pil is not None:
                        try:
                            Image, ImageTk, ImageDraw = self._pil
                            im = Image.open(fp).convert("RGBA").resize((60, 60))
                            mask = Image.new("L", (60, 60), 0)
                            ImageDraw.Draw(mask).ellipse((0, 0, 60, 60), fill=255)
                            av = Image.new("RGBA", (60, 60), (0, 0, 0, 0))
                            av.paste(im, (0, 0), mask)
                            ph = ImageTk.PhotoImage(av)
                        except Exception:
                            ph = None

                if ph is not None:
                    lbl = tk.Label(wrap, image=ph, width=64, height=64, bg="white",
                                   relief="solid" if i == self.selected_idx else "flat", 
                                   bd=2 if i == self.selected_idx else 1,
                                   highlightthickness=0)
                    lbl.image = ph
                    lbl.configure(highlightbackground="#4285f4" if i == self.selected_idx else "#ddd")
                else:
                    lbl = tk.Canvas(wrap, width=64, height=64, bg="white", highlightthickness=0)
                    colors = ["#4a90e2", "#50e3c2", "#f5a623", "#bd10e0", "#7ed321"]
                    if i == self.selected_idx:
                        lbl.create_rectangle(0, 0, 64, 64, outline="#4285f4", width=2)
                    else:
                        lbl.create_rectangle(0, 0, 64, 64, outline="#ddd", width=1)
                    lbl.create_oval(8, 8, 56, 56, fill=colors[i % len(colors)], outline="")

                lbl.grid(row=0, column=i, padx=4, pady=1)
                self.avatar_labels.append(lbl)

                def on_click(e, idx=i):
                    self.selected_idx = idx
                    for j, child in enumerate(self.avatar_labels):
                        if isinstance(child, tk.Label):
                            child.configure(relief="solid" if j == self.selected_idx else "flat",
                                          bd=2 if j == self.selected_idx else 1,
                                          highlightbackground="#4285f4" if j == self.selected_idx else "#ddd")
                        else:
                            child.delete("all")
                            colors = ["#4a90e2", "#50e3c2", "#f5a623", "#bd10e0", "#7ed321"]
                            if j == self.selected_idx:
                                child.create_rectangle(0, 0, 64, 64, outline="#4285f4", width=2)
                            else:
                                child.create_rectangle(0, 0, 64, 64, outline="#ddd", width=1)
                            child.create_oval(8, 8, 56, 56, fill=colors[j % len(colors)], outline="")
                
                lbl.bind("<Button-1>", on_click)
                
            except Exception:
                pass

        # Cloud Sync Section - More Professional
        sync_frame = tk.Frame(container, bg="white", relief="solid", bd=1)
        sync_frame.pack(fill="x", pady=(10, 0))
        
        # Sync header with tooltip
        sync_header = tk.Frame(sync_frame, bg="#f8f9fa")
        sync_header.pack(fill="x", padx=1, pady=0)

        header_left = tk.Frame(sync_header, bg="#f8f9fa")
        header_left.pack(side="left", fill="x", expand=True, padx=10, pady=8)

        title_row = tk.Frame(header_left, bg="#f8f9fa")
        title_row.pack(anchor="w")

        tk.Label(title_row, text="‚òÅ", bg="#f8f9fa", fg="#4285f4",
                font=("Segoe UI", 14)).pack(side="left")
        tk.Label(title_row, text="Cloud Backup", bg="#f8f9fa", fg="#333",
                font=("Segoe UI", 11, "bold")).pack(side="left", padx=(5, 0))

        # Tooltip with better styling
        info_btn = tk.Label(title_row, text="‚ìò", bg="#f8f9fa", fg="#999", 
                          font=("Segoe UI", 10), cursor="hand2")
        info_btn.pack(side="left", padx=(8, 0))

        def show_info(e=None):
            info_window = tk.Toplevel(self)
            info_window.title("Cloud Sync Benefits")
            info_window.geometry("320x260")
            info_window.transient(self)
            info_window.grab_set()
            info_window.configure(bg="white")
            
            tk.Label(info_window, text="‚òÅ Cloud Sync Benefits", bg="white", fg="#333",
                    font=("Segoe UI", 12, "bold")).pack(pady=(15, 0))
            
            benefits = [
                "‚úì Automatic backup to cloud",
                "‚úì Restore data after reinstall", 
                "‚úì Protection from data loss",
                "‚úì Sync across devices",
                "‚úì Secure authentication"
            ]
            
            for benefit in benefits:
                tk.Label(info_window, text=benefit, bg="white", fg="#666",
                        font=("Segoe UI", 10), anchor="w").pack(anchor="w", padx=40, pady=1)
            
            tk.Button(info_window, text="Got it!", bg="#4285f4", fg="white",
                     font=("Segoe UI", 10), bd=0, padx=20, pady=1,
                     command=info_window.destroy).pack(pady=1)

        info_btn.bind("<Button-1>", show_info)

        tk.Label(header_left, text="Optional ‚Ä¢ Secure ‚Ä¢ Free", bg="#f8f9fa", fg="#999",
                font=("Segoe UI", 9)).pack(anchor="w")

        # Auth content area - dynamic height
        self.auth_content = tk.Frame(sync_frame, bg="white")
        self.auth_content.pack(fill="both", padx=10, pady=(5, 10))
        
        # Status/signed in area (initially hidden)
        self.signed_in_frame = tk.Frame(self.auth_content, bg="white")
        
        # Sign in options frame
        self.signin_frame = tk.Frame(self.auth_content, bg="white")
        self.signin_frame.pack(fill="x")
        
        # Email auth frame (initially hidden)
        self.email_auth_frame = tk.Frame(self.auth_content, bg="white")
        
        # Initial sign in buttons
        btn_container = tk.Frame(self.signin_frame, bg="white")
        btn_container.pack(fill="x")
        
        self.google_btn = tk.Button(btn_container, text="Sign in with Google",
                                   font=('Segoe UI', 10), bg="#4285f4", fg="white",
                                   bd=0, padx=15, pady=8, cursor="hand2",
                                   command=self._initiate_google_signin)
        self.google_btn.pack(side="left", fill="x", expand=True, padx=(0, 5))
        
        self.email_signin_btn = tk.Button(btn_container, text="Sign in with Email",
                                         font=('Segoe UI', 10), bg="#00ACC1", fg="white",
                                         bd=0, padx=15, pady=8, cursor="hand2",
                                         command=self._toggle_email_auth)
        self.email_signin_btn.pack(side="left", fill="x", expand=True, padx=(5, 0))
        
        # Email auth fields (hidden by default)
        self._create_email_auth_fields()
        
        # Save & Continue button at bottom
        btn_frame = tk.Frame(container, bg="white")
        btn_frame.pack(side="bottom", pady=(15, 0))
        
        self.continue_btn = tk.Button(btn_frame, text="Save & Continue", 
                                     command=self._save, font=("Segoe UI", 11, "bold"),
                                     bg="#4CAF50", fg="white", bd=0, padx=25, pady=4,
                                     cursor="hand2")
        self.continue_btn.pack()
        
        # Check existing auth
        self._check_existing_auth()

    def _create_email_auth_fields(self):
        """Create email authentication fields"""
        # Email field only - compact layout
        tk.Label(self.email_auth_frame, text="Enter Email for Cloud Backup", bg="white", fg="#333",
                font=("Segoe UI", 10)).pack(anchor="w", pady=(2, 1))
        
        self.auth_email_var = tk.StringVar()
        email_entry = tk.Entry(self.email_auth_frame, textvariable=self.auth_email_var,
                              font=("Segoe UI", 10), relief="solid", bd=1)
        email_entry.pack(fill="x", ipady=4)
        email_entry.focus()
        
        # Button row
        btn_row = tk.Frame(self.email_auth_frame, bg="white")
        btn_row.pack(fill="x", pady=(8, 0))
        
        tk.Button(btn_row, text="Cancel", font=("Segoe UI", 9),
                 bg="#f0f0f0", fg="#666", bd=0, padx=12, pady=2,
                 command=self._toggle_email_auth).pack(side="left", padx=(0, 5))
        
        tk.Button(btn_row, text="Send OTP", font=("Segoe UI", 9, "bold"),
                 bg="#4CAF50", fg="white", bd=0, padx=15, pady=2,
                 command=self._send_otp_email).pack(side="right")
        
        # Status label for email auth
        self.email_status_label = tk.Label(self.email_auth_frame, text="", 
                                          bg="white", font=("Segoe UI", 8))
        self.email_status_label.pack(pady=(4, 0))

    def _toggle_email_auth(self):
        """Toggle between sign in buttons and email form"""
        if self.email_auth_frame.winfo_viewable():
            self.email_auth_frame.pack_forget()
            self.signin_frame.pack(fill="x")
        else:
            self.signin_frame.pack_forget()
            self.email_auth_frame.pack(fill="x")

    def _send_otp_email(self):
        """Send OTP with timeout handling"""
        import time
        current_time = time.time()
        
        # Check timeout (3 minutes = 180 seconds)
        if self.last_otp_time and (current_time - self.last_otp_time) < 180:
            remaining = int(180 - (current_time - self.last_otp_time))
            self.email_status_label.config(text=f"‚è± Wait {remaining}s before resending", fg="#FF9800")
            return
        
        # Get name from main form
        name = self.name_var.get().strip()
        email = self.auth_email_var.get().strip()
        
        if not name:
            self.email_status_label.config(text="‚ùå Please enter your name above", fg="red")
            return
        
        if not self._is_valid_email(email):
            self.email_status_label.config(text="‚ùå Invalid email address", fg="red")
            return
        
        self.email_status_label.config(text="üì§ Sending OTP...", fg="#4285f4")
        
        import uuid, random, string
        from datetime import datetime
        
        self.pending_user_data = {
            'uid': str(uuid.uuid4()),
            'name': name,
            'email': email,
            'auth_method': 'email',
            'created_at': datetime.now().isoformat()
        }
        
        self.current_otp = ''.join(random.choices(string.digits, k=6))
        
        if self._send_otp(email, self.current_otp):
            self.last_otp_time = current_time
            self.otp_attempts = 0
            self._show_otp_verification()
        else:
            self.email_status_label.config(text="‚ùå Failed to send OTP", fg="red")

    def _show_otp_verification(self):
        """Show OTP verification in the same frame"""
        # Clear email auth frame
        for widget in self.email_auth_frame.winfo_children():
            widget.destroy()
        
        tk.Label(self.email_auth_frame, text="Enter Verification Code", bg="white", fg="#333",
                font=("Segoe UI", 10, "bold")).pack(pady=(0, 1))
        
        tk.Label(self.email_auth_frame, text=f"Sent to: {self.pending_user_data['email']}", 
                bg="white", fg="#666", font=("Segoe UI", 8)).pack()
        
        # OTP entry - compact
        otp_frame = tk.Frame(self.email_auth_frame, bg="white")
        otp_frame.pack(pady=(5, 3))
        
        self.otp_var = tk.StringVar()
        otp_entry = tk.Entry(otp_frame, textvariable=self.otp_var, font=("Segoe UI", 13),
                            width=10, justify="center", relief="solid", bd=1)
        otp_entry.pack()
        otp_entry.focus()
        
        # Status for OTP - compact
        self.otp_status_label = tk.Label(self.email_auth_frame, text="", 
                                        bg="white", font=("Segoe UI", 8))
        self.otp_status_label.pack(pady=0)
        
        # Buttons - minimal spacing
        btn_row = tk.Frame(self.email_auth_frame, bg="white")
        btn_row.pack(pady=(4, 0))
        
        tk.Button(btn_row, text="Cancel", font=("Segoe UI", 8),
                 bg="#f0f0f0", fg="#666", bd=0, padx=10, pady=4,
                 command=self._cancel_otp).pack(side="left", padx=(0, 4))
        
        self.resend_btn = tk.Button(btn_row, text="Resend", font=("Segoe UI", 8),
                                   bg="#2196F3", fg="white", bd=0, padx=10, pady=4,
                                   command=self._resend_otp)
        self.resend_btn.pack(side="left", padx=(0, 4))
        
        self.verify_btn = tk.Button(btn_row, text="Verify", font=("Segoe UI", 8, "bold"),
                                   bg="#4CAF50", fg="white", bd=0, padx=12, pady=4,
                                   command=self._verify_otp)
        self.verify_btn.pack(side="left")
        
        # Start countdown for resend
        self._update_resend_timer()

    def _update_resend_timer(self):
        """Update resend button with countdown"""
        import time
        current_time = time.time()
        
        if self.last_otp_time:
            elapsed = current_time - self.last_otp_time
            remaining = max(0, 180 - int(elapsed))  # 3 minutes = 180 seconds
            
            if remaining > 0:
                mins = remaining // 60
                secs = remaining % 60
                self.resend_btn.config(text=f"Resend ({mins}:{secs:02d})", state="disabled", bg="#ccc")
                self.after(1000, self._update_resend_timer)
            else:
                self.resend_btn.config(text="Resend", state="normal", bg="#2196F3")

    def _resend_otp(self):
        """Resend OTP"""
        email = self.pending_user_data['email']
        self.email_status_label.config(text="üì§ Resending...", fg="#4285f4")
        
        import random, string, time
        self.current_otp = ''.join(random.choices(string.digits, k=6))
        
        if self._send_otp(email, self.current_otp):
            self.last_otp_time = time.time()
            self.otp_attempts = 0
            self.otp_status_label.config(text="‚úì OTP resent", fg="#4CAF50")
            self._update_resend_timer()
        else:
            self.otp_status_label.config(text="‚ùå Failed to resend", fg="red")

    def _verify_otp(self):
        """Verify OTP with attempt tracking"""
        self.otp_status_label.config(text="‚è≥ Verifying...", fg="#4285f4")
        
        if self.otp_var.get().strip() == self.current_otp:
            self.otp_status_label.config(text="‚úì Verified successfully!", fg="#4CAF50")
            self.after(500, lambda: self._on_auth_success(self.pending_user_data))
        else:
            self.otp_attempts += 1
            if self.otp_attempts >= 3:
                self.otp_status_label.config(text="‚ùå Too many attempts. Please resend OTP", fg="red")
                self.verify_btn.config(state="disabled", bg="#ccc")
            else:
                remaining = 3 - self.otp_attempts
                self.otp_status_label.config(text=f"‚ùå Invalid OTP. {remaining} attempts left", fg="red")

    def _cancel_otp(self):
        """Cancel OTP verification"""
        # Recreate email auth fields
        for widget in self.email_auth_frame.winfo_children():
            widget.destroy()
        self._create_email_auth_fields()

    def _initiate_google_signin(self):
        """Initiate Google OAuth flow ‚Äî credentials managed by Firebase backend."""
        try:
            # Temporarily remove topmost while browser is opening
            self.attributes('-topmost', False)

            from Authenticator import get_free_port, GOOGLE_AUTH_URL
            import threading, webbrowser
            from urllib.parse import urlencode

            GOOGLE_CLIENT_ID = get_secret("GOOGLE_CLIENT_ID")

            if not GOOGLE_CLIENT_ID:
                messagebox.showerror(
                    "Configuration Error",
                    "‚ùå GOOGLE_CLIENT_ID secret not found ‚Äî please check Secret Manager."
                )
                return

            redirect_port = get_free_port()
            redirect_uri = f"http://localhost:{redirect_port}/callback"

            auth_params = {
                'client_id': GOOGLE_CLIENT_ID,
                'redirect_uri': redirect_uri,
                'response_type': 'code',
                'scope': 'openid email profile',
                'access_type': 'offline',
                'prompt': 'select_account'
            }

            auth_url = GOOGLE_AUTH_URL + '?' + urlencode(auth_params)

            def start_server():
                from Authenticator import OAuthCallbackHandler
                from http.server import HTTPServer

                server = HTTPServer(('localhost', redirect_port), OAuthCallbackHandler)
                server.auth_code = None
                server.timeout = 120

                while server.auth_code is None:
                    server.handle_request()

                if server.auth_code:
                    # ‚úÖ Firebase will handle token exchange securely
                    self.after(0, lambda: self._exchange_google_code(server.auth_code, redirect_uri))

            threading.Thread(target=start_server, daemon=True).start()
            webbrowser.open(auth_url)

            # Update button to show waiting state
            self.google_btn.config(text="‚è≥ Waiting for Google...", bg="#FFA726")

        except Exception as e:
            self.attributes('-topmost', False)
            messagebox.showerror("Error", f"Google sign-in failed: {e}", parent=self)


    def _exchange_google_code(self, auth_code, redirect_uri):
        """Exchange Google auth code directly with Google (no backend needed)."""
        import requests
        from secrets_util import get_secret

        try:
            GOOGLE_CLIENT_ID = get_secret("GOOGLE_CLIENT_ID")
            GOOGLE_CLIENT_SECRET = get_secret("GOOGLE_CLIENT_SECRET")
            TOKEN_URL = "https://oauth2.googleapis.com/token"
            USERINFO_URL = "https://www.googleapis.com/oauth2/v2/userinfo"

            # Step 1: Exchange auth code for access token
            data = {
                "code": auth_code,
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "redirect_uri": redirect_uri,
                "grant_type": "authorization_code",
            }
            token_response = requests.post(TOKEN_URL, data=data).json()

            if "access_token" not in token_response:
                self.google_btn.config(text="Sign in with Google", bg="#4285f4")
                from tkinter import messagebox
                messagebox.showerror("Error", f"Token exchange failed:\n{token_response}", parent=self)
                return

            # Step 2: Fetch user info from Google
            headers = {"Authorization": f"Bearer {token_response['access_token']}"}
            user_info = requests.get(USERINFO_URL, headers=headers).json()

            if user_info.get("email"):
                user_data = {
                    'uid': user_info.get('id'),
                    'email': user_info.get('email'),
                    'name': user_info.get('name'),
                    'picture': user_info.get('picture'),
                    'google_id': user_info.get('id'),
                    'auth_method': 'google',
                    'created_at': token_response.get('issued_at', '')
                }
                self._on_auth_success(user_data)
            else:
                self.google_btn.config(text="Sign in with Google", bg="#4285f4")
                from tkinter import messagebox
                messagebox.showerror("Error", "Failed to get user info", parent=self)

        except Exception as e:
            self.google_btn.config(text="Sign in with Google", bg="#4285f4")
            print(f"[AUTH] Google failed: {e}")


    def _on_auth_success(self, user_data):
        """NEW sign-in complete - check cloud data before creating flags"""
        import os
        
        print(f"[AUTH] NEW SIGN-IN: {user_data.get('email')}")
        
        self.user_authenticated = True
        self.auth_user_data = user_data
        
        # Save auth data locally FIRST
        try:
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            os.makedirs(os.path.dirname(user_config_file), exist_ok=True)
            
            import hashlib, platform
            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
            hostname = platform.node()
            user_data['machine_fingerprint'] = hashlib.md5(f"{system_info}-{hostname}".encode()).hexdigest()[:16]
            
            with open(user_config_file, 'w') as f:
                json.dump(user_data, f, indent=2)
            print(f"[AUTH] Saved auth config")
        except Exception as e:
            print(f"[AUTH] Save failed: {e}")
            messagebox.showerror("Error", f"Failed to save authentication: {e}", parent=self)
            return
        
        # Check if user has cloud data before creating restore flags
        has_cloud_data = self._check_cloud_data_exists(user_data)
        
        if has_cloud_data:
            print("[AUTH] Cloud data exists - will create restore flags")
            
            # CREATE TWO FLAGS only if cloud data exists
            appdata_dir = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            
            # Flag 1: Skip backup on close
            try:
                restart_flag_file = os.path.join(appdata_dir, '.pending_restart')
                with open(restart_flag_file, 'w') as f:
                    f.write('skip_backup_for_restore')
                print("[AUTH] ‚úì Restart flag created")
            except Exception as e:
                print(f"[AUTH] WARNING: Failed to create restart flag: {e}")
            
            # Flag 2: Force full restore
            try:
                force_restore_flag = os.path.join(appdata_dir, '.force_full_restore')
                with open(force_restore_flag, 'w') as f:
                    f.write('restore_all_files')
                print("[AUTH] ‚úì Force restore flag created")
            except Exception as e:
                print(f"[AUTH] WARNING: Failed to create force restore flag: {e}")
            
            # Ask user to close and restart
            restart = messagebox.askyesno(
                "Sign-in Successful",
                f"Welcome back, {user_data.get('name', user_data.get('email'))}!\n\n"
                "Your cloud backup was found.\n\n"
                "To restore your data, please restart the app.\n\n"
                "Click Yes to close now and restart manually.\n"
                "Click No to continue without restoring.",
                parent=self
            )
            
            if restart:
                print("[AUTH] User will restart - closing app...")
                self.grab_release()
                self.destroy()
                self._restart_app()
            else:
                print("[AUTH] User declined restart")
                # Remove BOTH flags if declined
                try:
                    restart_flag_file = os.path.join(appdata_dir, '.pending_restart')
                    force_restore_flag = os.path.join(appdata_dir, '.force_full_restore')
                    
                    if os.path.exists(restart_flag_file):
                        os.remove(restart_flag_file)
                    if os.path.exists(force_restore_flag):
                        os.remove(force_restore_flag)
                except:
                    pass
                
                self._show_restart_warning(user_data)
        else:
            print("[AUTH] No cloud data - first time sign-up, no restore needed")
            
            # Just show success without restart
            self._show_signed_in_success(user_data)
            
    def _check_cloud_data_exists(self, user_data):
        """Check if user has any data backed up in cloud"""
        try:
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = user_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            
            # Connect
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[CHECK-CLOUD] No credentials")
                return False
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            
            # Check if user exists in sheet with data
            from secrets_util import get_encrypted_gspread_client
            auth_sys.gspread_client = get_encrypted_gspread_client()

            if not auth_sys.gspread_client:
                print("[CHECK-CLOUD] Could not initialize GSpread client")
                return False

            sheet = auth_sys.gspread_client.open_by_key(auth_sys.sheet_id)
            worksheet = sheet.worksheet(auth_sys.worksheet_name)
            records = worksheet.get_all_records()
            worksheet = sheet.worksheet(auth_sys.worksheet_name)
            records = worksheet.get_all_records()
            
            print(f"[CHECK-CLOUD] Checking for email: {user_data.get('email')}")
            
            for record in records:
                if record.get('email') == user_data.get('email'):
                    print(f"[CHECK-CLOUD] Found user record!")
                    
                    # Check with correct field names (with suffixes)
                    has_data = bool(
                        record.get('profile_json') or
                        record.get('wastage_log_csv') or 
                        record.get('total_studied_time_json') or
                        record.get('wastage_by_day_json') or
                        record.get('studied_today_time_json') or
                        record.get('exam_date_json') or
                        record.get('opened_days_txt') or
                        record.get('goal_config_json') or
                        record.get('plans_json')
                    )
                    
                    print(f"[CHECK-CLOUD] has_data result: {has_data}")
                    return has_data
            
            print("[CHECK-CLOUD] User email not found in sheet")
            return False
            
        except Exception as e:
            print(f"[CHECK-CLOUD] Error: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _show_signed_in_success(self, user_data):
        """Show success message for first-time sign-ups (no restart needed)"""
        self.signin_frame.pack_forget()
        self.email_auth_frame.pack_forget()
        self.signed_in_frame.pack(fill="x")
        
        for widget in self.signed_in_frame.winfo_children():
            widget.destroy()
        
        success_frame = tk.Frame(self.signed_in_frame, bg="#e8f5e9", relief="solid", bd=1)
        success_frame.pack(fill="x", pady=(5, 4))
        
        info_frame = tk.Frame(success_frame, bg="#e8f5e9")
        info_frame.pack(fill="x", padx=10, pady=10)
        
        tk.Label(info_frame, text="‚úì", bg="#e8f5e9", fg="#4CAF50",
                font=("Segoe UI", 16, "bold")).pack(side="left", padx=(0, 8))
        
        text_frame = tk.Frame(info_frame, bg="#e8f5e9")
        text_frame.pack(side="left", fill="x", expand=True)
        
        tk.Label(text_frame, text="Successfully signed in", bg="#e8f5e9", fg="#2e7d32",
                font=("Segoe UI", 10, "bold")).pack(anchor="w")
        
        email_text = user_data.get('email', 'User')
        if len(email_text) > 30:
            email_text = email_text[:27] + "..."
        tk.Label(text_frame, text=email_text, bg="#e8f5e9", fg="#558b2f",
                font=("Segoe UI", 9)).pack(anchor="w", pady=(2, 0))
        
        # Sign out button on the right
        signout_btn = tk.Button(info_frame, text="Sign Out",
                               font=('Segoe UI', 9), bg="#ef5350", fg="white",
                               bd=0, padx=12, pady=5, cursor="hand2",
                               command=self._handle_signout)
        signout_btn.pack(side="right")
        
        # Benefit message with more padding
        tk.Label(self.signed_in_frame, text="‚úì Cloud backup enabled - your data will be saved automatically",
                bg="white", fg="#66bb6a", font=("Segoe UI", 9)).pack(pady=(8, 8))
        
        # Pre-fill name
        if user_data.get('name') and not self.name_var.get():
            self.name_var.set(user_data['name'])

    def _restart_app(self):
        """Close app with instruction to restart manually"""
        import os
        
        try:
            messagebox.showinfo(
                "App Will Close",
                "The app will close now.\n\n"
                "Please open it again to restore your cloud data.\n\n"
                "Your data is safe and will be restored on next launch.",
                parent=self.app
            )
            
            print("[RESTART] Closing for manual restart")
            os._exit(0)
            
        except Exception as e:
            print(f"[RESTART] Error: {e}")
            os._exit(0)

    def _show_restart_warning(self, user_data):
        """Show warning if restart declined"""
        self.signin_frame.pack_forget()
        self.email_auth_frame.pack_forget()
        self.signed_in_frame.pack(fill="x")
        
        for widget in self.signed_in_frame.winfo_children():
            widget.destroy()
        
        warning_frame = tk.Frame(self.signed_in_frame, bg="#fff3cd", relief="solid", bd=1)
        warning_frame.pack(fill="x", pady=(5, 4))
        
        # Header with icon and text
        header_frame = tk.Frame(warning_frame, bg="#fff3cd")
        header_frame.pack(fill="x", padx=10, pady=(10, 5))
        
        tk.Label(header_frame, text="‚ö†", bg="#fff3cd", fg="#f57c00",
                font=("Segoe UI", 18, "bold")).pack(side="left", padx=(0, 10))
        
        text_frame = tk.Frame(header_frame, bg="#fff3cd")
        text_frame.pack(side="left", fill="x", expand=True)
        
        tk.Label(text_frame, text="Restart Required", bg="#fff3cd", fg="#f57c00",
                font=("Segoe UI", 11, "bold")).pack(anchor="w")
        
        email_text = user_data.get('email', '')
        if len(email_text) > 30:
            email_text = email_text[:27] + "..."
        tk.Label(text_frame, text=f"Signed in: {email_text}", 
                bg="#fff3cd", fg="#666", font=("Segoe UI", 9)).pack(anchor="w", pady=(2, 0))
        
        # Instruction message
        tk.Label(warning_frame, text="Close and reopen the app to restore your cloud data", 
                bg="#fff3cd", fg="#333", font=("Segoe UI", 9)).pack(padx=10, pady=(0, 10))
        
        # Buttons
        btn_frame = tk.Frame(warning_frame, bg="#fff3cd")
        btn_frame.pack(padx=10, pady=(0, 10))
        
        def close_now():
            import os
            appdata_dir = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            
            # Recreate BOTH flags
            try:
                restart_flag_file = os.path.join(appdata_dir, '.pending_restart')
                with open(restart_flag_file, 'w') as f:
                    f.write('skip_backup_for_restore')
                
                force_restore_flag = os.path.join(appdata_dir, '.force_full_restore')
                with open(force_restore_flag, 'w') as f:
                    f.write('restore_all_files')
            except:
                pass
            
            messagebox.showinfo(
                "App Closing",
                "Please reopen the app to restore your data.",
                parent=self
            )
            os._exit(0)
        
        tk.Button(btn_frame, text="Close App Now", font=("Segoe UI", 9, "bold"),
                 bg="#ff9800", fg="white", relief="flat", bd=0, padx=20, pady=7,
                 command=close_now).pack(side="left", padx=(0, 8))
        
        tk.Button(btn_frame, text="Later", font=("Segoe UI", 9),
                 bg="#f0f0f0", fg="#666", relief="flat", bd=0, padx=15, pady=7,
                 command=self.destroy).pack(side="left")
    def _handle_signout(self):
        """Sign out with confirmation"""
        if messagebox.askyesno("Sign Out", "Remove cloud backup access?\n\nYour local data will remain.", parent=self):
            self.user_authenticated = False
            self.auth_user_data = None
            
            # Hide signed in frame
            self.signed_in_frame.pack_forget()
            
            # Show sign in options again
            self.signin_frame.pack(fill="x")
            
            # Reset buttons
            self.google_btn.config(text="Sign in with Google", bg="#4285f4", state="normal")
            self.email_signin_btn.config(state="normal")
            
            # Remove local auth file
            try:
                user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
                if os.path.exists(user_config_file):
                    os.remove(user_config_file)
            except Exception:
                pass

    def _check_existing_auth(self):
        """Check if already authenticated - show UI without triggering restart"""
        try:
            import os, json
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            
            if os.path.exists(user_config_file):
                with open(user_config_file, 'r') as f:
                    user_data = json.load(f)
                
                if user_data.get('email'):
                    print(f"[AUTH] Already authenticated: {user_data.get('email')}")
                    
                    # Just show signed-in UI - DON'T call _on_auth_success
                    self.user_authenticated = True
                    self.auth_user_data = user_data
                    
                    # Hide sign-in options
                    self.signin_frame.pack_forget()
                    self.email_auth_frame.pack_forget()
                    
                    # Show signed-in frame
                    self.signed_in_frame.pack(fill="x")
                    
                    # Build signed-in UI
                    for widget in self.signed_in_frame.winfo_children():
                        widget.destroy()
                    
                    success_frame = tk.Frame(self.signed_in_frame, bg="#e8f5e9", relief="solid", bd=1)
                    success_frame.pack(fill="x", pady=(5, 4))
                    
                    info_frame = tk.Frame(success_frame, bg="#e8f5e9")
                    info_frame.pack(fill="x", padx=10, pady=6)
                    
                    tk.Label(info_frame, text="‚úì", bg="#e8f5e9", fg="#4CAF50",
                            font=("Segoe UI", 16, "bold")).pack(side="left", padx=(0, 8))
                    
                    text_frame = tk.Frame(info_frame, bg="#e8f5e9")
                    text_frame.pack(side="left", fill="x", expand=True)
                    
                    tk.Label(text_frame, text="Signed in", bg="#e8f5e9", fg="#2e7d32",
                            font=("Segoe UI", 10, "bold")).pack(anchor="w")
                    
                    email_text = user_data.get('email', '')[:30]
                    tk.Label(text_frame, text=email_text, bg="#e8f5e9", fg="#558b2f",
                            font=("Segoe UI", 9)).pack(anchor="w")
                    
                    self.signout_btn = tk.Button(info_frame, text="Sign Out",
                                                font=('Segoe UI', 9), bg="#ef5350", fg="white",
                                                bd=0, padx=12, pady=4, cursor="hand2",
                                                command=self._handle_signout)
                    self.signout_btn.pack(side="right")
                    
                    tk.Label(self.signed_in_frame, text="‚úì Cloud backup enabled",
                            bg="white", fg="#66bb6a", font=("Segoe UI", 9)).pack(pady=(0, 4))
                    
                    # Pre-fill name
                    if user_data.get('name') and not self.name_var.get():
                        self.name_var.set(user_data['name'])
                    
                    print("[AUTH] Displayed existing auth (NO restart)")
                    
        except Exception as e:
            print(f"[AUTH] Check failed: {e}")

    def _is_valid_email(self, email):
        import re
        return re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email) is not None

    def _send_otp(self, email, otp):
        """Send OTP email"""
        try:
            from Authenticator import SMTP_SERVER, SMTP_PORT, EMAIL_USER, EMAIL_PASSWORD
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            
            # Create a more professional email
            msg = MIMEMultipart('alternative')
            msg['Subject'] = "StudyTimer - Email Verification"
            msg['From'] = EMAIL_USER
            msg['To'] = email
            
            # HTML version
            html = f"""
            <html>
              <body style="font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px;">
                <div style="max-width: 500px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                  <h2 style="color: #4285f4; margin-bottom: 20px;">StudyTimer Verification</h2>
                  <p style="color: #333; font-size: 16px;">Your verification code is:</p>
                  <div style="background: #f0f7ff; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0;">
                    <span style="font-size: 28px; font-weight: bold; color: #4285f4; letter-spacing: 5px;">{otp}</span>
                  </div>
                  <p style="color: #666; font-size: 14px;">This code will expire in 5 minutes.</p>
                  <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
                  <p style="color: #999; font-size: 12px;">If you didn't request this code, please ignore this email.</p>
                </div>
              </body>
            </html>
            """
            
            # Plain text version
            text = f"Your StudyTimer verification code: {otp}\n\nThis code will expire in 5 minutes."
            
            part1 = MIMEText(text, 'plain')
            part2 = MIMEText(html, 'html')
            
            msg.attach(part1)
            msg.attach(part2)
            
            server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
            server.starttls()
            server.login(EMAIL_USER, EMAIL_PASSWORD)
            server.send_message(msg)
            server.quit()
            return True
        except Exception as e:
            print(f"[EMAIL] Failed: {e}")
            return False

    def _save(self):
        """Save profile - all original logic preserved"""
        from tkinter import messagebox
        from datetime import datetime
        import json, os

        nm = (self.name_var.get() or "").strip()
        if not nm:
            self.lift()
            self.bell()
            messagebox.showerror("Name Required", "Please enter your name to continue.", parent=self)
            return

        try:
            dt = datetime.strptime(self.exam_var.get().strip(), "%Y-%m-%d").date()
        except Exception:
            self.lift()
            self.bell()
            messagebox.showerror("Invalid Date", "Please enter date in YYYY-MM-DD format.", parent=self)
            return

        # Save profile locally
        prof = _load_profile()
        if not isinstance(prof, dict):
            prof = {}

        # ‚úÖ Detect exam-name change BEFORE overwriting it
        old_exam_name = (prof.get("exam_name") or "").strip()
        new_exam_name = (self.exam_name_var.get() or "").strip()
        exam_name_changed = bool(old_exam_name and new_exam_name and old_exam_name != new_exam_name)

        prof["user_name"] = nm
        prof["exam_name"] = new_exam_name
        prof["language"] = (self.language_var.get() or "").strip()


        # ‚úÖ Only save avatar if one was selected
        from config_paths import app_paths

        if self.selected_idx is not None:
            prof["avatar_id"] = int(self.selected_idx) + 1

            # Store actual avatar file path instead of placeholder string
            avatar_file_path = os.path.join(app_paths.avatars_dir, f"avatar {prof['avatar_id']}.png")
            if os.path.exists(avatar_file_path):
                prof["avatar_path"] = avatar_file_path
                print(f"[AVATAR] Saved path: {avatar_file_path}")
            else:
                prof["avatar_path"] = f"placeholder{prof['avatar_id']}"  # Fallback
                print(f"[AVATAR] File not found, using placeholder")
        # else: keep existing avatar if any
        
        prof["onboarding_done"] = True
        
        # Add auth data if signed in
        if self.user_authenticated and self.auth_user_data:
            prof["auth_email"] = self.auth_user_data.get('email')
            prof["auth_uid"] = self.auth_user_data.get('uid')
            prof["auth_method"] = self.auth_user_data.get('auth_method')
            print(f"[AUTH] Profile saved with authentication: {self.auth_user_data.get('email')}")
            
            # Save user config locally
            try:
                import hashlib, platform
                user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
                os.makedirs(os.path.dirname(user_config_file), exist_ok=True)
                
                # Generate machine fingerprint
                system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                hostname = platform.node()
                machine_fp = hashlib.md5(f"{system_info}-{hostname}".encode()).hexdigest()[:16]
                
                self.auth_user_data['machine_fingerprint'] = machine_fp
                
                with open(user_config_file, 'w') as f:
                    json.dump(self.auth_user_data, f, indent=2)
                print("[AUTH] User config saved locally")
            except Exception as e:
                print(f"[AUTH] Failed to save user config: {e}")
        else:
            prof.pop("auth_email", None)
            prof.pop("auth_uid", None)
            prof.pop("auth_method", None)
            print("[AUTH] Profile saved without authentication")
        
        _save_profile(prof)
        print("[PROFILE] Local profile saved")

        # Refresh app
        try:
            self.app.user_name = nm
            self.app.avatar_path = prof.get("avatar_path", "")
            if hasattr(self.app, "update_profile_badge"):
                self.app.after(0, self.app.update_profile_badge)
        except Exception as e:
            print(f"[PROFILE] Refresh failed: {e}")

        # Save exam date PER EXAM
        try:
            current_exam_name = (self.exam_name_var.get() or "").strip()
            # Helper is defined in same file
            set_exam_date_for_exam(current_exam_name, dt)

            # Keep runtime copy for graphs etc.
            self.app.progress_exam_date = dt
            if hasattr(self.app, "recompute_required_rates"):
                self.app.recompute_required_rates()
        except Exception as e:
            print(f"[EXAM] Save failed: {e}")


        # Refresh goal/markers
        try:
            if hasattr(self.app, "refresh_goal_and_markers"):
                self.app.refresh_goal_and_markers()
        except Exception as e:
            print(f"[GOAL] Refresh failed: {e}")

        # Push to sheet sync
        def _push_now_or_later(attempt=0):
            try:
                ss = getattr(self.app, "_sheet_sync", None)
                if ss:
                    p2 = _load_profile()
                    ss.update(name=(p2.get("user_name") or ""), online=False)
                    print("[GSYNC] Profile synced")
                    return
                if attempt < 20:
                    self.app.after(500, lambda: _push_now_or_later(attempt+1))
            except Exception as e:
                print(f"[GSYNC] Failed: {e}")

        self.app.after(0, _push_now_or_later)

        # Schedule first cloud backup after 5 minutes (if authenticated)
        if self.user_authenticated and self.auth_user_data:
            print("[BACKUP] First cloud backup scheduled in 5 minutes")
            self.app.after(300000, lambda: self.app.perform_cloud_backup())  # 5 minutes = 300000ms

        # Check referral
        def _check_referral_after_delay():
            try:
                if hasattr(self.app, 'check_first_run_referral'):
                    self.app.check_first_run_referral()
            except Exception as e:
                print(f"[REFERRAL] Failed: {e}")

        self.app.after(1500, _check_referral_after_delay)

        # ‚úÖ SYNC PROFILE TO FIREBASE GROUPS
        try:
            if hasattr(self.app, 'groups') and self.app.groups:
                print("[FIREBASE] Syncing profile to groups...")
                # ‚úÖ UPDATE profile_data reference first!
                self.app.groups.profile_data = prof
                self.app.groups.sync_profile_to_firebase()
        except Exception as e:
            print(f"[FIREBASE] Sync failed: {e}")
            
        # ‚úÖ SYNC TO FIREBASE LEADERBOARD IMMEDIATELY
        try:
            if hasattr(self.app, '_firebase_sync') and self.app._firebase_sync:
                print("[FIREBASE-LB] Syncing name change to leaderboard...")
                self.app._firebase_sync.update(
                    name=nm,
                    online=True
                )
                print("[FIREBASE-LB] ‚úÖ Name synced to leaderboard")
        except Exception as e:
            print(f"[FIREBASE-LB] Sync failed: {e}")
         
        # ‚úÖ If exam name changed, clear old sessions and show popup in main app
        try:
            if exam_name_changed and hasattr(self.app, "handle_exam_name_change"):
                # Run on main app event loop
                self.app.after(
                    0,
                    lambda old=old_exam_name, new=new_exam_name: self.app.handle_exam_name_change(old, new)
                )
        except Exception as e:
            print(f"[EXAM] Error while scheduling exam-change handler: {e}") 

        # Close
        self.attributes('-topmost', False)
        self.grab_release()
        self.destroy()

    
# ---------- realism display gaps ----------
MIN_GAP_MINUTES = 5
GAP_JITTER_MAX_MINUTES = 12
MAX_BACKFILL_CASCADE = 75

def _desired_gap(prev_name: str, name: str, today: date) -> int:
    seed = (hash(prev_name + "|" + name + str(today)) & 0xffffffff)
    r = random.Random(seed).random()
    return MIN_GAP_MINUTES + int(round(r * GAP_JITTER_MAX_MINUTES))



def _enforce_display_gaps(rows):
    """
    Ensure small visual gaps for identical totals.
    Accepts rows of 5 or 6 elements (with optional avatar_id).
    Returns the same shape.
    """
    if not rows:
        return []
    base = []
    for itm in rows:
        if len(itm) >= 6:
            n, wh, st, th, tt, aid = itm[:6]
        else:
            n, wh, st, th, tt = itm[:5]
            aid = None
        try:
            minutes = int(round(float(wh) * 60.0))
        except Exception:
            minutes = 0
        base.append((n, minutes, st, float(th), float(tt), aid))
    disp = list(base)

    def desired_gap(prev_name, curr_name):
        try:
            return 1 if prev_name and curr_name and prev_name.lower() > curr_name.lower() else 0
        except Exception:
            return 0

    for i in range(1, len(disp)):
        pn, pm, ps, pth, ptt, paid = disp[i-1]
        cn, cm, cs, cth, ctt, caid = disp[i]
        need_prev = cm + desired_gap(pn, cn)
        if pm < need_prev:
            disp[i-1] = (pn, need_prev, ps, pth, ptt, paid)
            j = i-2
            while j >= 0:
                jn, jm, js, jth, jtt, jaid = disp[j]
                need2 = disp[j+1][1] + desired_gap(jn, disp[j+1][0])
                if jm < need2:
                    disp[j] = (jn, need2, js, jth, jtt, jaid)
                    j -= 1
                else:
                    break
    out = []
    for tup, orig in zip(disp, rows):
        n, minutes, st, th, tt, aid = tup
        wh = minutes/60.0
        if len(orig) >= 6:
            out.append([n, wh, st, th, tt, aid])
        else:
            out.append([n, wh, st, th, tt])
    return out
    # Normalize to a tuple (name, minutes, status, today, target, avatar_id_opt)
    norm = []
    for item in rows:
        if len(item) >= 6:
            name, week, status, th, tt, aid = item[:6]
        else:
            name, week, status, th, tt = item[:5]
            aid = None
        minutes = int(float(week) * 60)
        norm.append([name, minutes, status, float(th), float(tt), aid])

    base = [tuple(it) for it in norm]  # immutable reference
    disp = [tuple(it) for it in norm]

    today = date.today()
    for i in range(1, len(disp)):
        pn, pm, ps, pth, ptt, paid = disp[i-1]
        n, cm, s, th, tt, aid = disp[i]
        need = _desired_gap(pn, n, today)
        want_prev = cm + need
        if pm < want_prev:
            disp[i-1] = (pn, min(want_prev, base[i-1][1] + MAX_BACKFILL_CASCADE), ps, pth, ptt, paid)
            j = i-2
            while j >= 0:
                pn2, pm2, ps2, pth2, ptt2, paid2 = disp[j]
                gap2 = _desired_gap(pn2, disp[j+1][0], today)
                want2 = disp[j+1][1] + gap2
                if pm2 < want2:
                    disp[j] = (pn2, min(want2, base[j][1] + MAX_BACKFILL_CASCADE), ps2, pth2, ptt2, paid2)
                    j -= 1
                else:
                    break

    # Convert back to shape: week in hours, and keep avatar id if present
    out = []
    for tup in disp:
        name, minutes, status, th, tt, aid = tup
        week_hours = minutes / 60.0
        if aid is None:
            out.append([name, week_hours, status, th, tt])
        else:
            out.append([name, week_hours, status, th, tt, aid])
    return out

# ---------- google sheets helpers ----------
def _internet() -> bool:
    try:
        requests.get("https://www.google.com", timeout=3)
        return True
    except Exception:
        return False
        
def _internet():
    """Check internet connectivity"""
    try:
        import urllib.request
        urllib.request.urlopen('http://www.google.com', timeout=5)
        return True
    except:
        return False
        




def _parse_hhmm_to_hours(s: str) -> float:
    """Convert 'HH:MM' or 'HH:MM:SS' to hours as float; accept plain numeric too."""
    try:
        s = (s or "").strip()
        if not s:
            return 0.0
        if ":" in s:
            parts = s.split(":")
            if len(parts) == 2:
                h, m = int(parts[0]), int(parts[1])
                return max(0.0, h + m/60.0)
            if len(parts) == 3:
                h, m, sec = int(parts[0]), int(parts[1]), int(parts[2])
                return max(0.0, h + m/60.0 + sec/3600.0)
        return float(s)
    except Exception:
        return 0.0



        
def _load_avatars(folder=None):
    if folder is None:
        folder = app_paths.avatars_dir
    try:
        return sorted(
            os.path.join(folder, f) for f in os.listdir(folder)
            if f.lower().endswith((".png", ".jpg", ".jpeg", ".webp", ".gif"))
        )
    except Exception:
        return []

def _circle(path, size=18, online=False, greyed=False):
    try:
        img = Image.open(path).convert("RGBA").resize((size, size))
    except Exception:
        img = PILImage.new("RGBA", (size, size), (200,200,200,255))
    if greyed:
        r,g,b,a = img.split()
        grey = Image.merge("RGB",(r,r,r)).convert("L")
        img = Image.merge("RGBA",(grey,grey,grey,a))
    mask = Image.new("L",(size,size),0)
    d = ImageDraw.Draw(mask); d.ellipse((0,0,size,size), fill=255)
    canvas = Image.new("RGBA",(size+10,size+10),(0,0,0,0))
    canvas.paste(img,(0,0),mask)
    if online and not greyed:
        d2 = ImageDraw.Draw(canvas)
        r2 = max(2, size//6); b2 = max(1, r2//3)
        x0 = size - r2*2 - b2; y0 = size - r2*2 - b2
        d2.ellipse((x0,y0,size,size), fill="white")
        d2.ellipse((x0+b2,y0+b2,size-b2,size-b2), fill="green")
    return ImageTk.PhotoImage(canvas)
    
def init_firebase(service_account, database_url):
    """Initialize Firebase - handles both dict and file path"""
    try:
        if not firebase_admin._apps:
            if isinstance(service_account, dict):
                cred = credentials.Certificate(service_account)
            else:
                cred = credentials.Certificate(service_account)
            firebase_admin.initialize_app(cred, {'databaseURL': database_url})
        return True
    except Exception as e:
        print(f"[FIREBASE INIT ERROR] {e}")
        return False
    
class LeaderboardTablePanel(ttk.Frame):
    def __init__(self, parent, database_url, service_account_path,
                 title_text="Leaderboard", poll_seconds=60, width=560, height=330,
                 show_rows=10, avatars_folder=app_paths.avatars_dir):
        super().__init__(parent)

        # ---------- state ----------
        self.title_base = "Weekly Leaderboard"
        self._net_ok = True
        self.database_url = database_url
        init_firebase(service_account_path, database_url)
        self.poll_ms = max(15000, poll_seconds * 1000)
        self.show_rows = max(3, show_rows)
        self.avatars_folder = avatars_folder
        self.avatar_files = _load_avatars(avatars_folder)
        self.medal_icons = _load_medal_icons(app_paths.medals_dir, size=20)
        self.avatar_refs = []
        self._last_disp = []
        
        # Virtual scrolling data
        self._all_data = []  # Complete dataset
        self._visible_start = 0  # First visible row index
        self._visible_count = self.show_rows + 6  # Visible rows + larger buffer
        self._row_height = 24  # Estimated row height in pixels
        
        # Pre-rendering cache for smooth scrolling
        self._rendered_cache = {}  # Cache of pre-rendered row data
        self._cache_range = (0, 0)  # Currently cached range
        self._prerender_size = self.show_rows * 3  # Pre-render 3 screens worth
        
        # Performance optimizations
        self._last_render_time = 0  # Debounce rapid renders
        self._pending_render = None  # Pending render operation
        self._image_cache = {}  # Cache for avatar/medal images

        # ---------- outer flat card ----------
        self.box = tk.Frame(self, bg="#ffffff", bd=0, highlightthickness=0)
        self.box.pack(fill="both", expand=True)

        # background inset (wet-sand) canvas
        self.bg_canvas = tk.Canvas(self.box, bg="#ffffff", bd=0, highlightthickness=0)
        self.bg_canvas.pack(fill="both", expand=True)
        try:
            self.bg_canvas.lower()
        except Exception:
            pass

        # title label
        self.title_lbl = tk.Label(self.box, text=title_text, bg="#ffffff",
                                  fg="#3c4350", font=("Segoe UI", 10, "bold"))
        # --- tiny "you(x)" stuck to the title ---
        self.you_rank_lbl = tk.Label(
            self.box, text=" you (-)", bg="#ffffff",
            fg="#000000", font=("Segoe UI", 8)
        )
        self.you_rank_lbl.place(x=200, y=8)   # will be re-positioned below

        def _place_you_rank(_evt=None):
            """Keep the small 'you(x)' label right after the title text."""
            try:
                self.box.update_idletasks()
                x = 14 + self.title_lbl.winfo_width() + 6
                self.you_rank_lbl.place_configure(x=x, y=8)
            except Exception:
                pass

        self.title_lbl.bind("<Configure>", _place_you_rank)
        self.after(0, _place_you_rank)                          
        
        # overlay content container
        self.content = tk.Frame(self.box, bg="#ffffff", bd=0, highlightthickness=0)
        self.content.place(relx=0, rely=0, relwidth=1, relheight=1)
        try:
            self.content.lift()
        except Exception:
            pass
        self.title_lbl.place(x=14, y=8)
        self.reset_hint_lbl = tk.Label(
            self.box,
            text="will be reseted every Sunday 11:59 PM ‚Ä¢ Total entries 0",
            bg="#ffffff", fg="#000000", font=("Segoe UI", 8)  # Pure black color
        )
        # bottom-left inside the card
        self.reset_hint_lbl.place(relx=0.0, rely=1.0, x=14, y=-8, anchor="sw")
        self.you_rank_lbl.lift()

        # Custom header (Canvas) ‚Äî removes native boxy headers entirely
        self.header = tk.Canvas(self.content, height=28, bg="#f9fbfe",
                                bd=0, highlightthickness=0)
        self.header.pack(side="top", fill="x", padx=(14,8), pady=(32,0))

        # ========== VIRTUAL SCROLLABLE TREEVIEW SECTION ==========
        # Create a frame to hold treeview + scrollbars (same background as content)
        self.tree_frame = tk.Frame(self.content, bg="#ffffff", bd=0, highlightthickness=0)
        self.tree_frame.pack(side="left", fill="both", expand=True, padx=(14,8), pady=(0,12))
        
        # Configure grid weights for proper resizing
        self.tree_frame.grid_rowconfigure(0, weight=1)
        self.tree_frame.grid_columnconfigure(0, weight=1)

        # Treeview body with NO headings (theme-proof) - Keep original height for consistent look
        cols = ("Rank", "Time (HH:MM)", "Status")
        self.tv_style = ttk.Style(self)
        try:
            self.tv_style.theme_use("clam")
        except Exception:
            pass
        self.tv_style.configure("Flat.Treeview", background="#ffffff",
                                fieldbackground="#ffffff", borderwidth=0, relief="flat")
        
        # Configure ultra-ultra-slim scrollbar styles (2.5px width)
        self.tv_style.configure("UltraSlim.Vertical.TScrollbar", 
                               gripcount=0,
                               background="#c8c8c8",
                               troughcolor="#fafafa",
                               bordercolor="#fafafa",
                               arrowcolor="#777777",
                               darkcolor="#c8c8c8",
                               lightcolor="#c8c8c8",
                               width=3,  # Ultra-ultra-slim (2.5px effective)
                               relief="flat",
                               borderwidth=0)
        
        self.tv_style.configure("UltraSlim.Horizontal.TScrollbar",
                               gripcount=0, 
                               background="#c8c8c8",
                               troughcolor="#fafafa",
                               bordercolor="#fafafa",
                               arrowcolor="#777777",
                               darkcolor="#c8c8c8",
                               lightcolor="#c8c8c8",
                               width=3,  # Ultra-ultra-slim (2.5px effective)
                               relief="flat",
                               borderwidth=0)
        
        # Keep the original height but allow virtual scrolling
        self.tree = ttk.Treeview(self.tree_frame, columns=cols, show="tree",
                                 height=self.show_rows, style="Flat.Treeview")
        try: 
            self.tree.configure(takefocus=False)
        except Exception: 
            pass
        
        # Place treeview in grid
        self.tree.grid(row=0, column=0, sticky="nsew")

        # ========== ADD VIRTUAL SCROLLING SUPPORT ==========
        # Custom vertical scrollbar for virtual scrolling
        self.v_scrollbar = ttk.Scrollbar(self.tree_frame, orient="vertical", 
                                        command=self._on_virtual_scroll, 
                                        style="UltraSlim.Vertical.TScrollbar")
        
        # Horizontal scrollbar (standard behavior)
        self.h_scrollbar = ttk.Scrollbar(self.tree_frame, orient="horizontal", 
                                        command=self.tree.xview, 
                                        style="UltraSlim.Horizontal.TScrollbar")
        self.tree.configure(xscrollcommand=self._on_h_scroll)
        
        # Track scrollbar visibility and state
        self._v_scrollbar_visible = False
        self._h_scrollbar_visible = False
        self._v_scrollbar_needed = False
        self._h_scrollbar_needed = False
        self._mouse_in_tree_area = False
        self._hide_timer = None
        
        # Bind mouse enter/leave events for auto-hiding scrollbars
        self._bind_hover_events()
        
        # Bind mouse wheel for virtual scrolling
        self.tree.bind("<MouseWheel>", self._on_mousewheel)
        self.tree.bind("<Button-4>", self._on_mousewheel)  # Linux
        self.tree.bind("<Button-5>", self._on_mousewheel)  # Linux

        # tag for offline greying
        try:
            self.tree.tag_configure("offlinegrey", foreground="#6b6b6b", background="#f3f3f3")
        except Exception:
            pass

        # Responsive columns + paint header
        self._col_fracs = (0.48, 0.12, 0.20, 0.20)
        def _resize_columns_and_header(evt=None):
            try:
                total = max(1, self.tree.winfo_width())
                name_w  = int(total * self._col_fracs[0])
                rank_w  = int(total * self._col_fracs[1])
                time_w  = int(total * self._col_fracs[2])
                stat_w  = int(total * self._col_fracs[3])
                self.tree.column("#0", width=name_w)
                self.tree.column("Rank", width=rank_w, anchor="center")
                self.tree.column("Time (HH:MM)", width=time_w, anchor="center")
                self.tree.column("Status", width=stat_w, anchor="center")
                # draw header: center ALL labels (Name, Rank, Time, Status)
                self.header.delete("all")
                xpad = 1
                widths = [name_w, rank_w, time_w, stat_w]
                labels = ["Name", "Rank", "Time", "Status"]
                x = xpad
                for i, (lab, wid) in enumerate(zip(labels, widths)):
                    cx = x + wid/2
                    self.header.create_text(cx, 14, text=lab, anchor="center",
                                            fill="#2d2f33", font=("Segoe UI", 10, "bold"))
                    x += wid
                    if i < 3:
                        self.header.create_line(x, 7, x, 24, fill="#e7ebf0")
                # bottom hairline
                self.header.create_line(0, 27, self.header.winfo_width(), 27, fill="#e7ebf0")
            except Exception:
                pass
        self.tree.bind("<Configure>", _resize_columns_and_header)
        self.header.bind("<Configure>", _resize_columns_and_header)

        # draw the inset on resize (flat outside)
        def _on_resize(evt=None):
            try:
                w = max(60, self.box.winfo_width())
                h = max(60, self.box.winfo_height())
                _draw_inset_sand(self.bg_canvas, w, h, radius=18, blur=18, edge=12, depth=80)
                self.bg_canvas.lower(); self.content.lift(); self.title_lbl.lift(); self.reset_hint_lbl.lift()
            except Exception:
                pass

        # start timers
        def _t3_on_resize(evt=None):
            try:
                w = max(60, self.box.winfo_width()); h = max(60, self.box.winfo_height())
                _draw_inset_sand(self.bg_canvas, w, h, radius=16, blur=16, edge=10, depth=80)
                self.bg_canvas.lower(); self.content.lift()
            except Exception:
                pass
        self.box.bind('<Configure>', _on_resize)
        self.after(300, self._tick)
        try:
            self.update_profile_badge()
        except Exception:
            pass
        self.after(0, self._netcheck)
        
    def _fetch_from_firebase(self):
        """Fetch ALL users from Firebase (active and inactive)"""
        try:
            print("[FIREBASE-FETCH] Connecting to Firebase...")
            ref = db.reference('leaderboard')
            print("[FIREBASE-FETCH] Getting all users...")
            
            # Get ALL users - no filtering
            data = ref.get()
            
            print(f"[FIREBASE-FETCH] Data received: {len(data) if data else 0} users")
            
            if not data:
                print("[FIREBASE-FETCH] No data in Firebase")
                return []
            
            result = []
            for uid, user in data.items():
                name = user.get('name', 'Unknown')
                week_hours = user.get('weekHours', 0)
                status = user.get('status', 'Offline')
                avatar_id = user.get('avatarId', '1')
                user_uid = user.get('uid', uid)
                active = user.get('active', True)  # Get active status
                
                # Convert to HH:MM:SS
                total_seconds = int(week_hours * 3600)
                hours = total_seconds // 3600
                minutes = (total_seconds % 3600) // 60
                seconds = total_seconds % 60
                time_hhmmss = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
                
                try:
                    aid = int(avatar_id)
                except:
                    aid = 1
                
                # If inactive, force status to Offline (will be shown grey)
                if not active:
                    status = "Offline"
                
                result.append((name, time_hhmmss, status, "", "", aid, user_uid))
            
            print(f"[FIREBASE-FETCH] Processed {len(result)} total users")
            
            # Sort by time descending
            def time_to_seconds(time_str):
                try:
                    parts = time_str.split(":")
                    return int(parts[0]) * 3600 + int(parts[1]) * 60 + int(parts[2])
                except:
                    return 0
            
            result.sort(key=lambda x: time_to_seconds(x[1]), reverse=True)
            
            if result:
                print(f"[FIREBASE-FETCH] Top user: {result[0][0]} with {result[0][1]}")
            
            return result
            
        except Exception as e:
            print(f"[FIREBASE-FETCH-ERROR] {e}")
            import traceback
            traceback.print_exc()
            return []
        
    def update_online_count(self):
        """Update online count in real-time"""
        try:
            if not self._net_ok or not self._all_data:
                return
            
            online_count = 0
            for item in self._all_data:
                if len(item) >= 3 and item[2] == "Online":
                    online_count += 1
            
            # Get current total
            total_rows = len(self._all_data)
            
            # Update the bottom label
            if online_count > 0:
                reset_text = f"will be reseted every Sunday 11:59 PM ‚Ä¢ Total entries {total_rows} ‚Ä¢  Online ({online_count})"
            else:
                reset_text = f"will be reseted every Sunday 11:59 PM ‚Ä¢ Total entries {total_rows}"
            
            self.reset_hint_lbl.configure(text=reset_text)
            
        except Exception:
            pass
    
    
        
    # ========== VIRTUAL SCROLLING METHODS ==========
    def _prerender_rows(self, start_idx, end_idx):
        """Pre-render row data to cache for smooth scrolling with image caching."""
        if not self._all_data:
            return
            
        end_idx = min(end_idx, len(self._all_data))
        
        for i in range(start_idx, end_idx):
            if i in self._rendered_cache:
                continue  # Already cached
                
            if i >= len(self._all_data):
                break
                
            item = self._all_data[i]
            actual_rank = i + 1
            
            # Pre-process all the expensive operations safely
            if len(item) >= 6:
                name, hours_decimal, status, th, tt, avatar_id, *rest = item
            else:
                name, hours_decimal, status, th, tt = item
                avatar_id = 0
                
            # Convert decimal hours to seconds, then to HH:MM display
            total_seconds = self._time_to_seconds(str(hours_decimal))
            time_display = self._seconds_to_time_display(total_seconds)
            
            # Determine online/offline status considering internet connectivity
            is_online = (status == "Online") and self._net_ok
            is_greyed = not is_online
            
            # Use image cache for expensive operations
            cache_key = f"{name}{avatar_id}{actual_rank}{is_online}{self._net_ok}"
            
            if cache_key in self._image_cache:
                img = self._image_cache[cache_key]
            else:
                # Pre-load medal and avatar (expensive operations)
                medal_img = getattr(self, 'medal_icons', {}).get(actual_rank, None)
                av_path = self._avatar_for(name, int(avatar_id) if avatar_id else 0)
                
                # Pre-render nameplate (most expensive operation)
                img = _nameplate_with_medal(
                    name, av_path, medal_img, size=18,
                    spacing_av_text=6, spacing_text_medal=6,
                    online=is_online,
                    greyed=is_greyed
                )
                
                # Cache the image (limit cache size)
                if len(self._image_cache) < 1000:  # Prevent memory bloat
                    self._image_cache[cache_key] = img
            
            # Cache the processed data
            self._rendered_cache[i] = {
                'name': name,
                'rank': actual_rank,
                'time_str': time_display,
                'status': status,
                'image': img,
                'tags': ("offlinegrey",) if is_greyed else ()
            }
        
        self._cache_range = (start_idx, end_idx)
        
    def _netcheck(self):
        """Network check method that was being called but missing"""
        try:
            self._net_ok = _internet()
            self._set_title()
            self._render(self._last_disp)
            try:
                self.content.lift()
                self.title_lbl.lift()
                self.you_rank_lbl.lift()
                self.reset_hint_lbl.lift()  # Ensure bottom text is always visible
            except Exception:
                pass
        finally:
            self.after(30000, self._netcheck)
    
    def _on_virtual_scroll(self, *args):
        """Handle virtual scrolling with pre-rendered cache."""
        if not self._all_data:
            return
            
        if args[0] == "moveto":
            # Direct position (0.0 to 1.0)
            fraction = float(args[1])
            total_rows = len(self._all_data)
            new_start = int(fraction * max(0, total_rows - self.show_rows))
            new_start = max(0, min(new_start, total_rows - 1))
            
        elif args[0] == "scroll":
            # Relative scroll (number, "units" or "pages")
            delta = int(args[1])
            if args[2] == "pages":
                delta *= self.show_rows
            new_start = self._visible_start + delta
            new_start = max(0, min(new_start, len(self._all_data) - 1))
        else:
            return
            
        if new_start != self._visible_start:
            self._visible_start = new_start
            
            # Check if we need to expand cache
            cache_start, cache_end = self._cache_range
            visible_end = new_start + self._visible_count
            
            # If scrolling outside cache range, pre-render more
            if new_start < cache_start or visible_end > cache_end:
                # Expand cache in scroll direction
                buffer_size = self._prerender_size // 2
                cache_new_start = max(0, new_start - buffer_size)
                cache_new_end = min(len(self._all_data), new_start + self._prerender_size)
                
                # Pre-render in background (non-blocking)
                self.after_idle(self._prerender_rows, cache_new_start, cache_new_end)
            
            self._render_visible_rows_cached()
            self._update_virtual_scrollbar()
    
    def _on_mousewheel(self, event):
        """Handle mouse wheel for virtual scrolling with smooth pre-rendering."""
        if not self._all_data:
            return
            
        # Calculate scroll direction and amount
        if event.num == 4 or event.delta > 0:
            delta = -2  # Scroll up (reduced for smoother feel)
        elif event.num == 5 or event.delta < 0:
            delta = 2   # Scroll down (reduced for smoother feel)
        else:
            delta = -int(event.delta / 60)  # Windows/Mac (smaller steps)
            
        new_start = max(0, min(self._visible_start + delta, 
                              len(self._all_data) - self.show_rows))
        
        if new_start != self._visible_start:
            self._visible_start = new_start
            
            # Pre-render ahead in scroll direction
            if delta > 0:  # Scrolling down
                prerender_start = new_start
                prerender_end = min(len(self._all_data), new_start + self._prerender_size)
            else:  # Scrolling up
                prerender_start = max(0, new_start - self._prerender_size // 2)
                prerender_end = new_start + self._visible_count
            
            # Pre-render in background if needed
            cache_start, cache_end = self._cache_range
            if prerender_start < cache_start or prerender_end > cache_end:
                self.after_idle(self._prerender_rows, prerender_start, prerender_end)
            
            self._render_visible_rows_cached()
            self._update_virtual_scrollbar()
            
        return "break"  # Prevent default scrolling
        
    def _update_virtual_scrollbar(self):
        """Update virtual scrollbar position based on current view."""
        if not self._all_data:
            self.v_scrollbar.set(0.0, 1.0)
            self._v_scrollbar_needed = False
        else:
            total_rows = len(self._all_data)
            visible_rows = min(self.show_rows, total_rows)
            
            if total_rows <= self.show_rows:
                # No scrolling needed
                self.v_scrollbar.set(0.0, 1.0)
                self._v_scrollbar_needed = False
            else:
                # Calculate scrollbar position
                top = self._visible_start / total_rows
                bottom = min(1.0, (self._visible_start + visible_rows) / total_rows)
                self.v_scrollbar.set(top, bottom)
                self._v_scrollbar_needed = True
        
        self._update_scrollbar_visibility()
    
    def _render_visible_rows_cached(self):
        """Render visible rows using pre-rendered cache for instant performance."""
        # Clear existing items
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.avatar_refs = []
        
        if not self._all_data:
            return
            
        # Calculate visible range
        start_idx = self._visible_start
        end_idx = min(start_idx + self._visible_count, len(self._all_data))
        
        # Render from cache if available, otherwise render directly
        for i in range(start_idx, end_idx):
            if i >= len(self._all_data):
                break
            
            if i in self._rendered_cache:
                # Use cached data (instant!)
                cached = self._rendered_cache[i]
                kwargs = {
                    "text": "", 
                    "values": (cached['rank'], cached['time_str'], cached['status'])
                }
                if cached['image'] is not None:
                    kwargs["image"] = cached['image']
                
                self.tree.insert("", "end", tags=cached['tags'], **kwargs)
                self.avatar_refs.append(cached['image'])
            else:
                # Fallback: render directly (should be rare with good pre-rendering)
                self._render_single_row(i)
    
    def _render_single_row(self, i):
        """Render a single row directly (fallback when not cached)."""
        item = self._all_data[i]
        actual_rank = i + 1
        
        if len(item) == 7:
            name, time_value, status, th, tt, avatar_id, uid = item
        elif len(item) == 6:
            name, time_value, status, th, tt, avatar_id = item
            uid = ""
        else:
            name, time_value, status, th, tt = item
            avatar_id = 0
            uid = ""
            
        # Handle both HH:MM format (preferred) and decimal hours (fallback)
        if ":" in str(time_value):
            # Already in HH:MM format - use directly
            time_display = str(time_value)
            total_seconds = self._time_to_seconds(time_value)
        else:
            # Convert decimal hours to HH:MM display
            total_seconds = self._time_to_seconds(str(time_value))
            time_display = self._seconds_to_time_display(total_seconds)
        
        # Debug output for fallback rendering
        print(f"[DEBUG] Fallback Row {i+1}: {name} (UID: {uid}) -> Raw: {time_value} -> Seconds: {total_seconds} -> Display: {time_display}")

        medal_img = getattr(self, 'medal_icons', {}).get(actual_rank, None)
        av_path = self._avatar_for(name, int(avatar_id) if avatar_id else 0)

        # Determine online/offline status considering internet connectivity
        is_online = (status == "Online") and self._net_ok
        is_greyed = not is_online

        img = _nameplate_with_medal(
            name, av_path, medal_img, size=18,
            spacing_av_text=6, spacing_text_medal=6,
            online=is_online,
            greyed=is_greyed
        )
        
        kwargs = {"text": "", "values": (actual_rank, time_display, status)}
        if img is not None:
            kwargs["image"] = img
            
        tags = ("offlinegrey",) if is_greyed else ()
        self.tree.insert("", "end", tags=tags, **kwargs)
        self.avatar_refs.append(img)
    
    # ========== MOUSE HOVER EVENTS FOR SCROLLBARS ==========
    def _bind_hover_events(self):
        """Bind mouse enter/leave events to all relevant widgets including scrollbars."""
        # All widgets that should keep scrollbars visible when hovered
        widgets_to_bind = [
            self.tree_frame, 
            self.tree, 
            self.header, 
            self.v_scrollbar, 
            self.h_scrollbar
        ]
        
        for widget in widgets_to_bind:
            widget.bind("<Enter>", self._on_mouse_enter, add="+")
            widget.bind("<Leave>", self._on_mouse_leave, add="+")
    
    def _on_mouse_enter(self, event=None):
        """Show scrollbars when mouse enters the tree area or scrollbars."""
        # Cancel any pending hide timer
        if self._hide_timer:
            self.after_cancel(self._hide_timer)
            self._hide_timer = None
            
        self._mouse_in_tree_area = True
        self._update_scrollbar_visibility()
    
    def _on_mouse_leave(self, event=None):
        """Schedule hiding scrollbars when mouse leaves, with small delay to prevent flickering."""
        # Use a small delay to prevent flickering when moving between related widgets
        if self._hide_timer:
            self.after_cancel(self._hide_timer)
        
        self._hide_timer = self.after(100, self._delayed_mouse_leave)
    
    def _delayed_mouse_leave(self):
        """Actually hide scrollbars after delay."""
        self._hide_timer = None
        
        # Check if mouse is actually outside the entire scrollable area
        try:
            x, y = self.winfo_pointerxy()
            root_x = self.winfo_rootx()
            root_y = self.winfo_rooty()
            
            # Convert to relative coordinates
            rel_x = x - root_x
            rel_y = y - root_y
            
            # Check if mouse is still within the tree frame bounds
            tf_x = self.tree_frame.winfo_x()
            tf_y = self.tree_frame.winfo_y() 
            tf_w = self.tree_frame.winfo_width()
            tf_h = self.tree_frame.winfo_height()
            
            # Add small margin for scrollbars
            margin = 15
            if (tf_x - margin <= rel_x <= tf_x + tf_w + margin and 
                tf_y - margin <= rel_y <= tf_y + tf_h + margin):
                return  # Still in area, don't hide
                
        except Exception:
            pass
        
        self._mouse_in_tree_area = False
        self._update_scrollbar_visibility()
    
    def _update_scrollbar_visibility(self):
        """Update scrollbar visibility based on mouse position and scroll needs."""
        try:
            # Show scrollbars only when mouse is in area AND scrolling is needed
            show_v = self._mouse_in_tree_area and self._v_scrollbar_needed
            show_h = self._mouse_in_tree_area and self._h_scrollbar_needed
            
            # Update vertical scrollbar
            if show_v and not self._v_scrollbar_visible:
                self.v_scrollbar.grid(row=0, column=1, sticky="ns", padx=(1, 1))
                self._v_scrollbar_visible = True
            elif not show_v and self._v_scrollbar_visible:
                self.v_scrollbar.grid_remove()
                self._v_scrollbar_visible = False
            
            # Update horizontal scrollbar  
            if show_h and not self._h_scrollbar_visible:
                self.h_scrollbar.grid(row=1, column=0, sticky="ew", pady=(1, 1))
                self._h_scrollbar_visible = True
            elif not show_h and self._h_scrollbar_visible:
                self.h_scrollbar.grid_remove()
                self._h_scrollbar_visible = False
                
        except Exception:
            pass

    # ========== STANDARD SCROLLBAR METHODS ==========
    def _on_h_scroll(self, *args):
        """Handle horizontal scrollbar updates and track scroll needs."""
        # Update scrollbar position
        self.h_scrollbar.set(*args)
        
        # Track if scrolling is needed
        try:
            left, right = float(args[0]), float(args[1])
            self._h_scrollbar_needed = not (left == 0.0 and right == 1.0)
        except Exception:
            self._h_scrollbar_needed = False
        
        # Update visibility based on current state
        self._update_scrollbar_visibility()
        
    def _time_to_seconds(self, time_str: str) -> int:
        """Parse 'HH:MM[:SS]' or decimal hours into seconds."""
        try:
            s = (time_str or "").strip()
            if not s:
                return 0
            
            if ":" in s:
                # Handle HH:MM or HH:MM:SS format (preferred format from writer)
                parts = [int(p) for p in s.split(":")]
                if len(parts) == 3:
                    h, m, sec = parts
                    return h*3600 + m*60 + sec
                if len(parts) == 2:
                    h, m = parts
                    return h*3600 + m*60
            else:
                # Fallback: Handle decimal hours (e.g., '1.93' = 1.93 hours = 1h 55.8mins)
                decimal_hours = float(s)
                total_seconds = int(decimal_hours * 3600)  # Convert decimal hours to seconds
                return total_seconds
        except Exception:
            return 0

    def _seconds_to_time_display(self, total_seconds: int) -> str:
        try:
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            return f"{hours:02d}:{minutes:02d}:{seconds:02d}"  # HH:MM:SS
        except Exception:
            return "00:00:00"

    def _update_you_rank_badge(self, disp_rows) -> None:
        """
        Calculate user rank based on time sorting (highest time = rank 1).
        Uses UID if available, falls back to name matching.
        disp_rows is the full list returned by _fetch(); each row like:
        (name, time_value_hhmm_or_decimal, status, th, tt, avatar_id, uid)
        """
        try:
            app = self.winfo_toplevel()
            my_uid = (getattr(app, "user_uid", "") or "").strip()
            my_name = (getattr(app, "user_name", "") or "").strip().lower()
            
            print(f"[YOU-RANK] Looking for: UID='{my_uid}', Name='{my_name}'")
            print(f"[YOU-RANK] Total rows to search: {len(disp_rows)}")
            
            if not my_uid and not my_name:
                self.you_rank_lbl.config(text=" you(-)")
                return

            # Build list of (time_seconds, uid, name, original_index) for accurate ranking
            entries_with_time = []
            for idx, it in enumerate(disp_rows or []):
                if not it or len(it) < 7:
                    continue
                name = str(it[0]).strip()
                time_value = it[1]
                uid = str(it[6]).strip()  # Get UID from 7th element (index 6)
                
                # Convert time to seconds for accurate comparison
                secs = self._time_to_seconds(str(time_value))
                entries_with_time.append((secs, uid, name.lower(), idx))

            if not entries_with_time:
                self.you_rank_lbl.config(text=" you(-)")
                return

            # Sort by time in descending order (highest time = rank 1)
            entries_with_time.sort(key=lambda x: x[0], reverse=True)
            
            # Find user's rank in sorted list
            rank = None
            
            # First try UID matching (more accurate)
            if my_uid:
                for rank_pos, (_, uid, name, _) in enumerate(entries_with_time, 1):
                    if uid == my_uid:
                        rank = rank_pos
                        break
            
            # Fallback to name matching if UID didn't work
            if not rank and my_name:
                for rank_pos, (_, uid, name, _) in enumerate(entries_with_time, 1):
                    if name == my_name:
                        rank = rank_pos
                        break

            self.you_rank_lbl.config(text=f" you({rank})" if rank else " you(-)")
        except Exception:
            self.you_rank_lbl.config(text=" you(-)")

    def _set_title(self):
        try:
            # Prevent flickering by checking if update is actually needed
            current_net_status = self._net_ok
            total_rows = len(self._all_data)
            
            # Count online members
            online_count = 0
            if self._all_data and self._net_ok:
                for item in self._all_data:
                    # item format: (name, time_value, status, th, tt, avatar_id)
                    if len(item) >= 3 and item[2] == "Online":
                        online_count += 1
            
            # Only update if status or count changed
            if not hasattr(self, '_last_net_status'):
                self._last_net_status = None
            if not hasattr(self, '_last_total_rows'):
                self._last_total_rows = None
            if not hasattr(self, '_last_online_count'):
                self._last_online_count = None
                
            if (current_net_status == self._last_net_status and 
                total_rows == self._last_total_rows and
                online_count == self._last_online_count):
                return  # No change needed, prevent flicker
                
            self._last_net_status = current_net_status
            self._last_total_rows = total_rows
            self._last_online_count = online_count
            
            if self._net_ok:
                txt = f"{self.title_base} ‚Äî updates every 5 minutes"
                fg = "#3c4350"
                # Show user rank only when online
                if hasattr(self, "you_rank_lbl"):
                    try:
                        self.you_rank_lbl.place(x=200, y=8)  # Make visible
                    except Exception:
                        pass
            else:
                txt = f"{self.title_base} ‚Äî connect internet to see live update"
                fg = "#666666"
                # Hide user rank when offline
                if hasattr(self, "you_rank_lbl"):
                    try:
                        self.you_rank_lbl.place_forget()  # Hide completely
                    except Exception:
                        pass

            self.title_lbl.configure(text=txt, fg=fg)

            # Update reset hint with total entries AND online count
            if self._net_ok and online_count > 0:
                reset_text = f"will be reseted every Sunday 11:59 PM ‚Ä¢ Total entries {total_rows}  Online ({online_count})"
            else:
                reset_text = f"will be reseted every Sunday 11:59 PM ‚Ä¢ Total entries {total_rows}"
            
            self.reset_hint_lbl.configure(text=reset_text)

            # Position you(x) label when visible
            if self._net_ok and hasattr(self, "you_rank_lbl"):
                try:
                    self.you_rank_lbl.configure(fg="#000000")
                    self.box.update_idletasks()
                    x = 14 + self.title_lbl.winfo_width() + 6
                    self.you_rank_lbl.place_configure(x=x, y=8)
                except Exception:
                    pass
        except Exception as e:
            print(f"[LEADERBOARD] Error updating title: {e}")
            pass

    def _tick(self):
        import time
        try:
            print(f"[DEBUG] _tick called at {time.strftime('%H:%M:%S')} (poll_ms={self.poll_ms})")

            if _internet():
                disp = self._fetch_from_firebase()
                
                if disp:
                    print(f"[LEADERBOARD] Successfully fetched {len(disp)} entries")
                    # Debug: Show first few entries
                    for i, entry in enumerate(disp[:3]):
                        if len(entry) >= 3:
                            print(f"[LEADERBOARD] Entry {i+1}: {entry[0]} -> Time: '{entry[1]}' -> Status: '{entry[2]}'")
                else:
                    print("[LEADERBOARD] No data returned")
                
                self._last_disp = disp
                self._net_ok = True
                self._set_title()
                self._render(disp)
            else:
                print("[LEADERBOARD] No internet connection")
                self._net_ok = False
                self._set_title()
                self._render(self._last_disp)

        except Exception as e:
            print(f"[LEADERBOARD] _tick error: {e}")
            import traceback
            traceback.print_exc()
            self._net_ok = False
            self._set_title()
            self._render(self._last_disp)

        finally:
            print(f"[DEBUG] Scheduling next tick in {self.poll_ms/1000:.1f}s")
            self.winfo_toplevel().after(self.poll_ms, self._tick)

    def _avatar_for(self, name: str, avatar_id: int | None):
        """Use exact Avatar ID if present; otherwise pick a stable avatar from name hash."""
        # try explicit avatarX.ext first
        if avatar_id and isinstance(avatar_id, int) and avatar_id > 0:
            for ext in (".png", ".jpg", ".jpeg", ".webp", ".gif"):
                p = os.path.join(self.avatars_folder, f"avatar{avatar_id}{ext}")
                if os.path.isfile(p):
                    return p
        # fallback: stable, per-name choice from the available pool
        if self.avatar_files:
            idx = (avatar_id - 1) % len(self.avatar_files) if (avatar_id and avatar_id > 0) \
                  else (abs(hash(name)) % len(self.avatar_files))
            return self.avatar_files[idx]
        return None
        
    def _render(self, disp):
        """Main render method with proper refresh handling and optimized visible-only updates."""
        import time
        current_time = time.time()
        
        # Store complete dataset for virtual scrolling
        old_data_len = len(self._all_data) if self._all_data else 0
        old_net_status = getattr(self, '_last_net_ok', None)
        old_data_hash = getattr(self, '_last_data_hash', None)
        
        self._all_data = disp or []
        
        # Create hash of FULL data to detect actual changes
        import hashlib
        import json

        # Hash the first 100 users to detect changes
        rows_for_hash = self._all_data[:100]
        data_str = json.dumps([(item[0], item[1], item[2]) for item in rows_for_hash], sort_keys=True)
        current_data_hash = hashlib.md5(data_str.encode()).hexdigest()

        # ‚úÖ Also include UID user row if it‚Äôs outside top 20
        try:
            uid_name = _load_profile().get("user_name", "").strip().lower()
            for row in self._all_data:
                if len(row) >= 1 and str(row[0]).strip().lower() == uid_name:
                    if row not in rows_for_hash:
                        rows_for_hash.append(row)
                    break
        except Exception as e:
            print(f"[DEBUG] UID row hash check failed: {e}")

        data_str = str([(item[0], item[1], item[2]) for item in rows_for_hash])
        current_data_hash = hashlib.md5(data_str.encode()).hexdigest()
        
        # Force cache clear when internet status changes or data actually changes
        data_changed = current_data_hash != old_data_hash
        net_status_changed = old_net_status != self._net_ok
        
        if data_changed or net_status_changed:
            # Clear all caches to force complete re-render with fresh data
            self._rendered_cache.clear()
            self._cache_range = (0, 0)
            
            # Clear image cache when network status changes (affects greying)
            if net_status_changed:
                self._image_cache.clear()
            elif len(self._image_cache) > 2000:
                # Clear oldest entries (simple FIFO) only if data changed
                keys_to_remove = list(self._image_cache.keys())[:1000]
                for key in keys_to_remove:
                    del self._image_cache[key]
            
            print(f"[DEBUG] Data or network changed - clearing cache. Data changed: {data_changed}, Net changed: {net_status_changed}")
        
        self._last_net_ok = self._net_ok
        self._last_data_hash = current_data_hash
        
        # Reset scroll position if data changed significantly
        if len(self._all_data) < self._visible_start:
            self._visible_start = 0
        
        # Always re-render visible rows when data changes or on fresh calls
        if data_changed or net_status_changed or not hasattr(self, '_last_render_time') or (current_time - getattr(self, '_last_render_time', 0)) > 30:
            self._render_visible_rows_cached()
            self._last_render_time = current_time
            print(f"[DEBUG] Re-rendered visible rows - Data entries: {len(self._all_data)}")
            
            # Debug: Show what data we're working with for first few rows
            for i, item in enumerate(self._all_data[:3]):
                if len(item) >= 3:
                    print(f"[DEBUG] Data Row {i+1}: Name='{item[0]}', Time='{item[1]}', Status='{item[2]}'")
        
        # Update scrollbar
        self._update_virtual_scrollbar()
        
        # Update user rank badge using full dataset (only when online)
        if self._net_ok and self._all_data:
            self._update_you_rank_badge(self._all_data)
        
        # Set title (with flicker prevention)
        self._set_title()
        
        # Start pre-rendering for smooth scrolling (after main render)
        if self._all_data and (data_changed or not hasattr(self, '_prerender_done')):
            initial_prerender_size = min(self._prerender_size, len(self._all_data))
            self.after_idle(self._prerender_rows, 0, initial_prerender_size)
            self._prerender_done = True
        self.update_online_count()
        
class Top3Panel(ttk.Frame):
    """
    Static Top-3 panel ‚Äî shows last week's top 3 until next Sunday 11:59 PM.
    Reads data from Firebase Realtime Database.
    """
    def __init__(self, parent, firebase_sync, width=240, height=240, 
                 avatars_folder=app_paths.avatars_dir, title_text=None):
        super().__init__(parent)
        self.title_base = "Last Week Top Rankers"
        self.firebase_sync = firebase_sync  # Pass FirebaseSync instance
        self.avatars_folder = avatars_folder
        self.avatar_files = _load_avatars(avatars_folder)
        self.avatar_refs = []
        self.medal_refs = []
        self._last_disp = []
        self._net_ok = True
        self._current_display_data = []

        self.box = tk.Frame(self, bg="#ffffff", bd=0, highlightthickness=0)
        self.box.pack(fill="both", expand=True)
        self.bg_canvas = tk.Canvas(self.box, bg="#ffffff", bd=0, highlightthickness=0)
        self.bg_canvas.pack(fill="both", expand=True)
        self.content = tk.Frame(self.box, bg="#ffffff", bd=0, highlightthickness=0)
        self.content.place(relx=0, rely=0, relwidth=1, relheight=1)

        try:
            self.bg_canvas.lower()
            self.content.lift()
        except Exception:
            pass

        self.t3_title = tk.Label(self.content, text=self.title_base,
                         font=("Segoe UI", 12, "bold"),
                         bg="#ffffff", fg="#3CB043")
        self.t3_title.pack(side="top", anchor="w", padx=10, pady=(10, 4))

        self.medal_icons = self._load_medal_icons()
        self.rows = []
        
        for i in range(3):
            row = tk.Frame(self.content, bg="#ffffff")
            bottom_pad = 8 if i == 2 else 3
            row.pack(fill="x", padx=10, pady=(3, bottom_pad))

            avatar = tk.Label(row, bg="#ffffff", bd=0, highlightthickness=0)
            avatar.grid(row=0, column=0, rowspan=2, padx=(0, 8), sticky="w")

            name_lbl = tk.Label(row, text=f"#{i+1}  ‚Äî",
                               font=("Segoe UI", 10, "bold"),
                               bg="#ffffff", fg="#000000")
            name_lbl.grid(row=0, column=1, sticky="w")

            duration_lbl = tk.Label(row, text="",
                                   font=("Segoe UI", 10),
                                   bg="#ffffff", fg="#000000")
            duration_lbl.grid(row=0, column=2, sticky="w", padx=(4, 0))

            medal_label = tk.Label(row, bg="#ffffff", bd=0, highlightthickness=0)
            medal_label.grid(row=0, column=3, padx=(5, 0), sticky="w")

            time_lbl = tk.Label(row, text="",
                               font=("Segoe UI", 9),
                               bg="#ffffff", fg="#666666")
            time_lbl.grid(row=1, column=1, columnspan=3, sticky="w")

            bar_canvas = tk.Canvas(row, height=0, bg="#ffffff", bd=0, highlightthickness=0)

            self.rows.append({
                "avatar": avatar,
                "name": name_lbl,
                "duration": duration_lbl,
                "medal": medal_label,
                "time": time_lbl,
                "bar_canvas": bar_canvas,
                "track_id": None,
                "bar_id": None,
                "raw_name": "‚Äî",
            })    

        def _on_resize(evt=None):
            try:
                w = max(60, self.box.winfo_width())
                h = max(60, self.box.winfo_height())
                _draw_inset_sand(self.bg_canvas, w, h, radius=16, blur=16, edge=10, depth=80)
                self.bg_canvas.lower()
                self.content.lift()
            except Exception:
                pass
        
        self.box.bind("<Configure>", _on_resize)

        # Load and display last week's data
        self._load_and_display_last_week()
        self._schedule_weekly_refresh()
        self._check_internet_connection()

    def _load_and_display_from_firebase(self):
        """Load last week's top 3 from Firebase"""
        try:
            last_week_data = self.firebase_sync.get_last_week_top3()
            
            if last_week_data:
                # Convert Firebase data to display format
                converted_data = []
                for user in last_week_data:
                    converted_data.append((
                        user.get('name', ''),
                        user.get('weekHours', 0),
                        'Offline',  # Default status for historical data
                        0, 0,  # placeholders
                        user.get('avatar_id', 1)
                    ))
                
                self._current_display_data = converted_data
                self._render(converted_data)
                print(f"[TOP3] Loaded {len(converted_data)} last week rankers from Firebase")
            else:
                print("[TOP3] No last week data found in Firebase")
                self._render([])
                
        except Exception as e:
            print(f"[TOP3] Error loading from Firebase: {e}")
            import traceback
            traceback.print_exc()
            self._render([])

    def _load_medal_icons(self):
        """Load medal icons with bigger size (24x24)"""
        try:
            from PIL import Image, ImageTk
            
            medal_icons = {}
            medal_files = {1: "gold_medal", 2: "silver_medal", 3: "bronze_medal"}
            
            possible_paths = [
                "app/medals",
                app_paths.medals_dir,
                "./app/medals", 
                "./medals"
            ]
            
            medals_folder = None
            for path in possible_paths:
                if os.path.exists(path):
                    medals_folder = path
                    print(f"[MEDALS] Found medals folder at: {path}")
                    break
            
            if not medals_folder:
                print("[MEDALS] No medals folder found, using emoji fallback")
                return {}
            
            for rank, filename in medal_files.items():
                medal_path = None
                
                for ext in [".png", ".jpg", ".jpeg", ".webp", ".gif"]:
                    potential_path = os.path.join(medals_folder, f"{filename}{ext}")
                    if os.path.isfile(potential_path):
                        medal_path = potential_path
                        break
                
                if medal_path:
                    try:
                        img = Image.open(medal_path).convert("RGBA")
                        img = img.resize((24, 24), Image.Resampling.LANCZOS)
                        medal_icons[rank] = img
                        print(f"[MEDALS] Loaded medal {rank} at 24x24")
                    except Exception as e:
                        print(f"[MEDALS] Failed to load {medal_path}: {e}")
            
            return medal_icons
            
        except ImportError:
            print("[MEDALS] PIL not available, using emoji fallback")
            return {}
        except Exception as e:
            print(f"[MEDALS] Medal loading failed: {e}")
            return {}

    def _is_sunday_night_reset(self):
        """Check if it's Sunday 11:59 PM for weekly reset"""
        import datetime
        now = datetime.datetime.now()
        return (now.weekday() == 6 and now.hour == 23 and now.minute == 59)

    def _seconds_until_next_sunday(self):
        """Calculate seconds until next Sunday 11:59 PM"""
        import datetime
        now = datetime.datetime.now()
        days_ahead = (6 - now.weekday()) % 7
        next_sun = now + datetime.timedelta(days=days_ahead)
        target = next_sun.replace(hour=23, minute=59, second=0, microsecond=0)
        if target <= now:
            target += datetime.timedelta(days=7)
        return int((target - now).total_seconds())

    def _check_internet_connection(self):
        """Check internet connection and update display accordingly"""
        try:
            import socket
            socket.create_connection(("8.8.8.8", 53), timeout=3)
            new_status = True
        except Exception:
            new_status = False
        
        if new_status != self._net_ok:
            self._net_ok = new_status
            print(f"[TOP3] Internet status changed: {'Connected' if self._net_ok else 'Disconnected'}")
            if hasattr(self, '_current_display_data') and self._current_display_data:
                self._render(self._current_display_data)
        
        self.after(30000, self._check_internet_connection)

    def force_offline_test(self):
        """Test method to force offline mode"""
        self._net_ok = False
        print("[TOP3] FORCED OFFLINE MODE")
        if hasattr(self, '_current_display_data') and self._current_display_data:
            self._render(self._current_display_data)
    
    def force_online_test(self):
        """Test method to force online mode"""
        self._net_ok = True
        print("[TOP3] FORCED ONLINE MODE")
        if hasattr(self, '_current_display_data') and self._current_display_data:
            self._render(self._current_display_data)

    def _load_and_display_last_week(self):
        """Load and display from Firebase"""
        self._load_and_display_from_firebase()

    def _schedule_weekly_refresh(self):
        """Schedule periodic refresh intelligently"""
        import datetime
        
        now = datetime.datetime.now()
        
        # If it's Sunday evening (after 11 PM), check every 5 minutes
        if now.weekday() == 6 and now.hour >= 23:
            refresh_ms = 300000  # 5 minutes
        # If it's Monday (day after reset), check once
        elif now.weekday() == 0:
            refresh_ms = 3600000  # 1 hour
        # Rest of the week, check once per day
        else:
            refresh_ms = 86400000  # 24 hours
        
        self._load_and_display_from_firebase()
        self.after(refresh_ms, self._schedule_weekly_refresh)

    def _avatar_for(self, name: str, avatar_id: int | None):
        """Get avatar path for user"""
        if avatar_id and isinstance(avatar_id, int) and avatar_id > 0:
            for ext in (".png", ".jpg", ".jpeg", ".webp", ".gif"):
                p = os.path.join(self.avatars_folder, f"avatar{avatar_id}{ext}")
                if os.path.isfile(p):
                    return p
        if self.avatar_files:
            idx = (avatar_id - 1) % len(self.avatar_files) if (avatar_id and avatar_id > 0) \
                  else (abs(hash(name)) % len(self.avatar_files))
            return self.avatar_files[idx]
        return None

    def _circle(self, path, size=22, greyed=False):
        """Create circular avatar image with optional grey effect"""
        try:
            from PIL import Image, ImageTk, ImageDraw
            
            try:
                img = Image.open(path).convert("RGBA").resize((size, size))
            except Exception:
                img = Image.new("RGBA", (size, size), (200, 200, 200, 255))
            
            if greyed:
                r, g, b, a = img.split()
                grey = Image.merge("RGB", (r, r, r)).convert("L")
                img = Image.merge("RGBA", (grey, grey, grey, a))
            
            mask = Image.new("L", (size, size), 0)
            d = ImageDraw.Draw(mask)
            d.ellipse((0, 0, size, size), fill=255)
            
            canvas = Image.new("RGBA", (size + 10, size + 10), (0, 0, 0, 0))
            canvas.paste(img, (0, 0), mask)
            
            return ImageTk.PhotoImage(canvas)
            
        except ImportError:
            return None
        except Exception as e:
            print(f"Error creating circular image: {e}")
            return None

    def _render(self, disp):
        """Render the last week's top 3"""
        top3 = disp[:3] if disp else []
        self.avatar_refs = []
        self.medal_refs = []
        self._current_display_data = disp
        is_greyed = not self._net_ok

        for i in range(3):
            slot = self.rows[i]
            rank = i + 1

            if i < len(top3):
                item = top3[i]
                if len(item) == 6:
                    name, time_value, status, th, tt, avatar_id = item
                else:
                    name, time_value, status, th, tt = item
                    avatar_id = 0

                try:
                    if ":" in str(time_value):
                        parts = str(time_value).split(":")
                        hours = int(parts[0])
                        minutes = int(parts[1])
                        total_minutes = hours * 60 + minutes
                    else:
                        total_minutes = int(float(time_value) * 60)

                    hh = total_minutes // 60
                    mm = total_minutes % 60
                except:
                    hh = 0
                    mm = 0

                display_name = name or "‚Äî"
                duration_text = f"{hh:02d}:{mm:02d}"

                name_color = "#6b6b6b" if is_greyed else "#000000"
                slot["name"].configure(text=f"#{rank}  {display_name}", fg=name_color)
                slot["duration"].configure(text=f"- {duration_text}", fg=name_color)

                if rank in self.medal_icons:
                    try:
                        from PIL import ImageTk, Image
                        medal_img = self.medal_icons[rank].copy()

                        if is_greyed:
                            r, g, b, a = medal_img.split()
                            grey = Image.merge("RGB", (r, r, r)).convert("L")
                            medal_img = Image.merge("RGBA", (grey, grey, grey, a))

                        medal_photo = ImageTk.PhotoImage(medal_img)
                        slot["medal"].configure(image=medal_photo)
                        slot["medal"].image = medal_photo
                        self.medal_refs.append(medal_photo)
                    except Exception as e:
                        print(f"Failed to set medal image for rank {rank}: {e}")
                        fallback_medals = ["ü•á", "ü•à", "ü•â"]
                        medal_color = "#6b6b6b" if is_greyed else "#000000"
                        slot["medal"].configure(text=fallback_medals[i],
                                               font=("Segoe UI", 12), fg=medal_color)
                else:
                    fallback_medals = ["ü•á", "ü•à", "ü•â"]
                    medal_color = "#6b6b6b" if is_greyed else "#000000"
                    slot["medal"].configure(text=fallback_medals[i],
                                           font=("Segoe UI", 12), fg=medal_color)

                slot["time"].configure(text="")

                av_path = self._avatar_for(name, int(avatar_id) if avatar_id else 0)
                if av_path:
                    try:
                        img = self._circle(av_path, size=22, greyed=is_greyed)
                        if img:
                            slot["avatar"].configure(image=img)
                            slot["avatar"].image = img
                            self.avatar_refs.append(img)
                        else:
                            slot["avatar"].configure(image="")
                    except Exception as e:
                        print(f"Failed to load avatar for {name}: {e}")
                        slot["avatar"].configure(image="")

                slot["bar_canvas"].pack_forget()

            else:
                slot["medal"].configure(image="", text="")
                empty_color = "#6b6b6b" if is_greyed else "#000000"
                slot["name"].configure(text=f"#{rank}  ‚Äî", fg=empty_color)
                slot["duration"].configure(text="", fg=empty_color)
                slot["time"].configure(text="")
                slot["avatar"].configure(image="")
                slot["bar_canvas"].pack_forget()


        

import tkinter as tk
import tkinter.font as tkfont
from tkinter import ttk, messagebox, filedialog, simpledialog
import datetime
import json
import os
import csv
import sys
import random
import pygame
import re
import threading
import time
from datetime import datetime, timedelta, date, time as dtime# Make sure this is at the top of your file
from collections import defaultdict
import queue
import requests
import datetime as dt
from tkinter import filedialog, messagebox
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
import io
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.platypus import Table, TableStyle

    


# For alarm
import platform
if platform.system() == "Windows":
    import winsound
else:
    winsound = None

        



def _load_medal_icons(folder=app_paths.medals_dir, size=16):
    """
    Load gold/silver/bronze PNGs from the app directory.
    Expected names or subfolders: gold_medal, silver_medal, bronze_medal.
    Returns dict: {1: PIL.Image, 2: PIL.Image, 3: PIL.Image}
    """
    def _find_one(keyword, basename):
        # direct file (with common extensions)
        for ext in (".png", ".webp", ".jpg", ".jpeg"):
            p = os.path.join(folder, basename + ext)
            if os.path.isfile(p):
                return p
        # nested folder like medals/gold_medal/xxx.png
        pdir = os.path.join(folder, basename)
        if os.path.isdir(pdir):
            # Prefer file containing the keyword in its name
            for f in os.listdir(pdir):
                fl = f.lower()
                if fl.endswith((".png", ".webp", ".jpg", ".jpeg")) and keyword in fl:
                    return os.path.join(pdir, f)
            # Fallback: first image inside that folder
            for f in os.listdir(pdir):
                if f.lower().endswith((".png", ".webp", ".jpg", ".jpeg")):
                    return os.path.join(pdir, f)
        # fallback: scan medals/ for a file containing keyword
        if os.path.isdir(folder):
            for f in os.listdir(folder):
                fl = f.lower()
                if fl.endswith((".png", ".webp", ".jpg", ".jpeg")) and keyword in fl:
                    return os.path.join(folder, f)
        return None

    out = {}
    spec = {1: ("gold", "gold_medal"), 2: ("silver", "silver_medal"), 3: ("bronze", "bronze_medal")}
    for rank, (kw, base) in spec.items():
        fp = _find_one(kw, base)
        try:
            if fp:
                im = Image.open(fp).convert("RGBA").resize((size, size), Image.LANCZOS)
                out[rank] = im
        except Exception:
            # keep going if an image fails to load
            pass
    return out


def _avatar_with_medal(avatar_path, medal_img, size=18, spacing=8, online=False, greyed=False):
    """
    Return an ImageTk.PhotoImage composed of circular avatar + medal PNG to the right.
    If medal_img is None, returns standard circular avatar.
    """
    # Load avatar (fallback to gray block)
    try:
        av = Image.open(avatar_path).convert("RGBA").resize((size, size), Image.LANCZOS)
    except Exception:
        av = Image.new("RGBA", (size, size), (200, 200, 200, 255))

    # circular crop
    mask = Image.new("L", (size, size), 0)
    d = ImageDraw.Draw(mask)
    d.ellipse((0, 0, size, size), fill=255)
    avatar_rgba = Image.new("RGBA", (size, size), (0, 0, 0, 0))
    avatar_rgba.paste(av, (0, 0), mask)

    # greyscale option
    if greyed:
        r, g, b, a = avatar_rgba.split()
        grey = Image.merge("RGB", (r, r, r)).convert("L")
        avatar_rgba = Image.merge("RGBA", (grey, grey, grey, a))
        if medal_img is not None:
            mr, mg, mb, ma = medal_img.split()
            mgrey = Image.merge("RGB", (mr, mr, mr)).convert("L")
            medal_img = Image.merge("RGBA", (mgrey, mgrey, mgrey, ma))

    # compose avatar + medal (if any)
    if medal_img is not None:
        base_w = size + spacing + medal_img.width
        base_h = max(size, medal_img.height)
        canvas = Image.new("RGBA", (base_w, base_h), (0, 0, 0, 0))
        y_av = (base_h - size) // 2
        canvas.paste(avatar_rgba, (0, y_av), avatar_rgba)
        y_md = (base_h - medal_img.height) // 2
        canvas.paste(medal_img, (size + spacing, y_md), medal_img)
    else:
        canvas = avatar_rgba

    # online dot (white border + green)
    if online and not greyed:
        d2 = ImageDraw.Draw(canvas)
        r2 = max(2, size // 6)
        b2 = max(1, r2 // 3)
        x0 = size - r2 * 2 - b2
        y0 = (canvas.height - size) // 2 + (size - r2 * 2 - b2)
        d2.ellipse((x0, y0, x0 + 2 * r2, y0 + 2 * r2), fill="white")
        d2.ellipse((x0 + b2, y0 + b2, x0 + 2 * r2 - b2, y0 + 2 * r2 - b2), fill="green")

    return ImageTk.PhotoImage(canvas)





def _nameplate_with_medal(name, avatar_path=None, medal_img=None, size=18, spacing_av_text=6, spacing_text_medal=8, online=False, greyed=False):
    # [avatar] Name [medal] composite; uses fast TTF selection for crisp text without scanning disks.
    if avatar_path:
        try:
            av = Image.open(avatar_path).convert("RGBA").resize((size, size), Image.LANCZOS)
        except Exception:
            av = Image.new("RGBA", (size, size), (200, 200, 200, 255))
        mask = Image.new("L", (size, size), 0)
        ImageDraw.Draw(mask).ellipse((0, 0, size, size), fill=255)
        avatar_rgba = Image.new("RGBA", (size, size), (0, 0, 0, 0))
        avatar_rgba.paste(av, (0, 0), mask)
    else:
        avatar_rgba = None

    # Pick a common system TTF (no directory scan)
    candidates = [
        r"C:\Windows\Fonts\segoeui.ttf",
        r"C:\Windows\Fonts\arial.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/System/Library/Fonts/SFNS.ttf",
    ]
    # Get Tk default font size to match Treeview look
    try:
        tk_font = tkfont.nametofont("TkDefaultFont")
        sz = int(tk_font.cget("size"))
    except Exception:
        sz = 12
    px = abs(sz) if sz < 0 else max(10, int(round(sz * 96 / 72)))

    pil_font = None
    for fp in candidates:
        try:
            if os.path.isfile(fp):
                pil_font = ImageFont.truetype(fp, px)
                break
        except Exception:
            continue
    if pil_font is None:
        pil_font = ImageFont.load_default()

    text = str(name)
    # Measure text
    tmp = Image.new("RGBA", (1024, size*2), (0,0,0,0))
    draw = ImageDraw.Draw(tmp)
    bbox = draw.textbbox((0,0), text, font=pil_font)
    text_w = max(1, bbox[2]-bbox[0])
    text_h = max(1, bbox[3]-bbox[1])

    medal = medal_img if medal_img is not None else None

    w = 0
    h = max(size, text_h, medal.height if medal else 0)
    if avatar_rgba is not None:
        w += size
    if avatar_rgba is not None and text:
        w += spacing_av_text
    if text:
        w += text_w
    if text and medal:
        w += spacing_text_medal
    if medal:
        w += medal.width

    canvas = Image.new("RGBA", (w, h), (0,0,0,0))
    x = 0
    if avatar_rgba is not None:
        y_av = (h - size)//2
        canvas.paste(avatar_rgba, (x, y_av), avatar_rgba)
        if online and not greyed:
            d2 = ImageDraw.Draw(canvas)
            r2 = max(2, size // 6)
            b2 = max(1, r2 // 3)
            x0 = x + size - r2*2 - b2
            y0 = y_av + (size - r2*2 - b2)
            d2.ellipse((x0, y0, x0 + 2*r2, y0 + 2*r2), fill="white")
            d2.ellipse((x0 + b2, y0 + b2, x0 + 2*r2 - b2, y0 + 2*r2 - b2), fill="green")
        x += size
    if avatar_rgba is not None and text:
        x += spacing_av_text

    # draw text
    ImageDraw.Draw(canvas).text((x, (h - text_h)//2 - bbox[1]), text, fill=(36,55,80,255), font=pil_font)
    x += text_w

    if text and medal:
        x += spacing_text_medal
    if medal:
        y_md = (h - medal.height)//2
        canvas.paste(medal, (x, y_md), medal)

    if greyed:
        r,g,b,a = canvas.split()
        grey = Image.merge("RGB", (r, r, r)).convert("L")
        canvas = Image.merge("RGBA", (grey, grey, grey, a))

    return ImageTk.PhotoImage(canvas)


def save_last_update_id(update_id, filename="last_update_id.txt"):
    try:
        with open(filename, "w") as f:
            f.write(str(update_id))
    except Exception as e:
        print("Could not save last_update_id:", e)

def load_last_update_id(filename="last_update_id.txt"):
    try:
        with open(filename, "r") as f:
            return int(f.read().strip())
    except Exception:
        return None
        

def send_telegram_message_and_pin(text, chat_id, pin=False):
    """Send a message and optionally pin it using Telegram API directly."""
    import requests
    from secrets_util import get_secret

    TELEGRAM_BOT_TOKEN = get_secret("TELEGRAM_BOT_TOKEN")
    base_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}"

    try:
        # 1. Send the message
        send_resp = requests.post(f"{base_url}/sendMessage", json={
            "chat_id": chat_id,
            "text": text,
            "parse_mode": "HTML"
        })
        send_data = send_resp.json()

        if not send_data.get("ok"):
            print(f"[Telegram] ‚ùå Failed to send message: {send_data}")
            return False

        print(f"[Telegram] ‚úÖ Message sent successfully")

        # 2. If pin requested ‚Äî pin the message
        if pin:
            message_id = send_data["result"]["message_id"]
            pin_resp = requests.post(f"{base_url}/pinChatMessage", json={
                "chat_id": chat_id,
                "message_id": message_id
            })
            pin_data = pin_resp.json()

            if pin_data.get("ok"):
                print(f"[Telegram] üìå Message pinned successfully")
            else:
                print(f"[Telegram] ‚ùå Failed to pin message: {pin_data}")

        return True

    except Exception as e:
        print(f"[Telegram] ‚ö† Error sending or pinning message: {e}")
        return False

def telegram_polling(app):
    """Single unified polling function for Telegram with enhanced commands"""
    import requests, time, json
    from datetime import datetime, date
    last_update_id = None  # ‚úÖ fixed
    TELEGRAM_BOT_TOKEN = get_secret("TELEGRAM_BOT_TOKEN")
    if not TELEGRAM_BOT_TOKEN:
        print("‚ùå Telegram bot token not found! Check Secret Manager or permissions.")
        return

    api_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}"
    print(f"[Telegram] Using token length: {len(TELEGRAM_BOT_TOKEN)}")
    
    print("[Telegram] Polling started...")
    
    while True:
        try:
            params = {"timeout": 15}
            if last_update_id is not None:
                params["offset"] = last_update_id + 1
                
            resp = requests.get(f"{api_url}/getUpdates", params=params, timeout=20)
            data = resp.json()
            
            if not data.get("ok"):
                time.sleep(2)
                continue
                
            for result in data.get("result", []):
                update_id = result["update_id"]
                last_update_id = update_id
                
                message = result.get("message", {})
                chat_id = str(message.get("chat", {}).get("id", ""))
                text = (message.get("text") or "").strip()
                
                if text:
                    print(f"[Telegram] Received: '{text}' from chat_id: {chat_id}")
                
                # Check if user is authorized (except for initial /start with UID)
                prof = _load_profile()
                authorized_chat_id = prof.get("telegram_chat_id")
                
                # Handle /start command (both connection and session/extra study start)
                if text.lower().startswith("/start"):
                    parts = text.split()
                    
                    # If /start has UID parameter - this is for connection
                    if len(parts) > 1:
                        received_uid = parts[1]
                        expected_uid = prof.get("uid", "")
                        
                        print(f"[Telegram] Checking UID - Expected: {expected_uid}, Received: {received_uid}")
                        
                        if expected_uid and received_uid == expected_uid:
                            # Save chat ID for connection
                            prof["telegram_chat_id"] = str(chat_id)
                            _save_profile(prof)
                            
                            print(f"[Telegram] ‚úÖ Connected! Chat ID {chat_id} saved to profile.json")
                            
                            # Send confirmation with available commands and pin it
                            confirm_msg = (
                                "‚úÖ Connected to StudyTimer!\n\n"
                                "Available commands:\n"
                                "/start - Start current session or extra study\n"
                                "/pause - Pause the timer/extra study\n"
                                "/resume - Resume the timer\n"
                                "/info - Get current session info\n"
                                "/plan - Show today's schedule\n"
                                "/report - Get daily study report\n"
                                "/help - Show this help message\n\n"
                                "üìå This message is pinned for easy reference!"
                            )
                            
                            send_telegram_message_and_pin(confirm_msg, chat_id, pin=True)
                        else:
                            print(f"[Telegram] UID mismatch or missing")
                            response_url = f"{api_url}/sendMessage"
                            requests.post(response_url, json={
                                "chat_id": chat_id,
                                "text": "‚ùå Invalid connection link. Please use the link from the app."
                            })
                    
                    # If just /start without UID - start session or extra study (if authorized)
                    else:
                        if str(chat_id) == str(authorized_chat_id):
                            if app:
                                # Check if there's an active session to start
                                idx = getattr(app, 'active_session_idx', None)
                                if idx is not None:
                                    # There's an active session - start regular timer
                                    if getattr(app, 'registered', False):
                                        msg = "‚ö† Session already started"
                                    else:
                                        # Start the session
                                        app.after(0, app.start_session)
                                        session_name = app.schedule[idx][0] if hasattr(app, 'schedule') else "Unknown"
                                        msg = f"‚úÖ Session started: {session_name}"
                                else:
                                    # No active session - check if we can start extra study
                                    if hasattr(app, 'extra_study_running'):
                                        if app.extra_study_running:
                                            # Extra study is running, stop it
                                            app.after(0, app.toggle_extra_study)
                                            msg = "‚èπ Extra study stopped"
                                        else:
                                            # Start extra study
                                            app.after(0, app.toggle_extra_study)
                                            msg = "üöÄ Extra study started!"
                                    else:
                                        msg = "‚ö† No active session and extra study not available"
                            else:
                                msg = "‚ö† Timer app not running"
                        else:
                            msg = "‚ùå Not connected. Please connect through the app first"
                        
                        response_url = f"{api_url}/sendMessage"
                        requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                
                # Handle /info command - Show current session details
                elif text.lower() == "/info":
                    if str(chat_id) == str(authorized_chat_id):
                        if app:
                            try:
                                # Get current session info
                                idx = getattr(app, 'active_session_idx', None)
                                
                                if idx is not None and hasattr(app, 'schedule'):
                                    # Running session info
                                    session = app.schedule[idx]
                                    session_name = session[0]
                                    start_time = session[1]
                                    end_time = session[2]
                                    
                                    # Convert to 12-hour format
                                    start_dt = parse_time(start_time)
                                    end_dt = parse_time(end_time)
                                    start_12h = to_12hour(start_dt) if start_dt else start_time
                                    end_12h = to_12hour(end_dt) if end_dt else end_time
                                    
                                    scheduled = f"{start_12h} - {end_12h}"
                                    
                                    # Session status
                                    if getattr(app, 'registered', False):
                                        if getattr(app, 'paused', False):
                                            status = "‚è∏ Paused"
                                        else:
                                            status = "‚ñ∂ Running"
                                    else:
                                        status = "‚èπ Not started"
                                else:
                                    session_name = "No active session"
                                    scheduled = "‚Äî"
                                    status = "üí§ Idle"
                                
                                # Check extra study status
                                extra_status = ""
                                if hasattr(app, 'extra_study_running') and app.extra_study_running:
                                    extra_status = "\nüöÄ Extra study: RUNNING"
                                
                                # Today's studied time
                                today_studied = getattr(app, 'today_study_stopwatch_seconds', 0)
                                today_str = hhmmss_from_seconds(int(today_studied))
                                
                                # Today's wastage
                                today_waste = app.get_today_wastage_seconds() if hasattr(app, 'get_today_wastage_seconds') else 0
                                waste_str = hhmmss_from_seconds(int(today_waste))
                                
                                msg = (
                                    f"üìä Current Session Info\n\n"
                                    f"üìö Running session: {session_name}\n"
                                    f"‚è∞ Scheduled: {scheduled}\n"
                                    f"‚úÖ Today studied: {today_str}\n"
                                    f"‚ùå Today wastage: {waste_str}\n"
                                    f"üîÑ Status: {status}"
                                    f"{extra_status}"
                                )
                                
                            except Exception as e:
                                print(f"[Telegram] Error getting info: {e}")
                                msg = "‚ö† Error retrieving session info"
                        else:
                            msg = "‚ö† Timer app not running"
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                    
                    response_url = f"{api_url}/sendMessage"
                    requests.post(response_url, json={
                        "chat_id": chat_id,
                        "text": msg,
                        "parse_mode": "Markdown"
                    })
                
                # Handle /plan command - Show all sessions schedule
                elif text.lower() == "/plan":
                    if str(chat_id) == str(authorized_chat_id):
                        if app and hasattr(app, 'schedule'):
                            try:
                                schedule = app.schedule
                                if schedule:
                                    msg = "üìÖ Today's Study Plan\n\n"
                                    
                                    for i, session in enumerate(schedule, 1):
                                        name = session[0]
                                        start_time = session[1]
                                        end_time = session[2]
                                        break_time = session[3]
                                        
                                        # Convert to 12-hour format
                                        start_dt = parse_time(start_time)
                                        end_dt = parse_time(end_time)
                                        start_12h = to_12hour(start_dt) if start_dt else start_time
                                        end_12h = to_12hour(end_dt) if end_dt else end_time
                                        
                                        # Format break time
                                        if break_time and "-" in break_time:
                                            brk_parts = break_time.split("-")
                                            brk_start = parse_time(brk_parts[0].strip())
                                            brk_end = parse_time(brk_parts[1].strip())
                                            brk_start_12h = to_12hour(brk_start) if brk_start else brk_parts[0]
                                            brk_end_12h = to_12hour(brk_end) if brk_end else brk_parts[1]
                                            break_display = f"{brk_start_12h} - {brk_end_12h}"
                                        elif break_time and break_time.lower() != "no break":
                                            break_display = break_time
                                        else:
                                            break_display = "No break"
                                        
                                        # Check if this is the current session
                                        current_marker = ""
                                        if getattr(app, 'active_session_idx', None) == i-1:
                                            current_marker = " ‚Üê Current"
                                        
                                        msg += (
                                            f"{i}. {name}{current_marker}\n"
                                            f"   Time: {start_12h} - {end_12h}\n"
                                            f"   Break: {break_display}\n\n"
                                        )
                                    
                                    # Add summary
                                    total_sessions = len(schedule)
                                    msg += f"Total sessions: {total_sessions}"
                                else:
                                    msg = "üìÖ No sessions scheduled for today"
                                    
                            except Exception as e:
                                print(f"[Telegram] Error getting plan: {e}")
                                msg = "‚ö† Error retrieving schedule"
                        else:
                            msg = "‚ö† Timer app not running or no schedule available"
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                    
                    response_url = f"{api_url}/sendMessage"
                    requests.post(response_url, json={
                        "chat_id": chat_id,
                        "text": msg,
                        "parse_mode": "Markdown"
                    })
                
                # Handle /report command - Send daily study report
                elif text.lower() == "/report":
                    if str(chat_id) == str(authorized_chat_id):
                        if app:
                            try:
                                # Generate PDF report
                                report_date = date.today()
                                pdf_buffer = app.generate_daily_pdf_auto(report_date)
                                
                                # Send PDF via Telegram
                                send_doc_url = f"{api_url}/sendDocument"
                                
                                # First send a message that report is being generated
                                msg_url = f"{api_url}/sendMessage"
                                requests.post(msg_url, json={
                                    "chat_id": chat_id,
                                    "text": "üìä Generating your study report..."
                                })
                                
                                # Send the PDF
                                files = {
                                    'document': (
                                        f'Study_Report_{report_date}.pdf',
                                        pdf_buffer.getvalue(),
                                        'application/pdf'
                                    )
                                }
                                
                                caption = (
                                    f"üìä Daily Study Report\n"
                                    f"üìÖ Date: {report_date.strftime('%Y-%m-%d')}\n\n"
                                    f"Your detailed study report is attached."
                                )
                                
                                response = requests.post(
                                    send_doc_url,
                                    data={
                                        "chat_id": chat_id,
                                        "caption": caption,
                                        "parse_mode": "Markdown"
                                    },
                                    files=files
                                )
                                
                                if not response.ok:
                                    # If PDF send fails, send summary instead
                                    today_studied = getattr(app, 'today_study_stopwatch_seconds', 0)
                                    today_str = hhmmss_from_seconds(int(today_studied))
                                    today_waste = app.get_today_wastage_seconds() if hasattr(app, 'get_today_wastage_seconds') else 0
                                    waste_str = hhmmss_from_seconds(int(today_waste))
                                    
                                    fallback_msg = (
                                        f"üìä Study Report Summary\n"
                                        f"üìÖ Date: {report_date}\n\n"
                                        f"‚úÖ Studied: {today_str}\n"
                                        f"‚ùå Wastage: {waste_str}\n\n"
                                        f"Full PDF report could not be sent"
                                    )
                                    
                                    requests.post(msg_url, json={
                                        "chat_id": chat_id,
                                        "text": fallback_msg,
                                        "parse_mode": "Markdown"
                                    })
                                    
                            except Exception as e:
                                print(f"[Telegram] Error generating report: {e}")
                                msg = "‚ö† Error generating study report"
                                response_url = f"{api_url}/sendMessage"
                                requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                        else:
                            msg = "‚ö† Timer app not running"
                            response_url = f"{api_url}/sendMessage"
                            requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                        response_url = f"{api_url}/sendMessage"
                        requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                        
                # Handle /pause command - Now handles both regular timer and extra study
                elif text.lower() == "/pause":
                    if str(chat_id) == str(authorized_chat_id):
                        if app:
                            # Check if extra study is running
                            if hasattr(app, 'extra_study_running') and app.extra_study_running:
                                app.after(0, app.toggle_extra_study)
                                msg = "‚è∏ Extra study paused"
                            elif hasattr(app, 'toggle_pause'):
                                if getattr(app, 'paused', False):
                                    msg = "‚ö† Timer is already paused"
                                elif not getattr(app, 'registered', False):
                                    msg = "‚ö† No active session to pause"
                                else:
                                    app.after(0, app.toggle_pause)
                                    msg = "‚è∏ Study timer paused"
                            else:
                                msg = "‚ö† Timer app not running or pause function not available"
                        else:
                            msg = "‚ö† Timer app not running"
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                    
                    response_url = f"{api_url}/sendMessage"
                    requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                
                # Handle /resume command
                elif text.lower() == "/resume":
                    if str(chat_id) == str(authorized_chat_id):
                        if app and hasattr(app, 'toggle_pause'):
                            if not getattr(app, 'paused', False):
                                msg = "‚ö† Timer is not paused"
                            elif not getattr(app, 'registered', False):
                                msg = "‚ö† No active session to resume"
                            else:
                                app.after(0, app.toggle_pause)
                                msg = "‚ñ∂ Study timer resumed"
                        else:
                            msg = "‚ö† Timer app not running"
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                    
                    response_url = f"{api_url}/sendMessage"
                    requests.post(response_url, json={"chat_id": chat_id, "text": msg})
                
                # Handle /help command - Pin the help message
                elif text.lower() == "/help":
                    if str(chat_id) == str(authorized_chat_id):
                        help_msg = (
                            "üìö StudyTimer Bot Commands\n\n"
                            "/start - Start current session or extra study\n"
                            "/pause - Pause the timer/extra study\n"
                            "/resume - Resume the timer\n"
                            "/info - Get current session info\n"
                            "/plan - Show today's schedule\n"
                            "/report - Get daily study report\n"
                            "/help - Show this help message\n\n"
                            "üìå This help is pinned for easy reference!"
                        )
                        
                        send_telegram_message_and_pin(help_msg, chat_id, pin=True)
                    else:
                        msg = "‚ùå Not connected. Please connect through the app first"
                        response_url = f"{api_url}/sendMessage"
                        requests.post(response_url, json={
                            "chat_id": chat_id,
                            "text": msg,
                            "parse_mode": "Markdown"
                        })
                    
        except Exception as e:
            print(f"[Telegram] Polling error: {e}")
            import traceback
            traceback.print_exc()
            time.sleep(3)
            


def get_random_quote_from_folder(folder_path=None):
    if folder_path is None:
        folder_path = app_paths.quotes_dir
    try:
        files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]
        if not files:
            return "No quotes found."
        random_file = random.choice(files)
        with open(os.path.join(folder_path, random_file), 'r', encoding='utf-8') as f:
            return f.read().strip()
    except Exception as e:
        return f"Error loading quote: {e}"
        
STATE_FILE = app_paths.state_file
WASTAGE_FILE = app_paths.wastage_file
STUDY_TOTAL_FILE = app_paths.study_total_file
WASTAGE_DAY_FILE = app_paths.wastage_day_file
STUDY_TODAY_FILE = app_paths.study_today_file
RESET_WASTAGE_FILE = app_paths.reset_wastage_file
PLAN_ACTIVATION_FILE = os.path.join(app_paths.appdata_dir, "plan_activation.json")
CUSTOM_SCHEDULE_FILE = app_paths.custom_schedule_file
HISTORY_LOG = app_paths.history_log_file
TARGET_DRIFT_FILE = app_paths.target_drift_file
LAST_SEEN_FILE = app_paths.last_seen_file
TARGET_THRESH_FILE = app_paths.target_thresh_file
CONFIG_FILE = app_paths.profile_file
DAILY_REPORT_FILE = app_paths.daily_report_file
REPORT_TIME = dtime(23, 59)
SNAPSHOT_FILE = app_paths.snapshot_file
PROFILE_FILE = app_paths.profile_file
PENDING_REPORT_FILE = app_paths.pending_report_file
WEEK_STATE_FILE = app_paths.week_state_file
RUNRATE_MODE = "combined"   # "combined" | "studied" | "waste"

def load_daily_report_status():
    import json, os
    if os.path.exists(DAILY_REPORT_FILE):
        try:
            with open(DAILY_REPORT_FILE, "r") as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_daily_report_status(data):
    import json
    with open(DAILY_REPORT_FILE, "w") as f:
        json.dump(data, f)

def _load_json_safe(path, default):
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception:
        pass
    return default

def _save_json_safe(path, obj):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(obj, f)
    except Exception:
        pass

def get_only_time(scheduled_start):
    parts = scheduled_start.split()
    if len(parts) >= 2:
        hour, ampm = parts[-2], parts[-1]
        hour = hour.lstrip("0")  # remove leading zero
        return f"{hour} {ampm}"
    return scheduled_start
        
def get_total_studied_seconds_upto_yesterday(plan_name=None):
    """Get total studied seconds up to yesterday for a specific plan"""
    import os, json
    from datetime import datetime
    
    if not os.path.exists(app_paths.study_today_file):
        return 0
    
    try:
        with open(app_paths.study_today_file, "r") as f:
            data = json.load(f)
        
        today = datetime.now().strftime("%Y-%m-%d")
        
        # Check if data has plan structure
        if plan_name and isinstance(data, dict):
            sample_key = next(iter(data.keys()), None)
            if sample_key and not sample_key.startswith("20"):  # Not a date
                # New plan-specific structure
                plan_data = data.get(plan_name, {})
                total = sum(v for k, v in plan_data.items() if k != today)
                return int(total)
        
        # Old global structure (backward compatibility)
        total = sum(v for k, v in data.items() if k != today and isinstance(v, (int, float)))
        return int(total)
        
    except Exception as e:
        print(f"[PROGRESS] Error loading study data: {e}")
        return 0
        
def load_reset_wastage():
    if os.path.exists(RESET_WASTAGE_FILE):
        with open(RESET_WASTAGE_FILE, "r") as f:
            return json.load(f)
    return {}


def _load_plan_activation_times():
    """Return the persisted plan activation timestamps per exam key."""
    try:
        if os.path.exists(PLAN_ACTIVATION_FILE):
            with open(PLAN_ACTIVATION_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                return data if isinstance(data, dict) else {}
    except Exception:
        pass
    return {}


def _save_plan_activation_times(data):
    try:
        os.makedirs(app_paths.appdata_dir, exist_ok=True)
        with open(PLAN_ACTIVATION_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass


def _record_plan_activation(plan_name, ts=None):
    """Persist when a plan became active (per exam)."""
    try:
        exam_key = _get_exam_key_for_plans(None)
    except Exception:
        exam_key = "__GLOBAL__"

    if ts is None:
        ts = datetime.now()

    data = _load_plan_activation_times()
    exam_block = data.get(exam_key, {}) if isinstance(data.get(exam_key), dict) else {}
    exam_block[plan_name or "Default"] = ts.isoformat()
    data[exam_key] = exam_block
    _save_plan_activation_times(data)


_runtime_activation_cache = {}


def _ensure_today_activation(plan_name):
    """Return an activation timestamp for today, setting one to now if missing."""
    now = datetime.now()

    # Prefer persisted activation when it's for today
    ts = _get_plan_activation(plan_name)
    if ts and ts.date() == now.date():
        _runtime_activation_cache[plan_name or "Default"] = ts
        return ts

    # If we already set one this runtime, reuse it (only for today)
    runtime_ts = _runtime_activation_cache.get(plan_name or "Default")
    if runtime_ts and runtime_ts.date() == now.date():
        return runtime_ts

    # Otherwise, record a fresh activation for today
    _record_plan_activation(plan_name, now)
    _runtime_activation_cache[plan_name or "Default"] = now
    return now


def _get_plan_activation(plan_name):
    """Fetch the activation timestamp for the given plan (if any)."""
    try:
        exam_key = _get_exam_key_for_plans(None)
    except Exception:
        exam_key = "__GLOBAL__"

    data = _load_plan_activation_times()
    exam_block = data.get(exam_key, {})
    if not isinstance(exam_block, dict):
        return None

    ts_str = exam_block.get(plan_name or "Default")
    if not isinstance(ts_str, str):
        return None

    try:
        return datetime.fromisoformat(ts_str)
    except Exception:
        return None

def save_reset_wastage(obj):
    with open(RESET_WASTAGE_FILE, "w") as f:
        json.dump(obj, f)

def save_schedule(sched):
    cleaned = []
    for s in sched:
        if isinstance(s, (list, tuple)) and len(s) == 4:
            cleaned.append(list(s))  # Ensure JSON serializable
    with open(CUSTOM_SCHEDULE_FILE, "w") as f:
        json.dump(cleaned, f)

def load_schedule():
    if os.path.exists(CUSTOM_SCHEDULE_FILE):
        with open(CUSTOM_SCHEDULE_FILE, "r") as f:
            return [tuple(x) for x in json.load(f)]
    return DEFAULT_SCHEDULE.copy()

DEFAULT_SCHEDULE = [
    ("physics", "10:00", "12:00", "12:00-12:20"),
    ("chemistry", "12:20", "14:50", "14:50-15:00"),
    ("maths", "15:00", "16:15", "16:15-16:25"),
   
]
SCHEDULE = DEFAULT_SCHEDULE

SUBJECT_GROUPS = {
    "Technical MCQ": "Technical",
    "Technical Subject": "Technical",
    "Technical Subject 1": "Technical",
    "Technical Subject 2": "Technical",
    "Technical Subject 3": "Technical",
    "General Science 1": "General Science",
    "General Science 2": "General Science",
    "Current Affairs 1": "Current Affairs",
    "Current Affairs 2": "Current Affairs",
    "Extra Studies": "Extra Studies"
}
GROUP_ORDER = ["Technical", "General Science", "Current Affairs", "Extra Studies"]

def parse_time(timestr):
    try:
        if not timestr or not isinstance(timestr, str):
            return None
        timestr = timestr.strip().lower()
        if "am" in timestr or "pm" in timestr:
            return datetime.strptime(timestr, "%I:%M%p").time()
        else:
            return datetime.strptime(timestr, "%H:%M").time()
    except Exception:
        return None

def get_session_datetimes(start_str, end_str, now=None):
    if now is None:
        now = datetime.now()
    today = now.date()
    start_time = parse_time(start_str)
    end_time = parse_time(end_str)
    dt_end = datetime.combine(today, end_time)
    if end_time <= start_time:
        if now.time() < end_time:
            dt_start = datetime.combine(today - timedelta(days=1), start_time)
        else:
            dt_start = datetime.combine(today, start_time)
            dt_end = dt_end + timedelta(days=1)
    else:
        dt_start = datetime.combine(today, start_time)
    return dt_start, dt_end

def get_study_day_id(now, schedule):
    """Return study day ID or None if schedule is empty."""
    if not schedule or not isinstance(schedule, list):
        return None  # üëà Avoid index errors

    if now is None:
        now = datetime.now()

    try:
        st_dt, en_dt = get_session_datetimes(schedule[0][1], schedule[-1][2], now)
        return st_dt.strftime("%Y-%m-%d")
    except Exception:
        return None

def is_on_break(now, idx, schedule):
    sess = schedule[idx]
    brk = sess[3]

    if not brk or "-" not in brk or brk.lower() == "no break" or brk == "...":
        return False

    today = now.date()
    brk_start_str, brk_end_str = brk.split("-")
    brk_start = parse_time(brk_start_str.strip())
    brk_end   = parse_time(brk_end_str.strip())

    if not brk_start or not brk_end:
        return False   # ‚¨Ö prevent None crashing combine()

    brk_dt_start = datetime.combine(today, brk_start)
    brk_dt_end   = datetime.combine(today, brk_end)

    if brk_dt_end <= brk_dt_start:
        brk_dt_end += timedelta(days=1)

    return brk_dt_start <= now <= brk_dt_end

def get_active_session_idx(schedule):
    now = datetime.now()
    for idx, sess in enumerate(schedule):
        st_dt, en_dt = get_session_datetimes(sess[1], sess[2], now)
        if st_dt <= now <= en_dt:
            return idx, st_dt, en_dt
    return None, None, None

def format_time_centi(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    cs = int((seconds - int(seconds)) * 100)
    return f"{h:02}:{m:02}:{s:02}.{cs:02}"
    
def format_seconds(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    return f"{h:02}:{m:02}:{s:02}"

def to_12hour(dt_time):
    if dt_time is None:
        return ""  # Return empty if input is None
    return dt_time.strftime("%I:%M %p").lstrip("0")

def hhmmss_from_seconds(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    return f"{h:02}:{m:02}:{s:02}"

def parse_hhmmss(hms):
    try:
        h, m, s = [int(x) for x in hms.split(":")]
        return h * 3600 + m * 60 + s
    except Exception:
        return 0

def save_state(state):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f)

def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    return {}

def save_wastage_log(data=None):
    if data is None:
        data = wastage_log
    with open(WASTAGE_FILE, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=["Plan", "Session", "Scheduled Start", "Actual Start", "Wastage (hh:mm:ss)", "Date", "Missed"])
        writer.writeheader()
        writer.writerows(data)

def load_wastage_log():
    """Load all wastage entries from CSV."""
    if os.path.exists(WASTAGE_FILE):
        with open(WASTAGE_FILE, "r", newline="") as f:
            reader = csv.DictReader(f)
            wastage_log.clear()
            for row in reader:
                # Handle old files without "Plan" column
                if "Plan" not in row:
                    row["Plan"] = "Default"
                wastage_log.append(dict(row))

def get_current_plan_wastage_log(plan_name):
    """Return only wastage entries for the specified plan."""
    return [entry for entry in wastage_log if entry.get("Plan", "Default") == plan_name]


def _resolve_plan_name(plan_name=None, app=None):
    """Determine which plan name to use for wastage calculations."""
    if plan_name:
        return plan_name
    if app and hasattr(app, "current_plan_name"):
        return app.current_plan_name or "Default"
    if APP_INSTANCE and hasattr(APP_INSTANCE, "current_plan_name"):
        return APP_INSTANCE.current_plan_name or "Default"
    try:
        return load_last_active_plan()
    except Exception:
        return "Default"


def _load_last_seen_plan(return_details=False):
    """
    Return the plan name recorded with the last_seen timestamp (if any).

    When return_details is True, also report whether the file existed and
    whether a plan was explicitly recorded, so callers can safely guard
    against legacy files that lack plan metadata.
    """
    last_seen_file_exists = os.path.exists(LAST_SEEN_FILE)
    has_explicit_plan = False
    plan_value = None

    try:
        if last_seen_file_exists:
            with open(LAST_SEEN_FILE, "r", encoding="utf-8") as f:
                txt = f.read().strip()
                try:
                    data = json.loads(txt)
                    if isinstance(data, dict):
                        plan_value = data.get("plan")
                        has_explicit_plan = "plan" in data
                except Exception:
                    # legacy plain timestamp format
                    plan_value = None
    except Exception:
        pass

    # Fallback to last active plan so we don't unintentionally backfill other plans
    if plan_value is None:
        try:
            plan_value = load_last_active_plan()
        except Exception:
            plan_value = None

    if return_details:
        return plan_value, has_explicit_plan, last_seen_file_exists
    return plan_value

def add_or_update_wastage(
    session_name,
    scheduled_start,
    actual_start,
    seconds_to_add,
    missed="No",
    app=None,
    plan_name=None,
):
    """
    Write/merge wastage into the row that belongs to the SCHEDULED day.
    Now includes Plan tracking.
    """
    # Resolve target plan and make sure it matches the active plan
    current_plan = _resolve_plan_name(plan_name, app)
    active_plan = None

    if app and hasattr(app, "current_plan_name"):
        active_plan = app.current_plan_name or "Default"
    elif APP_INSTANCE and hasattr(APP_INSTANCE, "current_plan_name"):
        active_plan = APP_INSTANCE.current_plan_name or "Default"
    else:
        try:
            active_plan = load_last_active_plan()
        except Exception:
            active_plan = "Default"

    if active_plan and current_plan != active_plan:
        return
    
    # Trigger UI refresh if app instance is available
    if app:
        try:
            app.after_idle(app.refresh_wastage)
        except Exception:
            pass
    
    # Derive the correct calendar day from scheduled_start
    try:
        sch_dt = datetime.strptime(scheduled_start, "%d-%b-%Y %I:%M %p")
        date_key = sch_dt.strftime("%Y-%m-%d")
    except Exception:
        # Fallback if scheduled_start is malformed
        date_key = datetime.now().strftime("%Y-%m-%d")
    
    # Merge into existing row for the same plan+session+schedule+day+missed flag
    for entry in wastage_log:
        if (entry.get("Plan", "Default") == current_plan and
            entry["Session"] == session_name and
            entry["Scheduled Start"] == scheduled_start and
            entry["Date"] == date_key and
            entry.get("Missed", "No") == missed):
            old_sec = parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))
            entry["Actual Start"] = actual_start
            entry["Wastage (hh:mm:ss)"] = hhmmss_from_seconds(old_sec + int(seconds_to_add))
            entry["Missed"] = missed
            save_wastage_log()
            return
    
    # No row yet ‚Üí create one
    entry = {
        "Plan": current_plan,
        "Session": session_name,
        "Scheduled Start": scheduled_start,
        "Actual Start": actual_start,
        "Wastage (hh:mm:ss)": hhmmss_from_seconds(int(seconds_to_add)),
        "Date": date_key,
        "Missed": missed
    }
    wastage_log.append(entry)
    save_wastage_log()

def get_total_studied_seconds():
    if os.path.exists(STUDY_TOTAL_FILE):
        with open(STUDY_TOTAL_FILE, "r") as f:
            obj = json.load(f)
        return obj.get("total", 0)
    return 0
    
def compute_true_grand_total(plan_name=None, app=None):
    load_wastage_log()
    resolved_plan = _resolve_plan_name(plan_name, app)
    backfill_gap_days(schedule, app=app, plan_name=resolved_plan)
    total_seconds = 0
    for entry in wastage_log:
        if entry.get("Plan", "Default") != resolved_plan:
            continue
        sec = parse_hhmmss(entry["Wastage (hh:mm:ss)"])
        total_seconds += sec
    return total_seconds
    
def hhmmss_from_seconds(seconds):
    seconds = int(seconds)
    h = seconds // 3600
    m = (seconds % 3600) // 60
    s = seconds % 60
    return f"{h:02}:{m:02}:{s:02}"
    
def to_12hr_str(dt):
    if isinstance(dt, datetime):
        return dt.strftime("%I:%M %p").lstrip("0")
    return str(dt)
# Use this for session start/end times if you want

def save_total_studied_seconds(val):
    with open(STUDY_TOTAL_FILE, "w") as f:
        json.dump({"total": val}, f)

def get_total_wastage_seconds(plan_name=None, app=None):
    plan_name = _resolve_plan_name(plan_name, app)
    summary = load_wastage_day_summary(plan_name)
    if not summary:
        return 0  # ‚úÖ Safeguard for None or empty

    grand_total = 0
    for date in summary:
        for group in GROUP_ORDER:
            grand_total += summary[date].get(group, 0)
    return grand_total

def load_wastage_day_summary():
    if os.path.exists(WASTAGE_DAY_FILE):
        try:
            with open(WASTAGE_DAY_FILE, "r") as f:
                return json.load(f)
        except Exception:        
            return {}
        return {}
        
def parse_any_date(dt):
    for fmt in ("%Y-%m-%d", "%d-%b-%Y"):
        try:
            return datetime.strptime(dt, fmt).date()
        except Exception:
            continue
    raise ValueError(f"Unrecognized date format: {dt}")

    first_day = parse_any_date(all_dates[0])
    last_day = parse_any_date(all_dates[-1])

    num_days = (last_day - first_day).days + 1
    for n in range(num_days):
        dt_str = (first_day + timedelta(days=n)).strftime("%Y-%m-%d")
        if dt_str not in by_summary:
            by_day[dt_str] = {}
        # initialize duration for all groups
        for group in GROUP_ORDER:
            by_day[dt_str][group] = 0
        missed_count_by_day[dt_str] = 0

        for sess in self.schedule:
            group = SUBJECT_GROUPS.get(sess[0], sess[0])
            # Calculate if missed or not (put your missed detection logic here)
            session_day = datetime.strptime(dt_str, "%Y-%m-%d")
            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], session_day)
            # your logic to decide if this session was missed for this day:
            was_missed = ... # True/False (replace with your logic)
            if was_missed:
                missed_count_by_day[dt_str] += 1
            else:
                dur = int((en_dt - st_dt).total_seconds())
                by_day[dt_str][group] += dur


            summary = {}
            for date in sorted(by_day.keys(), reverse=True):
                summary[date] = {}
                for group in GROUP_ORDER:
                    summary[date][group] = by_day[date].get(group, 0)
                summary[date]["Missed Sessions"] = missed_count_by_day.get(date, 0)
            save_wastage_day_summary(summary)
            return summary        

def save_wastage_day_summary(summary, plan_name="Default"):
    """Save wastage day summary for a specific plan."""
    # Load existing summaries for all plans
    all_summaries = {}
    if os.path.exists(WASTAGE_DAY_FILE):
        try:
            with open(WASTAGE_DAY_FILE, "r") as f:
                all_summaries = json.load(f)
        except Exception:
            all_summaries = {}
    
    # Update this plan's summary
    all_summaries[plan_name] = summary
    
    # Save back
    with open(WASTAGE_DAY_FILE, "w") as f:
        json.dump(all_summaries, f, indent=2)
    
    return summary

def load_wastage_day_summary(plan_name="Default"):
    """Load wastage day summary for a specific plan."""
    if os.path.exists(WASTAGE_DAY_FILE):
        try:
            with open(WASTAGE_DAY_FILE, "r") as f:
                all_summaries = json.load(f)
                return all_summaries.get(plan_name, {})
        except Exception:
            return {}
    return {}
       

def hhmmss_from_seconds_total(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    return f"{h:02}:{m:02}:{s:02}"

wastage_log = []

from datetime import datetime, timedelta

def _session_duration_seconds(start_12h: str, end_12h: str) -> int:
    """
    Pure scheduled duration, independent of 'now'.
    Handles overnight by adding 24h when end <= start.
    """
    st = parse_time(start_12h)   # expect your existing helper returning datetime.time
    en = parse_time(end_12h)
    if not st or not en:
        return 0
    base = datetime(2000, 1, 1, st.hour, st.minute)
    end  = datetime(2000, 1, 1, en.hour, en.minute)
    if end <= base:
        end += timedelta(days=1)
    return int((end - base).total_seconds())


def backfill_gap_days(schedule, app=None, plan_name=None):
    """
    Create MISSED entries for every scheduled session on any calendar day
    missing between the last logged day and yesterday.
    Idempotent: does not duplicate if rows already exist for a (session, schedule, date).
    Only considers the active plan.
    """
    load_wastage_log()  # ensure fresh

    if plan_name is None:
        if app and hasattr(app, "current_plan_name"):
            plan_name = app.current_plan_name
        elif APP_INSTANCE and hasattr(APP_INSTANCE, "current_plan_name"):
            plan_name = APP_INSTANCE.current_plan_name
        else:
            try:
                plan_name = load_last_active_plan()
            except Exception:
                plan_name = "Default"

    plan_name = plan_name or "Default"

    # ‚úÖ Guard: never backfill for an inactive plan
    if app and hasattr(app, "current_plan_name"):
        if plan_name != app.current_plan_name:
            return
    else:
        try:
            active_plan = load_last_active_plan()
            if active_plan and plan_name != active_plan:
                return
        except Exception:
            pass

    # ‚úÖ Guard: only backfill if this plan was the one active when the app last closed
    last_seen_plan, has_plan, file_exists = _load_last_seen_plan(return_details=True)
    if has_plan:
        if last_seen_plan and last_seen_plan != plan_name:
            return
    elif file_exists:
        # Legacy last_seen file without plan context; avoid cross-plan backfill
        return

    activation_ts = _get_plan_activation(plan_name)
    activation_date = activation_ts.date() if activation_ts else None

    # Find the newest date we have in the log (or None) for this plan
    def _parse_date(d):
        try:
            return datetime.strptime(d, "%Y-%m-%d").date()
        except Exception:
            return None

    plan_entries = [e for e in wastage_log if e.get("Plan", "Default") == plan_name]
    logged_dates = [_parse_date(e.get("Date")) for e in plan_entries if e.get("Date")]
    last_logged = max([d for d in logged_dates if d is not None], default=None)

    today = datetime.now().date()
    yesterday = today - timedelta(days=1)

    # If nothing logged yet, or last logged is already up to yesterday ‚Äî nothing to do
    if last_logged is None or last_logged >= yesterday:
        return

    start_date = last_logged + timedelta(days=1)

    # If this plan was activated after the last logged date, avoid backfilling
    # gaps from before activation (when the plan wasn't active).
    if activation_date and start_date < activation_date:
        start_date = activation_date

    if start_date > yesterday:
        return

    # Build a quick lookup of existing keys so we don't duplicate
    existing = set(
        (e.get("Session"), e.get("Scheduled Start"), e.get("Date"))
        for e in plan_entries
    )

    target_app = app or APP_INSTANCE

    # Walk every missing day: (last_logged + 1) ... yesterday
    cur = start_date
    while cur <= yesterday:
        for sess in schedule:
            # sess: [SessionName, start_12h, end_12h]
            start_12h, end_12h = sess[1], sess[2]
            dur = _session_duration_seconds(start_12h, end_12h)
            if dur <= 0:
                continue

            st_time = parse_time(start_12h)
            if not st_time:
                continue
            st_dt = datetime.combine(cur, st_time)

            scheduled_str = st_dt.strftime("%d-%b-%Y %I:%M %p")
            date_key = st_dt.strftime("%Y-%m-%d")

            key = (sess[0], scheduled_str, date_key)
            if key in existing:
                continue  # already has a row for this session on this day

            add_or_update_wastage(
                sess[0],
                scheduled_str,
                "MISSED",
                dur,
                missed="Yes",
                app=target_app,
                plan_name=plan_name,
            )
            existing.add(key)

        cur += timedelta(days=1)

    # Persisted inside add_or_update_wastage; nothing else to do

def log_skipped_sessions(schedule, app=None, plan_name=None):
    now = datetime.now()
    today_str = get_study_day_id(now, schedule)
    load_wastage_log()

    if plan_name is None:
        if app and hasattr(app, "current_plan_name"):
            plan_name = app.current_plan_name
        elif APP_INSTANCE and hasattr(APP_INSTANCE, "current_plan_name"):
            plan_name = APP_INSTANCE.current_plan_name
        else:
            try:
                plan_name = load_last_active_plan()
            except Exception:
                plan_name = "Default"

    plan_name = plan_name or "Default"

    # ‚úÖ Guard: only log skips for the active plan
    if app and hasattr(app, "current_plan_name"):
        if plan_name != app.current_plan_name:
            return
    else:
        try:
            active_plan = load_last_active_plan()
            if active_plan and plan_name != active_plan:
                return
        except Exception:
            pass

    activation_ts = _ensure_today_activation(plan_name)

    backfill_gap_days(schedule, app=app, plan_name=plan_name)
    resets = load_reset_wastage()

    # Build sets for quick checks
    attended_keys = set(
        (e["Session"], e["Scheduled Start"], e["Date"])
        for e in wastage_log
        if e.get("Plan", "Default") == plan_name and e.get("Missed", "No") != "Yes"
    )
    missed_keys = set(
        (e["Session"], e["Scheduled Start"], e["Date"])
        for e in wastage_log
        if e.get("Plan", "Default") == plan_name and e.get("Missed", "No") == "Yes"
    )

    today_resets = resets.get(today_str, [])

    for idx, sess in enumerate(schedule):
        st_dt, en_dt = get_session_datetimes(sess[1], sess[2], now)
        study_day = st_dt.strftime("%Y-%m-%d")
        if en_dt < now:
            scheduled = st_dt.strftime("%d-%b-%Y %I:%M %p")
            key = (sess[0], scheduled, study_day)

            # Skip if user reset, or if attended exists, or missed already logged
            if (sess[0] in today_resets) or (key in attended_keys) or (key in missed_keys):
                continue

            if activation_ts and en_dt <= activation_ts:
                continue

            duration = int((en_dt - st_dt).total_seconds())
            add_or_update_wastage(
                sess[0],
                scheduled,
                "MISSED",
                duration,
                missed="Yes",
                app=app,
                plan_name=plan_name,
            )  # ‚Üê Added app=app
# --- For studied time calculation ---
def get_today_studied_seconds_actual(schedule, plan_name=None, app=None):
    today_str = datetime.now().strftime("%Y-%m-%d")
    plan_name = _resolve_plan_name(plan_name, app)
    total = 0
    for idx, sess in enumerate(schedule):
        st_dt, en_dt = get_session_datetimes(sess[1], sess[2])
        if st_dt.strftime("%Y-%m-%d") == today_str:
            total += int((en_dt - st_dt).total_seconds())
    today_waste = 0
    for entry in wastage_log:
        if entry["Date"] == today_str and entry.get("Plan", "Default") == plan_name:
            today_waste += parse_hhmmss(entry["Wastage (hh:mm:ss)"])
    return max(total - today_waste, 0)

def get_total_studied_seconds_actual(schedule, plan_name=None, app=None):
    plan_name = _resolve_plan_name(plan_name, app)
    all_dates = set()
    for idx, sess in enumerate(schedule):
        st_dt, en_dt = get_session_datetimes(sess[1], sess[2])
        all_dates.add(st_dt.strftime("%Y-%m-%d"))
    total = 0
    for date in all_dates:
        for idx, sess in enumerate(schedule):
            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], datetime.strptime(date, "%Y-%m-%d"))
            total += int((en_dt - st_dt).total_seconds())
    total_waste = get_total_wastage_seconds(plan_name, app)
    return max(total - total_waste, 0)

def play_alarm_sound(alarm_path=None):
    if alarm_path and os.path.exists(alarm_path):
        if winsound:
            winsound.PlaySound(alarm_path, winsound.SND_FILENAME | winsound.SND_ASYNC)
        else:
            print("\a")
    else:
        if winsound:
            winsound.Beep(1200, 600)
        else:
            print("\a")

# ------ NEW: TODAY STUDIED STOPWATCH ------
def load_today_studied_data():
    """Load study data - handles both old (global) and new (plan-specific) formats"""
    if os.path.exists(STUDY_TODAY_FILE):
        try:
            with open(STUDY_TODAY_FILE, "r") as f:
                obj = json.load(f)
            return obj
        except Exception:
            return {}
    return {}
    
def get_total_stopwatch_studied(plan_name=None):
    """Get total studied time across all days
    
    Args:
        plan_name: Specific plan name, or None for ALL plans combined
    """
    data = load_today_studied_data()
    
    # If requesting ALL plans (None)
    if plan_name is None:
        total = 0
        if data:
            for key, value in data.items():
                if isinstance(value, dict):
                    # Plan structure - sum all dates in this plan
                    total += sum(value.values())
                elif isinstance(value, (int, float)) and key.startswith("20"):
                    # Old format - date as key
                    total += value
        return int(total)
    
    # Requesting specific plan
    if isinstance(data, dict):
        # Check if plan exists in new structure
        if plan_name in data and isinstance(data[plan_name], dict):
            return int(sum(data[plan_name].values()))
        
        # Old format - sum all date values (backward compatibility)
        total = 0
        for key, value in data.items():
            if key.startswith("20") and isinstance(value, (int, float)):
                total += value
        return int(total)
    
    return 0

def save_today_studied_data(obj):
    """Save study data"""
    with open(STUDY_TODAY_FILE, "w") as f:
        json.dump(obj, f, indent=2)
        
def get_today_studied_elapsed(plan_name=None):
    """Get today's studied time for a specific plan or all plans"""
    data = load_today_studied_data()
    today = datetime.now().strftime("%Y-%m-%d")
    
    # If no plan specified, get total across all plans for today
    if plan_name is None:
        total = 0
        for key, value in data.items():
            if isinstance(value, dict):
                total += value.get(today, 0)
            elif key == today and isinstance(value, (int, float)):
                total += value
        return int(total)
    
    # Get specific plan's today time
    if isinstance(data, dict):
        if plan_name in data and isinstance(data[plan_name], dict):
            return int(data[plan_name].get(today, 0))
        
        # Fallback to old format
        if today in data and isinstance(data[today], (int, float)):
            return int(data[today])
    
    return 0

def set_today_studied_elapsed(val, plan_name="Default"):
    """Set today's studied time for a specific plan"""
    data = load_today_studied_data()
    today = datetime.now().strftime("%Y-%m-%d")
    
    # Check if we need to migrate to plan-specific format
    needs_migration = False
    if data:
        for key in data.keys():
            if key.startswith("20") and isinstance(data[key], (int, float)):
                needs_migration = True
                break
    
    if needs_migration:
        old_data = data.copy()
        data = {"Default": old_data}
    
    # Ensure plan structure exists
    if plan_name not in data:
        data[plan_name] = {}
    
    # Set time for this plan
    data[plan_name][today] = int(val)
    
    save_today_studied_data(data)
    
import json, os

def load_config():
    """Load local configuration (Telegram token removed ‚Äî now managed by backend)"""
    if os.path.exists(app_paths.profile_file):
        with open(app_paths.profile_file, "r") as f:
            return json.load(f)
    # ‚úÖ No more telegram_bot_token in default config
    return {"telegram_chat_id": ""}





def load_config():
    """Load configuration from local file.
    Telegram bot token removed ‚Äî handled by backend API.
    """
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    # ‚úÖ Removed telegram_bot_token from default config
    return {"telegram_chat_id": ""}


def save_config(cfg: dict):
    try:
        # Never save sender credentials locally (keep everything else)
        clean_cfg = {k: v for k, v in cfg.items() 
                     if k not in ["sender_email", "sender_password", "smtp_server", "smtp_port"]}
        
        with open(app_paths.profile_file, "w", encoding="utf-8") as f:
            json.dump(clean_cfg, f, indent=2)
    except Exception as e:
        print("Failed to save config:", e)

def load_config():
    """Load config with sender credentials from Firebase"""
    if os.path.exists(app_paths.profile_file):
        try:
            with open(app_paths.profile_file, "r", encoding="utf-8") as f:
                config = json.load(f)
        except Exception:
            config = {}
    else:
        config = {}
    
    # Get sender credentials from Firebase environment variables
    sender_email = get_secret('EMAIL_USER') or ''
    sender_password = get_secret('EMAIL_PASSWORD') or ''
    smtp_server = get_secret('SMTP_SERVER') or 'smtp.gmail.com'
    smtp_port = int(get_secret('SMTP_PORT') or '587')
    
    # Set default values with Firebase credentials
    defaults = {
        "telegram_bot_token": "",
        "telegram_chat_id": "",
        "sender_email": sender_email,
        "sender_password": sender_password,
        "smtp_server": smtp_server,
        "smtp_port": smtp_port,
        "recipient_emails": config.get("recipient_emails", []),
        "email_enabled": config.get("email_enabled", False)
    }
    
    # Merge with existing config, but ALWAYS use Firebase credentials for sender
    for key, value in defaults.items():
        if key not in config or key in ["sender_email", "sender_password", "smtp_server", "smtp_port"]:
            config[key] = value
            
    return config
    
def _open_telegram():
    import webbrowser
    prof = _load_profile()
    uid = prof.get("uid", "")
    
    # Generate UID if not exists
    if not uid:
        import uuid
        uid = uuid.uuid4().hex
        prof["uid"] = uid
        _save_profile(prof)  # Your existing function
        print(f"[Telegram] Generated new UID: {uid}")
    
    # Use your bot's username (WITHOUT @)
    bot_username = "Mobilealarmbot"  # Change if different
    
    bot_link = f"https://t.me/{bot_username}?start={uid}"
    
    print(f"[Telegram] Opening: {bot_link}")
    print(f"[Telegram] Your UID: {uid}")
    print("[Telegram] Please click START in Telegram after the bot opens")
    
    webbrowser.open(bot_link)


def add_minutes_24h(hhmm: str, delta_min: int) -> str:
    from datetime import datetime, timedelta
    try:
        dt = datetime.strptime(hhmm.strip(), "%H:%M")
    except Exception:
        # fallback if empty/bad, keep as-is
        return hhmm
    dt = dt + timedelta(minutes=delta_min)
    return dt.strftime("%H:%M")   
    
# ---------- Reliable GSheet profile push with retry ----------
_pending_profile_push = None  # last name to push (or None)

def _try_push_profile():
    """Attempt to push queued profile to Google Sheet; retry if app not ready."""
    try:
        name = globals().get("_pending_profile_push", None)
        if not name:
            return

        if "app" in globals() and getattr(app, "_sheet_sync", None):
            online_now = bool(
                getattr(app, "stopwatch_running", False)
                or getattr(app, "extra_study_running", False)
                or (
                    getattr(app, "registered", False)
                    and getattr(app, "elapsed_timer_enabled", False)
                    and not getattr(app, "paused", True)
                    and getattr(app, "study_active_from", None) is not None
                )
            )
            print(f"[GSYNC] Pushing profile (retry ok): name={name}, online={online_now}")
            app._sheet_sync.update(name=name, online=online_now)
            globals()["_pending_profile_push"] = None  # success ‚Üí clear
            return

        # Not ready yet ‚Üí schedule another attempt
        if "app" in globals() and hasattr(app, "after"):
            print("[GSYNC] _sheet_sync not ready, retrying in 500ms‚Ä¶")
            app.after(500, _try_push_profile)
    except Exception as e:
        print("[GSYNC] profile push failed:", e)
# ----------------------------------------------------------------

def _live_running_seconds(self):
    """Seconds currently accumulating (running session / extra-study)."""
    from datetime import datetime
    live = 0
    try:
        # main study timer running and not paused
        if getattr(self, "study_active_from", None) and not getattr(self, "paused", True):
            live += int(max(0, (datetime.now() - self.study_active_from).total_seconds()))
    except Exception:
        pass
    try:
        # extra study timer running
        if getattr(self, "extra_study_running", False) and getattr(self, "extra_study_started_at", None):
            live += int(max(0, (datetime.now() - self.extra_study_started_at).total_seconds()))
    except Exception:
        pass
    return live
    
def _hours_to_hhmm(self, hours: float) -> str:
        mins = int(round(max(0.0, hours) * 60))
        return self._fmt_hhmm(mins)

# Add this debugging function to check Google Sheets connection:
def debug_google_sheets_connection():
    """Debug function to test Google Sheets connection"""
    import os, json, traceback
    import gspread
    from google.oauth2.service_account import Credentials

    print("\n" + "="*50)
    print("üîç GOOGLE SHEETS CONNECTION DEBUG")
    print("="*50)

    LB_SHEET_ID = "1qJugcDLdCYtKk2q5rDc9p9cRQT_4S8kicKO_Ow5lQZo"

    # ‚úÖ Load service account JSON from secret (environment variable)
    secret_raw = get_secret("GCP_GSHEET_CREDS")
    if not secret_raw:
        print("‚ùå ERROR: GCP_GSHEET_CREDS not found in environment")
        return False

    try:
        secret_json = json.loads(secret_raw)
        print("‚úÖ Loaded credentials JSON from environment")

        # ‚úÖ Build credentials object directly
        scope = ["https://www.googleapis.com/auth/spreadsheets",
                 "https://www.googleapis.com/auth/drive"]
        creds = Credentials.from_service_account_info(secret_json, scopes=scope)

        gc = gspread.authorize(creds)
        print("‚úÖ Successfully authorized with Google")

        # ‚úÖ Open Sheet
        sheet = gc.open_by_key(LB_SHEET_ID)
        print(f"‚úÖ Successfully opened sheet: {sheet.title}")

        # ‚úÖ List worksheets
        worksheets = sheet.worksheets()
        print(f"üìã Available worksheets:")
        for ws in worksheets:
            print(f"   - {ws.title}")

        # ‚úÖ Check for Licenses sheet
        try:
            licenses_ws = sheet.worksheet("Licenses")
            print(f"‚úÖ Found 'Licenses' worksheet")
            records = licenses_ws.get_all_records()
            print(f"üìä Current records in Licenses worksheet: {len(records)}")
            for i, record in enumerate(records[:3]):
                print(f"   Record {i+1}: {record}")
        except gspread.WorksheetNotFound:
            print("‚ö† 'Licenses' worksheet not found, would create it")

        return True

    except Exception as e:
        print(f"‚ùå ERROR: {e}")
        traceback.print_exc()
        return False

# Add this to test the license system:
def test_license_system():
    """Test the complete license system"""
    print("\n" + "="*50)
    print("üß™ LICENSE SYSTEM TEST")
    print("="*50)
    
    # Test Google Sheets connection first
    if not debug_google_sheets_connection():
        print("‚ùå Google Sheets connection failed - cannot proceed with license test")
        return False
    
    print("\nüîê Testing License Manager...")
    
    try:
        # Create license manager
        license_manager = SimpleLicenseManager(app_paths.gspread_credentials_file)
        
        # Test profile
        test_profile = {
            'user_name': 'Test User',
            'uid': 'test-uid-12345'
        }
        
        print("\nüìù Testing license request...")
        success, message = license_manager.request_license(test_profile)
        
        if success:
            print(f"‚úÖ License request successful: {message}")
            
            print("\nüîç Testing offline validation...")
            valid, result = license_manager.validate_offline()
            
            if valid:
                print(f"‚úÖ Offline validation successful: {result}")
                return True
            else:
                print(f"‚ùå Offline validation failed: {result}")
                return False
        else:
            print(f"‚ùå License request failed: {message}")
            return False
            
    except Exception as e:
        print(f"‚ùå License system test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def hide_and_protect_files():
    # Always use the AppData\Roaming\StudyTimer directory
    files_directory = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
    
    print(f"Looking for files in: {files_directory}")  # Debug
    
    # Find CSV and JSON files in that directory
    csv_files = glob.glob(os.path.join(files_directory, "*.csv"))
    json_files = glob.glob(os.path.join(files_directory, "*.json"))
    files = csv_files + json_files
    
    print(f"Found {len(files)} files to hide: {files}")  # Debug
    
    for file_path in files:
        print(f"Hiding: {file_path}")  # Debug
        try:
            result = subprocess.run(['attrib', '+H', '+R', '+S', file_path], shell=True, capture_output=True, text=True)
            print(f"Result for {file_path}: {result.returncode}")  # Debug
        except Exception as e:
            print(f"Error hiding {file_path}: {e}")
    
    print(f"Successfully processed {len(files)} files")

def unhide_and_make_writable():
    """Unhide files when app starts"""
    files_directory = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
    
    csv_files = glob.glob(os.path.join(files_directory, "*.csv"))
    json_files = glob.glob(os.path.join(files_directory, "*.json"))
    files = csv_files + json_files
    
    for file_path in files:
        subprocess.run(['attrib', '-H', '-R', '-S', file_path], shell=True)
    
    print(f"Unhidden {len(files)} files for app use")
    
def save_last_active_plan(plan_name):
    """
    Save the last active plan **per exam**.

    Stored in last_active_plan.json as:
        { "<exam_key>": "<plan_name>", ... }

    Also keeps writing last_active_plan.txt for backward compatibility.
    """
    try:
        # exam key is based on current profile exam_name or "__GLOBAL__"
        exam_key = _get_exam_key_for_plans(None)
    except Exception:
        exam_key = "__GLOBAL__"

    try:
        os.makedirs(app_paths.appdata_dir, exist_ok=True)

        # --- JSON, per-exam storage ---
        json_path = os.path.join(app_paths.appdata_dir, "last_active_plan.json")
        data = {}
        if os.path.exists(json_path):
            try:
                with open(json_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if not isinstance(data, dict):
                        data = {}
            except Exception as e:
                print(f"[PLAN] Failed to read last_active_plan.json: {e}")
                data = {}

        data[exam_key] = plan_name

        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
        # optional debug:
        # print(f"[PLAN] Saved last active plan '{plan_name}' for exam '{exam_key}'")

        # --- Legacy TXT (global) for old code/tools ---
        try:
            legacy_path = os.path.join(app_paths.appdata_dir, "last_active_plan.txt")
            with open(legacy_path, "w", encoding="utf-8") as f:
                f.write(plan_name)
        except Exception as e:
            print(f"[PLAN] Legacy last_active_plan.txt write failed: {e}")

    except Exception as e:
        print(f"Error saving last active plan: {e}")


def load_last_active_plan():
    """
    Load the last active plan for the **current exam**.

    Prefers last_active_plan.json (per exam),
    falls back to legacy last_active_plan.txt (single value),
    then finally "Default".
    """
    try:
        exam_key = _get_exam_key_for_plans(None)
    except Exception:
        exam_key = "__GLOBAL__"

    # --- Try JSON per-exam file first ---
    try:
        json_path = os.path.join(app_paths.appdata_dir, "last_active_plan.json")
        if os.path.exists(json_path):
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                plan = data.get(exam_key)
                if isinstance(plan, str) and plan.strip():
                    # print(f"[PLAN] Loaded last active plan '{plan}' for exam '{exam_key}'")
                    return plan.strip()
    except Exception as e:
        print(f"[PLAN] Error loading last_active_plan.json: {e}")

    # --- Fallback: legacy TXT (global) ---
    try:
        plan_file = os.path.join(app_paths.appdata_dir, "last_active_plan.txt")
        if os.path.exists(plan_file):
            with open(plan_file, "r", encoding="utf-8") as f:
                legacy_plan = f.read().strip()
                if legacy_plan:
                    return legacy_plan
    except Exception as e:
        print(f"Error loading last active plan: {e}")

    # Final fallback
    return "Default"

class StudyTimerApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.bind_all('<Control-Shift-D>', self._on_dev_shortcut)
        print("[DEV] Ctrl+Shift+D global shortcut bound")
        # üîπ NEW: diagnostics shortcut
        self.bind_all('<Control-Shift-S>', self._on_send_diagnostics)
        print("[DIAG] Ctrl+Shift+S global shortcut bound for diagnostics")
        # Load profile and set user info on app
        profile = _load_profile()
        self.user_uid = profile.get("uid", "")
        self.user_name = profile.get("user_name", "")
        unhide_and_make_writable()      
        # ========== RESTORE MISSING FILES FIRST (SYNCHRONOUS) ==========
        print("[INIT] Checking for cloud restore before loading data...")
        try:
            self.check_cloud_restore_on_startup_sync()
        except Exception as e:
            print(f"[INIT] Restore failed: {e}")
        print("[INIT] Restore check complete - proceeding with initialization\n")
        # ================================================================
        
        # Now continue with rest of initialization
        try:
            print("[INIT] Initializing unified license manager...")
            self.license_manager = UnifiedLicenseManager(LB_CREDENTIALS, LB_SHEET_ID)                
            print("[INIT] Unified license manager initialized successfully")
        except Exception as e:
            print(f"[INIT] ERROR: Failed to initialize license manager: {e}")
            messagebox.showerror("Initialization Error", f"Failed to initialize license manager: {e}")
            self.quit()
            return
        try:
            print("[INIT] Initializing trial manager...")
            self.trial_manager = SecureTrialManager(LB_CREDENTIALS, LB_SHEET_ID, self.license_manager)
            print("[INIT] Trial manager initialized successfully")
        except Exception as e:
            print(f"[INIT] Trial manager initialization error: {e}")
            self.trial_manager = None
            
        # Continue with migration and other initialization
        try:
            migrated = app_paths.migrate_existing_data()
            if migrated:
                print(f"Successfully migrated {len(migrated)} files to AppData folder")
        except Exception as e:
            print(f"Migration failed: {e}")
        try:
            migrated = app_paths.migrate_existing_data()
            if migrated:
                print(f"Successfully migrated {len(migrated)} files to AppData folder")
        except Exception as e:
            print(f"Migration failed: {e}")
        print("[MAIN] Initializing ReferralValidator...")
        try:
            self.referral_validator = ReferralValidator(self)
            print("[MAIN] ‚úì ReferralValidator initialized successfully")
        except Exception as e:
            print(f"[MAIN] ‚ùå Failed to initialize ReferralValidator: {e}")
            import traceback
            traceback.print_exc()
        self.config = load_config()  
        self.title("Study Timer App with Data Tracker")
        self.geometry("600x150")
        self._skipped_payment = False
        print("[DEBUG] Logging in anonymously...")
        login_data = api.anonymous_login()
        if login_data.get("success") and login_data.get("idToken"):
            api.set_auth_token(login_data["idToken"])
            print("[DEBUG] Token set successfully ‚úÖ")
        else:
            print("[DEBUG] Anonymous login failed ‚ùå")
        # Initialize network tracker
        self.tracker = NetworkTracker()        
        self.telegram_bot_token = self.config.get("telegram_bot_token", "")
        self.telegram_chat_id   = self.config.get("telegram_chat_id", "")
        # --- ensure StringVars for totals exist ---
        try:
            import tkinter as tk
            self.today_total_row_var = getattr(self, 'today_total_row_var', tk.StringVar(value=''))
            self.all_day_total_row_var = getattr(self, 'all_day_total_row_var', tk.StringVar(value=''))
        except Exception:
            pass

        # ---------- Onboarding: show only if really needed ----------
        try:
            _prof = _load_profile()
        except Exception:
            _prof = {}

        # If old installs already have name + exam date, mark done once.
        try:
            if not _prof.get("onboarding_done") and (_prof.get("user_name") or "").strip() and (_load_exam_date_only() is not None):
                _prof["onboarding_done"] = True
                _save_profile(_prof)
        except Exception:
            pass

        # Decide if the wizard is needed
        # Once onboarding is marked done, do not prompt again even if cached exam date is missing.
        done_flag = bool(_prof.get("onboarding_done"))
        need_wiz = not done_flag

        if need_wiz:
            def _run_wiz():
                try: self.attributes("-disabled", True)
                except Exception: pass

                wiz = OnboardingWizard(self)
                self.wait_window(wiz)

                try: self.attributes("-disabled", False)
                except Exception: pass

                # After wizard, reload profile + exam date and refresh UI
                try:
                    _p = _load_profile()
                    self.user_name   = _p.get("user_name", "")
                    self.avatar_path = _p.get("avatar_path", "")
                    self.progress_exam_date = _load_exam_date_only() or date.today()
                except Exception:
                    self.progress_exam_date = date.today()

                # update any header/badge immediately if available
                try:
                    if hasattr(self, "update_profile_badge"):
                        self.after(0, self.update_profile_badge)
                    elif getattr(self, "profile_badge", None):
                        self.profile_badge.refresh()
                except Exception:
                    pass

            # run after Tk finishes first layout
            self.after(50, _run_wiz)
        else:
            # already onboarded ‚Üí ensure exam date is cached
            try:
                self.progress_exam_date = _load_exam_date_only() or date.today()
            except Exception:
                self.progress_exam_date = date.today()
                self.after(150, _run_wiz)
                self.after(200, getattr(self, '_refresh_profile_badge', lambda: None))
        self._sheet_sync = SheetSync(app_load_profile_for_sync, app_save_profile_for_sync)
        self._firebase_sync = FirebaseSync(
            profile_loader=_load_profile,
            profile_saver=_save_profile,
            database_url=FIREBASE_DATABASE_URL,
            service_account_path=FIREBASE_SERVICE_ACCOUNT
        )
        try:
            self._sheet_sync.schedule_heartbeat(self, self._sheet_get_stats)
        except Exception as e:
            print('[GSYNC] schedule failed:', e)
            
        def integrity_check():
            try:
                user_profile = _load_profile()
                
                # Check license validation (ONLINE-first inside comprehensive_validation)
                license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)

                # If first-time user, skip integrity checks (trial / onboarding will handle it)
                if license_message == "first_time_user":
                    print("[INTEGRITY] First-time user - skipping integrity check.")
                    return

                # If license is valid, do multi-location integrity sanity check
                if license_valid:
                    offline_status = self.license_manager.check_offline_status(user_profile)

                    payment_ok  = offline_status.get("payment", False)
                    license_ok  = offline_status.get("license", False)
                    pay_count   = offline_status.get("payment_count", 0)
                    lic_count   = offline_status.get("license_count", 0)
                    total_loc   = offline_status.get("total_locations", 0)

                    total_valid_files = pay_count + lic_count
                    expected_slots    = max(1, total_loc * 2)

                    print(
                        f"[INTEGRITY] Offline status -> "
                        f"payment_ok={payment_ok}, license_ok={license_ok}, "
                        f"valid_files={total_valid_files}/{expected_slots}"
                    )

                    # ‚úÖ Case 1: quorum satisfied -> log and continue
                    if payment_ok and license_ok:
                        if total_valid_files < expected_slots:
                            print(
                                "[INTEGRITY] Warning: partial offline copies "
                                "(some locations cleaned), but quorum satisfied. Continuing."
                            )
                        else:
                            print("[INTEGRITY] License integrity OK (all locations healthy).")
                        return

                    # ‚úÖ Case 2: some valid files exist but quorum not satisfied
                    if total_valid_files > 0:
                        print("[INTEGRITY] Offline quorum not satisfied - attempting online repair if possible.")

                        if self.license_manager._check_internet():
                            # Try to repair from server (this should be fast; server already validated in comprehensive_validation)
                            try:
                                recovery_success = self.license_manager.recover_offline_files_from_online(user_profile)
                            except Exception as e:
                                print(f"[INTEGRITY] Recovery raised error: {e}")
                                recovery_success = False

                            if recovery_success:
                                print("[INTEGRITY] Files recovered successfully after quorum failure.")
                                return

                            # Here: internet exists, but recovery failed -> this is really suspicious
                            print(
                                f"[INTEGRITY] Recovery failed despite internet - "
                                f"valid files={total_valid_files}/{expected_slots}"
                            )
                            messagebox.showerror(
                                "License Error",
                                "License file integrity check failed. Please restart."
                            )
                            self._force_exit()
                            return

                        # üö® IMPORTANT CHANGE (your request):
                        # No internet + partial offline state:
                        #   -> DO NOT hard-exit.
                        #   -> Allow session, but log that we want an online repair later.
                        print(
                            "[INTEGRITY] No internet during partial offline state. "
                            "Allowing session, but will require online repair on a future run."
                        )
                        return

                    # ‚úÖ Case 3: no valid offline files at all
                    print(
                        "[INTEGRITY] No valid offline files found. "
                        "Relying on prior license validation (online/offline) for this session."
                    )
                    return
                
                # ‚úÖ License not valid - check trial
                if hasattr(self, 'trial_manager'):
                    trial_status, trial_message, days = self.trial_manager.validate_trial(user_profile)
                    
                    if trial_status == 'valid':
                        print(f"[INTEGRITY] Trial active ({days} days) - integrity OK")
                        return  # ‚úÖ Valid trial = pass integrity check
                        
                    elif trial_status == 'expired':
                        print("[INTEGRITY] Trial expired - integrity OK (expected state)")
                        return
                        
                    elif trial_status == 'tampered':
                        print(f"[INTEGRITY] Trial tampered: {trial_message}")
                        messagebox.showerror("Trial Error", f"Trial tampering detected: {trial_message}")
                        self._force_exit()
                        
                    elif trial_status == 'no_trial':
                        print("[INTEGRITY] No trial - integrity OK (first-time user)")
                        return
                
                # ‚úÖ If we reach here, no license and no trial - that's OK for first-time users
                print(f"[INTEGRITY] No license or trial - integrity OK")
                
            except Exception as e:
                print(f"[INTEGRITY] Check error: {e}")
                import traceback
                traceback.print_exc()
        # ‚úÖ Add validation state tracking
        self._validation_in_progress = False
        self._validation_completed = False
        self.after(1000, self._check_initial_trial_status)
        self.after(100000, integrity_check) 
        self.after(900000, self._check_license_and_payment) 
        # Start periodic write (30s) and read (60s) heartbeats
        self.after(3_000, self._gsync_write_tick)
        self.after(5_000, self._gsync_read_tick)
        self.state("zoomed")
        self.config = load_config()
        self.telegram_bot_token = self.config.get("telegram_bot_token", "")
        self.telegram_chat_id   = self.config.get("telegram_chat_id", "")
        # Load profile.json (separate from config.json)
        _prof = _load_profile()
        self.user_name = _prof.get("user_name", "")
        self.avatar_path = _prof.get("avatar_path", "")   
        self.last_stopwatch_disk_write = time.time()
        self.stopwatch_disk_write_interval = 30  # seconds (change to 10 if you want faster saves)  
        # ‚úÖ Load today's studied time for current plan
        try:
            loaded_seconds = get_today_studied_elapsed(plan_name=self.current_plan_name)
            self.today_study_stopwatch_seconds = loaded_seconds
            print(f"[INIT] Loaded {loaded_seconds}s for plan '{self.current_plan_name}'")
        except Exception as e:
            print(f"[INIT] Error loading study time: {e}")       
        self.update_opened_days()
        self.suppress_next_session_telegram = False
        self.session_end_notified = False
        self.command_queue = queue.Queue()
        self.last_start_notify_idx = None
        self.last_ended_session_idx = None
        self.geometry("1080x1920")     
        self.pause_credit_seconds = 0  # Total earned pause credit in seconds
        self.pause_credit_label = None  # UI element, set up later
        self.wastage_by_day = {}
        self.manual_plan_row_selected = False
        self.schedule = load_schedule()
        self.clean_schedule()
        save_schedule(self.schedule) 
        # === Multi-plan setup ===
        self.plans = load_all_plans()
        self.current_plan_name = load_last_active_plan()  # ‚Üê Load last active plan

        # If last plan doesn't exist anymore, fall back to Default
        if self.current_plan_name not in self.plans:
            self.current_plan_name = "Default"
            if self.current_plan_name not in self.plans:
                self.plans[self.current_plan_name] = []

        self.schedule = self.plans[self.current_plan_name]  
        # ‚úÖ Update the dropdown to show the correct plan
        if hasattr(self, 'plan_var'):
            self.plan_var.set(self.current_plan_name)   
        self.alarm_file = None
        self.dark_mode = False
        self.load_alarm_settings()
        self.alarm_playing = False
        self.after(1000, self.check_custom_alarm_time)
        self.title("Study Timer Pro")
        self.geometry("1080x1920")
        self.resizable(True, True)
        pygame.mixer.init()
        # initial badge paint
        try:
            self.update_profile_badge()
        except Exception:
            pass
       
       # === Title Bar Frame (single row with 3 zones: left | center | right) ===
        title_frame = tk.Frame(self)

        # --- Profile badge (avatar + name + mini edit) ---
        self._profile_badge = tk.Frame(title_frame, bg=self.cget("bg"))
        self._profile_badge.pack(side="left", padx=(8, 0))

        # Try loading PIL for circular avatar
        try:
            from PIL import Image, ImageTk, ImageDraw
            _pil_ok = True
        except Exception:
            _pil_ok = False

        self._profile_avatar_img = None
        self._profile_avatar = tk.Label(self._profile_badge, bd=0)
        self._profile_avatar.pack(side="left")

        self._profile_name_lbl = tk.Label(self._profile_badge, text=(self.user_name or "You"), font=("Arial", 10, "bold"))
        self._profile_name_lbl.pack(side="left", padx=(6, 4))

        def _open_editor():
            try:
                self.attributes('-disabled', True)
            except Exception:
                pass
            wiz = OnboardingWizard(self)
            self.wait_window(wiz)
            try:
                self.attributes('-disabled', False)
            except Exception:
                pass
            # refresh name + avatar + push to sheet
            self.update_profile_badge()
            try:
                if hasattr(self, "sheet") and self.sheet and getattr(self.sheet, "row_index", None):
                    self.sheet.write_my_row(name=getattr(self, "user_name", None))
            except Exception as _e:
                print("[SYNC] profile push error:", _e)
            try:
                if hasattr(self, "lb_table"): self.lb_table.refresh(force=True)
                if hasattr(self, "lb_top3"):  self.lb_top3.refresh(force=True)
            except Exception:
                pass

        self._profile_edit_btn = tk.Button(self._profile_badge, text="‚úé", width=2, height=1, relief="groove", cursor="hand2", command=_open_editor)
        self._profile_edit_btn.pack(side="left", padx=(0, 6))

        def _load_avatar_circular(fp, size=24):
            if not fp or not _pil_ok:
                return None
            try:
                im = Image.open(fp).convert("RGBA").resize((size, size))
                mask = Image.new("L", (size, size), 0)
                ImageDraw.Draw(mask).ellipse((0, 0, size, size), fill=255)
                av = Image.new("RGBA", (size, size), (0,0,0,0))
                av.paste(im, (0,0), mask)
                return ImageTk.PhotoImage(av)
            except Exception:
                return None
       
        title_frame.pack(fill="x", pady=(4, 0))
        # Remove legacy header profile widgets so we don't duplicate the new ProfileBadge
        self._remove_legacy_profile_widgets()
        
        # Left spacer (optional: for symmetry)
        left_spacer = tk.Frame(title_frame, width=200)
        left_spacer.pack(side="left")
        
        # --- Top title frame ---
        title_frame = tk.Frame(self)
        title_frame.pack(side="top", fill="x", pady=10)

        # --- Short-term frame ---
        short_frame = tk.Frame(title_frame)
        short_frame.pack(side="left", padx=(180, 0))
        # --- Data usage label (left of short-term) ---
        self.data_usage_label = tk.Label(
            short_frame,
            text="Data Usage: 0 KB",  # changed text
            font=("Arial", 11),       # removed "bold"
            fg="green"
        )
        self.data_usage_label.pack(side="left", padx=(20, 80))
        self.short_term_label = tk.Label(
            short_frame,
            text="Short-term: --:--",
            font=("Arial", 11, "bold"),
            fg="#0a73b8"
        )
        self.short_term_label.pack(side="left")
        
        self.update_data_usage()

        # --- Long-term frame ---
        long_frame = tk.Frame(title_frame)
        long_frame.pack(side="left", padx=(10, 0))

        self.long_term_label = tk.Label(
            long_frame,
            text="Long-term: --:--",
            font=("Arial", 11, "bold"),
            fg="#0a73b8"
        )
        self.long_term_label.pack(side="left")        
        self.long_info_btn = tk.Button(
            long_frame, text="i", font=("Arial", 10, "bold"),
            width=2, relief="groove", cursor="hand2",
            command=self.show_goal_info
        )
        self.long_info_btn.pack(side="left", padx=(8, 0))

        # Right-side buttons
        right_buttons_frame = tk.Frame(title_frame)
        right_buttons_frame.pack(side="right")
        self.undo_stack = []
        self.redo_stack = []

        # Theme button
        self.theme_btn = tk.Button(right_buttons_frame, text="üåô", font=("Arial", 16), bd=0, relief="flat",
                                   command=self.toggle_theme, cursor="hand2")
        self.theme_btn.pack(side="right", padx=4, pady=2)
        self.add_hover_effect(self.theme_btn, hover_bg="#D3D3D3")

        # Alarm button
        self.alarm_btn = tk.Button(right_buttons_frame, text="üîî", font=("Arial", 13), bd=0, relief="flat",
                                   command=self.select_alarm_file, cursor="hand2")
        self.alarm_btn.pack(side="right", padx=(0, 7), pady=2)
        self.add_hover_effect(self.alarm_btn, hover_bg="#D3D3D3")

        # Alarm tip label
        self.alarm_tip = tk.Label(right_buttons_frame, text="Alarm", font=("Arial", 8), fg="#0d82db", bg="#f4f4f8")
        self.alarm_tip.place(relx=0.94, rely=0.88)

        # Set alarm button
        self.set_alarm_btn = tk.Button(right_buttons_frame, text="Set Alarm", font=("Arial", 9),
                               command=self.set_alarm, cursor="hand2")
        self.set_alarm_btn.pack(side="right", padx=(4, 2), pady=2)
        self.add_hover_effect(self.set_alarm_btn, hover_bg="#E0E0E0")

        # Change exam button
        self.change_exam_btn = tk.Button(title_frame, text="Set Exam Date", font=("Arial", 9), 
                                        command=self.change_exam_date, cursor="hand2")
        self.change_exam_btn.pack(side="right", padx=(4, 2), pady=2)
        self.add_hover_effect(self.change_exam_btn, hover_bg="#E0E0E0")

        # Notification button
        self.notification_btn = tk.Button(
            title_frame,
            text="üîî",
            font=("Arial", 10),
            bg="#95A5A6",
            fg="white",
            width=3,
            command=self.show_notifications_inbox,
            cursor="hand2",
            relief="raised",
            bd=2,
            padx=2,
            pady=1
        )
        self.notification_btn.pack(side="right", padx=(4,2), pady=2)
        self.add_hover_effect(self.notification_btn, hover_bg="#7F8C8D", hover_fg="white", 
                             normal_bg="#95A5A6", normal_fg="white")

        # Help button
        self.help_btn = tk.Button(
            title_frame,
            text="‚ùì Help",
            font=("Arial", 9),
            bg="#3498DB",
            fg="white",
            command=self.show_help_menu,  # <-- Changed to show_help_menu
            cursor="hand2"
        )
        self.help_btn.pack(side="right", padx=(4,2), pady=2)
        self.add_hover_effect(self.help_btn, hover_bg="#2980B9", hover_fg="white", 
                             normal_bg="#3498DB", normal_fg="white")

        # near your Export PDF button, create AI button like:
        self.ai_btn = tk.Button(title_frame, text="AI", command=lambda: open_ai_chat_dialog(self, on_plans_updated=self.reload_plans_from_disk))
        self.ai_btn.pack(side="right", padx=(4,2), pady=2)


        # Export PDF button
        self.export_pdf_btn = tk.Button(
            title_frame,
            text="Export PDF",
            font=("Arial", 9),
            bg="#FFB6C1",
            fg="white",
            command=self.export_wastage_to_pdf,
            cursor="hand2"
        )
        self.export_pdf_btn.pack(side="right", padx=(4,2), pady=2)
        self.add_hover_effect(self.export_pdf_btn, hover_bg="#FF91A4", hover_fg="white", 
                             normal_bg="#FFB6C1", normal_fg="white")

        # Check for notifications when app starts
        self.after(1000, self.check_for_new_notifications)
        self.after(300000, self.periodic_notification_check)
        
        self.user_id = get_user_id_from_profile()
    
        # === Tabs setup ===
        self.notebook = ttk.Notebook(self)
        self.plan_tab = ttk.Frame(self.notebook)
        self.live_tab = ttk.Frame(self.notebook)
        self.wastage_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.plan_tab, text="Today's Plan")
        self.notebook.add(self.live_tab, text="Live Session")
        self.notebook.add(self.wastage_tab, text="Wastage Report")
        self.notebook.pack(fill="both", expand=True)
        # Create exam-name pill near the plan selector + countdown on tab row
        self.after(0, self._init_exam_header_on_tabs)

        
        # Define the callback for importing plans
        def import_plan_to_tab(plan_data):
            """Callback to import plan to Plan tab"""
            self.plans[plan_data['plan_name']] = plan_data['sessions']
            save_all_plans(self.plans)
            self.plan_var.set(plan_data['plan_name'])
            self.current_plan_name = plan_data['plan_name']
            self.schedule = plan_data['sessions']
            save_last_active_plan(plan_data['plan_name'])
            self.plan_display_btn.config(
                text=self._format_plan_button_label(plan_data["plan_name"])
            )
            self.refresh_plan_tree()
            messagebox.showinfo("Import Successful", f"Plan '{plan_data['plan_name']}' imported!")
        
        # ‚úÖ Load profile once
        profile = _load_profile()
        
        # ‚úÖ Add the Groups tab with profile data (REPLACE YOUR OLD CODE)
        self.groups = add_firebase_groups_tab(
            self.notebook, 
            self.user_id,
            import_plan_to_tab,
            profile  # Pass the entire profile dict
        )

        # Apply styling and effects
        self.setup_notebook_effects()
        from datetime import timedelta
        import os, json

        self.progress_start_date = date.today()  # default fallback

        # ‚úÖ Load from goal_config.json if available
        if os.path.exists(app_paths.goal_config_file):
            try:
                with open(app_paths.goal_config_file, "r") as f:
                    content = f.read().strip()
                    if content:
                        data = json.loads(content)
                        self.progress_goal_hours = data.get("goal_hours", 0)
                        marker_gap_days = data.get("marker_gap_days", 7)
                        if "start_date" in data:
                            self.progress_start_date = date.fromisoformat(data["start_date"])
                    else:
                        print("‚ö† goal_config.json is empty. Using defaults.")
            except Exception as e:
                print(f"‚ö† Failed to load goal_config.json: {e}. Using defaults.")
        else:
            self.progress_goal_hours = 0
            marker_gap_days = 7
        self.progress_exam_date = _load_exam_date_only() or date.today()
      

        # Default values
        self.progress_goal_hours = 0
        marker_gap_days = 7

        # ‚úÖ Safely load saved config
        if os.path.exists(app_paths.goal_config_file):
            try:
                with open(app_paths.goal_config_file, "r") as f:
                    content = f.read().strip()
                    if content:
                        data = json.loads(content)
                        self.progress_goal_hours = data.get("goal_hours", 0)
                        marker_gap_days = data.get("marker_gap_days", 7)
                    else:
                        print("‚ö† goal_config.json is empty. Using defaults.")
            except Exception as e:
                print(f"‚ö† Failed to load goal_config.json: {e}. Using defaults.")

        self.progress_goal_seconds = int(self.progress_goal_hours * 3600)
     

        # ‚úÖ Generate red line markers
        self.progress_markers = []
        current = self.progress_start_date
        while current <= self.progress_exam_date:
            label = current.strftime("%b %d")
            self.progress_markers.append((current, label))
            current += timedelta(days=marker_gap_days)

        self.setup_plan_tab()
        self.setup_live_tab()
        self.setup_wastage_tab()

        self.study_elapsed_seconds = 0.0
        self.study_active_from = None
        self.elapsed_timer_enabled = False
        self.remaining_visual_freeze = False
        self.remaining_visual_frozen_value = None
        self.pause_start_time = None
        self.session_start_datetime = None
        self.session_end_datetime = None
        self.active_session_idx = None
        self.prev_session_idx = None
        self.registered = False
        self.paused = False

        self.state = load_state()
        self._restore_pause_state_on_startup()
        # restore persisted pause credit (defaults to 0)
        self.pause_credit_seconds = int(self.state.get("pause_credit_seconds", 0))
        if self.pause_credit_label:
            self.update_pause_credit_label()
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)   # add this line
        
        self.pause_total_seconds = 0
        self.pause_start = None
        self.last_close_time = None
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)
  
        log_skipped_sessions(self.schedule, app=self)
        self.restore_or_init_session()
        self._backfill_wastage_offline()
        self.update_timer()
        self.protocol("WM_DELETE_WINDOW", self.on_app_close)

        self.total_studied_time = get_total_studied_seconds_actual(self.schedule, plan_name=self.current_plan_name, app=self)
        self.set_theme(self.dark_mode)
        self.prev_session_idx = None
        
       

        self.extra_study_running = False
        self.extra_study_start = None
        self._pause_waste_carry = 0.0

        # --- Today studied stopwatch ---
        # ‚úÖ Ensure stopwatch variable exists before calling update
        if not hasattr(self, 'today_study_stopwatch_seconds'):
            try:
                self.today_study_stopwatch_seconds = get_today_studied_elapsed(plan_name=self.current_plan_name)
                print(f"[INIT] Stopwatch initialized: {self.today_study_stopwatch_seconds}s for '{self.current_plan_name}'")
            except Exception as e:
                print(f"[INIT] Error initializing stopwatch: {e}")
                self.today_study_stopwatch_seconds = 0

        self.last_study_stopwatch_update = datetime.now()
        self.stopwatch_running = False
        self.stopwatch_update()
        # --- Target-drift bootstrap (new fields) ---
        self._per_day_key = self._get_today_key()
        self.per_day_drift_short = 0.0
        self.per_day_drift_long  = 0.0
        self._tick_ts = time.time()  # for precise elapsed dt

        # try load saved drift for today (safe fallbacks)
        store = _load_json_safe(TARGET_DRIFT_FILE, {})
        today_key = self._get_today_key()
        if isinstance(store.get(today_key), dict):
            self.per_day_drift_short = float(store[today_key].get("short", 0.0))
            self.per_day_drift_long  = float(store[today_key].get("long", 0.0))
        # === Target-drift bootstrap (must be before first update_goal_daywise_targets) ===
        try:
            self.per_day_drift_seconds = self._load_target_drift_today()
        except Exception:
            self.per_day_drift_seconds = 0  # fallback if helper not present yet

        self._last_sss_snapshot = int(getattr(self, "today_study_stopwatch_seconds", 0))

        # If you added the helper earlier, this will backfill drift for app-closed time.
        try:
            self._restore_offline_drift()
        except Exception:
            pass

        # Now safe to prime and start the loop
        self.short_drift_seconds = 0.0
        self.long_drift_seconds  = 0.0
        self._last_drift_tick = datetime.now()
        self._last_drift_tick = datetime.now()
        self.update_goal_daywise_targets()
         # Track day rollovers + caps/floors for both short & long
        self._per_day_key = self._get_today_key()
        self.short_cap_today = None
        self.long_cap_today = None
        self.short_floor_today = None
        self.long_floor_today = None
        self.after(1000, self.update_goal_daywise_targets_loop)
        self.session_started_flags = [False] * len(self.schedule)
        self.check_for_session_start()
        # Start Telegram polling in a background thread
        threading.Thread(target=telegram_polling, args=(self,), daemon=True).start()
        self.check_command_queue()
        self.after(100, self.check_command_queue)      
        self.auto_refresh_wastage()
         # <-- load (or compute once) for today
        self._offline_restored_for_today = False
        self._restore_offline_drift_dual()
        self.short_threshold_seconds = None
        self.long_threshold_seconds = None
        self.threshold_day_key = None
        self._reset_thresholds_flag = False  # do NOT force
        self._load_frozen_thresholds_on_startup()
        if self.state.get("actual_start"):
            self.study_active_from = datetime.fromisoformat(self.state["actual_start"])
        else:
            self.study_active_from = None

        self.pause_total = self.state.get("pause_total", 0)
        self.paused = self.state.get("pause_active", False)
        if self.state.get("pause_start"):
            self.pause_start = datetime.fromisoformat(self.state["pause_start"])
        else:
            self.pause_start = None
        self._restore_offline_drift_dual() 
        # force app to start in paused mode
        self.paused = True
        self.stopwatch_running = False
        if hasattr(self, "pause_btn"):
            self.pause_btn.config(text="Resume")
        if hasattr(self, "status_label"):
            self.status_label.config(text="Paused. Press Resume to continue.", foreground="orange")
       
        self._remove_legacy_profile_widgets()
        # one and only profile badge
        self.profile_badge = ProfileBadge(self, self)   # master=self, app=self
        self.profile_badge.place(x=12, y=8, anchor="nw")  # tweak x/y as you like
        # Store reference to the edit button for the guide
        self.profile_edit_btn = self.profile_badge.edit
        self.refresh_goal_and_markers()
        self.after(0, self.recompute_required_rates)
        self._start_runrate_scheduler()
        self.protocol("WM_DELETE_WINDOW", self.on_app_close)
        self.bind('<Control-u>', lambda e: self.unhide_files_manually())
        self.after(500000, self.check_first_time_user)
        self.referral_system = None
        self.setup_email_and_referral_ui()
        self.referral_validator = None
        self.premium_features_unlocked = False        
        if hasattr(self, 'license_manager') and self.license_manager:
            self.license_manager.main_app_instance = self
        self._check_day_change_on_startup()
        self.after(100, self._check_initial_tampered_state)
        
        # --- End
        
    def _ensure_exam_countdown_label(self):
        """Create the small slim countdown label if missing."""
        if hasattr(self, "exam_countdown_label") and self.exam_countdown_label.winfo_exists():
            return
        if not hasattr(self, "notebook") or not self.notebook.winfo_ismapped():
            self.after(200, self._ensure_exam_countdown_label)
            return
        if not hasattr(self, "exam_header_label") or not self.exam_header_label.winfo_exists():
            self.after(200, self._ensure_exam_countdown_label)
            return

        # Try to match notebook background, fall back to a neutral color
        try:
            bg_color = self.notebook.cget("background")
        except Exception:
            try:
                bg_color = self.exam_header_label.master.cget("background")
            except Exception:
                bg_color = "#f0f0f0"

        self.exam_countdown_label = tk.Label(
            self.notebook,
            text="",
            font=("Segoe UI", 10, "bold"),
            bg=bg_color,
            fg="#444444",
        )
        self._position_exam_countdown_label()

    def _update_exam_countdown(self):
        """Update remaining time label every second."""
        from datetime import datetime, time

        if (
            not hasattr(self, "exam_countdown_label")
            or not self.exam_countdown_label.winfo_exists()
        ):
            # If label disappeared, recreate and keep loop alive
            self._ensure_exam_countdown_label()
            self.after(1000, self._update_exam_countdown)
            return

        exam_date = self._get_exam_date_for_current_exam()

        if not exam_date:
            # No date set for this exam
            self.exam_countdown_label.config(text="")
        else:
            now = datetime.now()
            target = datetime.combine(exam_date, time(0, 0))
            delta = target - now
            total_sec = int(delta.total_seconds())

            if total_sec <= 0:
                text = "0d 0h 0m 0s"
            else:
                days = total_sec // 86400
                rem = total_sec % 86400
                hours = rem // 3600
                rem %= 3600
                mins = rem // 60
                secs = rem % 60
                text = f"{days}d {hours}h {mins}m {secs}s"

            self.exam_countdown_label.config(text=text)

        # schedule next update
        self.after(1000, self._update_exam_countdown)
        
    def _get_exam_date_for_current_exam(self):
        """Return datetime.date for the current exam name, or None."""
        try:
            # get current exam name
            exam_name = getattr(self, "current_exam_name", "") or ""
            if not exam_name:
                prof = _load_profile() or {}
                exam_name = (prof.get("exam_name") or "").strip()
                self.current_exam_name = exam_name

            # DIRECT CALL ‚Äî no import
            return get_exam_date_for_exam(exam_name)

        except Exception as e:
            print(f"[EXAM] _get_exam_date_for_current_exam failed: {e}")
            return getattr(self, "progress_exam_date", None)
        
    def _init_exam_header_on_tabs(self):
        """
        Create or update the white exam-name pill that sits near the
        plan dropdown while keeping the countdown on the tabs row.
        """
        # Get current exam name from profile
        try:
            prof = _load_profile() or {}
            exam_name = (prof.get("exam_name") or "").strip()
        except Exception as e:
            print(f"[EXAM-UI] Failed to load profile: {e}")
            exam_name = ""

        if not exam_name:
            exam_name = "No Exam"

        self.current_exam_name = exam_name

        # Collect exam names from plans.json and also include the current one
        try:
            exam_names = get_all_exam_names()
        except Exception as e:
            print(f"[EXAM-UI] Failed to read exam names: {e}")
            exam_names = []

        if exam_name not in exam_names:
            exam_names.append(exam_name)

        # Filter out empty / special keys for UI purposes
        visible_exams = [e for e in exam_names if e and e != "__GLOBAL__"]
        has_multiple_exams = len(set(visible_exams)) > 1

        # Ensure plan dropdown exists before positioning beside it
        if not hasattr(self, "plan_display_btn") or not self.plan_display_btn.winfo_exists():
            self.after(200, self._init_exam_header_on_tabs)
            return

        self.exam_header_char_width = 8
        # Build label text with fixed-width formatting so the dropdown arrow is always visible
        label_text = self._format_exam_header_label(exam_name)

        plan_font = getattr(self.plan_display_btn, "cget", lambda x: ("Segoe UI", 9))("font")
        plan_padx = getattr(self.plan_display_btn, "cget", lambda x: 10)("padx")
        plan_pady = getattr(self.plan_display_btn, "cget", lambda x: 4)("pady")

        # If label already exists, just update text and reposition
        if hasattr(self, "exam_header_label") and self.exam_header_label.winfo_exists():
            self.exam_header_label.config(
                text=label_text,
                width=self.exam_header_char_width,
                font=plan_font,
                padx=plan_padx,
                pady=plan_pady,
            )
            self._position_exam_header_label()
            self._ensure_exam_countdown_label()
            return


        # Create new label that sits near the plan dropdown
        self.exam_header_label = tk.Button(
            getattr(self, "plan_button_frame", self.plan_tab),
            text=label_text,
            font=plan_font,
            bg="white",
            fg="#333",
            bd=1,
            relief="solid",
            padx=plan_padx,
            pady=plan_pady,
            width=self.exam_header_char_width,
            anchor="w",
            cursor="hand2",
            command=lambda: self._on_exam_header_click(),
        )

        # Position it beside the plan dropdown
        self._position_exam_header_label()

        # Create / ensure countdown label on the tab row
        self._ensure_exam_countdown_label()

        # Start countdown loop once
        if not getattr(self, "_exam_countdown_started", False):
            self._exam_countdown_started = True
            self._update_exam_countdown()

    def _format_exam_header_label(self, exam_name: str) -> str:
        """
        Format the exam label so short names sit near the center while the ‚ñº stays on
        the far right edge of the fixed-width button.
        """
        safe_name = (exam_name or "No Exam").strip() or "No Exam"
        total_width = getattr(self, "exam_header_char_width", 8)
        arrow = " ‚ñº"

        name_space = max(total_width - len(arrow), 1)
        if len(safe_name) > name_space:
            safe_name = safe_name[: max(name_space - 1, 1)] + "‚Ä¶"

        # Center the text within the available space and keep the arrow pinned right.
        if len(safe_name) < name_space:
            left_pad = (name_space - len(safe_name)) // 2
            right_pad = name_space - len(safe_name) - left_pad
        else:
            left_pad = right_pad = 0

        return f"{' ' * left_pad}{safe_name}{' ' * right_pad}{arrow}"

    def _position_exam_header_label(self):
        """Place the exam header label beside the plan dropdown."""
        if not hasattr(self, "exam_header_label") or not self.exam_header_label.winfo_exists():
            return
        if (
            not hasattr(self, "plan_display_btn")
            or not self.plan_display_btn.winfo_exists()
        ):
            return

        try:
            self.exam_header_label.lift()
            self.exam_header_label.pack(
                side="left",
                padx=(0, 8),
                before=self.plan_display_btn,
            )
        except Exception as e:
            print(f"[EXAM-UI] Failed to position exam header label: {e}")

    def _position_exam_countdown_label(self):
        """Position the remaining-time label on the tab row (centered)."""
        if (
            not hasattr(self, "exam_countdown_label")
            or not self.exam_countdown_label.winfo_exists()
        ):
            return
        if not hasattr(self, "notebook") or not self.notebook.winfo_ismapped():
            return

        try:
            self.exam_countdown_label.lift()
            self.exam_countdown_label.place(relx=0.5, y=-6, anchor="n")
        except Exception as e:
            print(f"[EXAM-UI] Failed to position countdown label: {e}")

    def _on_exam_header_click(self, event=None):
        """
        When user clicks the exam pill:
        - If only one exam exists, do nothing.
        - If many exams exist, show a small popup menu to switch exam.
        """
        # Current exam
        current_exam = getattr(self, "current_exam_name", "") or ""

        # All known exam names (from file + current profile)
        try:
            exam_names = get_all_exam_names()
        except Exception as e:
            print(f"[EXAM-UI] Failed to read exam names on click: {e}")
            exam_names = []

        if current_exam and current_exam not in exam_names:
            exam_names.append(current_exam)

        # Filter / sort for menu
        visible_exams = sorted({e for e in exam_names if e and e != "__GLOBAL__"})

        if len(visible_exams) <= 1:
            # Only one exam ‚Äì nothing to switch
            return

        # Build menu
        menu = tk.Menu(self, tearoff=0)
        for name in visible_exams:
            def _make_cmd(target=name):
                return lambda: self._switch_exam_via_header(current_exam, target)

            # Mark current exam visually
            label = name
            if name == current_exam:
                label = f"‚úì {name}"

            menu.add_command(label=label, command=_make_cmd())

        x_root = event.x_root if event is not None else self.exam_header_label.winfo_rootx()
        y_root = event.y_root if event is not None else (
            self.exam_header_label.winfo_rooty() + self.exam_header_label.winfo_height()
        )

        try:
            menu.tk_popup(x_root, y_root)
        finally:
            menu.grab_release()

    def _switch_exam_via_header(self, old_exam_name: str, new_exam_name: str):
        """
        Switch the preparing exam when user picks from the exam pill menu.
        - Updates profile.json exam_name
        - Calls handle_exam_name_change(old, new) to reuse existing logic
        - Refreshes the exam header pill text
        """
        new_exam_name = (new_exam_name or "").strip()
        old_exam_name = (old_exam_name or "").strip()

        if not new_exam_name or new_exam_name == old_exam_name:
            return

        print(f"[EXAM-UI] Header switch: '{old_exam_name}' -> '{new_exam_name}'")

        # Update profile first
        try:
            prof = _load_profile() or {}
            prof["exam_name"] = new_exam_name
            _save_profile(prof)
        except Exception as e:
            print(f"[EXAM-UI] Failed to update profile exam name: {e}")

        # Reuse existing exam-change logic
        try:
            if hasattr(self, "handle_exam_name_change"):
                self.handle_exam_name_change(old_exam_name, new_exam_name)
        except Exception as e:
            print(f"[EXAM-UI] handle_exam_name_change error: {e}")

        # Update in-memory exam date and countdown
        try:
            new_date = self._get_exam_date_for_current_exam()
            if new_date:
                self.progress_exam_date = new_date
                if hasattr(self, "recompute_required_rates"):
                    self.recompute_required_rates()
        except Exception as e:
            print(f"[EXAM-UI] Failed to refresh exam date on switch: {e}")

        try:
            self._init_exam_header_on_tabs()
        except Exception as e:
            print(f"[EXAM-UI] Failed to re-init exam header after switch: {e}")

        # Update pill text
        try:
            self._init_exam_header_on_tabs()
        except Exception as e:
            print(f"[EXAM-UI] Failed to re-init exam header after switch: {e}")
        
    def handle_exam_name_change(self, old_exam_name: str, new_exam_name: str):
        """
        Called by OnboardingWizard when the exam name changes.

        Behaviour:
        - Clear the CURRENT schedule in the Plan tab (session area).
        - Reload plans for the NEW exam from plans.json.
        - Update current_plan_name, dropdown, and treeview.
        - Show the 'create new plan' popup ONLY if the NEW exam does NOT
          already have any saved plans.

        NOTE:
        - Old exam's plans are NOT deleted; they stay in plans.json
          under the old exam name. When the user changes the exam name
          back to that value, those plans will be loaded again WITHOUT
          showing the popup.
        """
        from tkinter import TclError

        try:
            print(f"[EXAM] Exam name changed from '{old_exam_name}' to '{new_exam_name}'")

            # 0) Check if the NEW exam already has plans stored in plans.json
            try:
                # _load_plans_for_exam(exam_name) reads that exam's section directly
                existing_for_new_exam = _load_plans_for_exam(new_exam_name)
                had_plans_for_new_exam = bool(existing_for_new_exam)
                print(f"[EXAM] New exam '{new_exam_name}' had_plans_for_new_exam={had_plans_for_new_exam}")
            except Exception as e:
                print(f"[EXAM] Failed to inspect plans for new exam: {e}")
                existing_for_new_exam = {}
                had_plans_for_new_exam = False

            # 1) Clear current schedule in memory + today's custom schedule file
            try:
                self.schedule = []
                if 'save_schedule' in globals():
                    save_schedule(self.schedule)
            except Exception as e:
                print(f"[EXAM] Failed to clear/save current schedule: {e}")

            # 2) Reload plans for the new exam only
            try:
                # We already loaded them into existing_for_new_exam above
                self.plans = existing_for_new_exam or {}
            except Exception as e:
                print(f"[EXAM] Failed to load plans for new exam: {e}")
                self.plans = {}

            # 3) Decide which plan should be active for this exam
            if not self.plans:
                # No plans yet for this exam ‚Äì start fresh with an empty Default
                self.current_plan_name = "Default"
                self.plans = {self.current_plan_name: []}
                self.schedule = []
            else:
                # If current_plan_name isn't valid for this exam, pick a sensible one
                if not getattr(self, "current_plan_name", None) in self.plans:
                    if "Default" in self.plans:
                        self.current_plan_name = "Default"
                    else:
                        self.current_plan_name = sorted(self.plans.keys())[0]
                # Use that plan's sessions as the active schedule
                self.schedule = self.plans.get(self.current_plan_name, [])

            # 4) Reset any cached session-name list used for dropdowns / undo
            try:
                if hasattr(self, "plan_session_names"):
                    self.plan_session_names = []
            except Exception as e:
                print(f"[EXAM] Failed to reset plan_session_names: {e}")

            # 5) Update plan selector UI (plan_var + button text)
            try:
                if hasattr(self, "plan_var"):
                    self.plan_var.set(self.current_plan_name)
                if hasattr(self, "plan_display_btn"):
                    self.plan_display_btn.config(
                        text=self._format_plan_button_label(self.current_plan_name)
                    )
            except TclError as e:
                print(f"[EXAM] Failed to update plan selector UI: {e}")
            except Exception as e:
                print(f"[EXAM] Unexpected UI error: {e}")

            # 6) Refresh the Plan tab tree area
            #    (will show splash if schedule is empty; otherwise the sessions)
            try:
                if hasattr(self, "plan_tab") and self.plan_tab.winfo_exists():
                    self.refresh_plan_tree()
            except Exception as e:
                print(f"[EXAM] Failed to refresh plan tree after exam change: {e}")

            # 7) Show the "exam changed" popup ONLY if this exam had no plans yet
            if not had_plans_for_new_exam:
                self._show_exam_changed_popup(old_exam_name, new_exam_name)
                
            # Refresh header pill text as well
            try:
                self._init_exam_header_on_tabs()
            except Exception as e:
                print(f"[EXAM-UI] Failed to refresh exam header after change: {e}")

        except Exception as e:
            print(f"[EXAM] handle_exam_name_change() error: {e}")

    def _show_exam_changed_popup(self, old_exam_name: str, new_exam_name: str):
        """
        Small centered popup after exam name change:
        - Explains that previous exam sessions are cleared
        - Tells user they can get back by renaming to old exam name
        - Offers: Create with AI / Manual Create buttons
        """
        import tkinter as tk

        # Use the main app window as parent (StudyTimerApp is a Tk root)
        parent = self

        popup = tk.Toplevel(parent)
        popup.title("Exam Changed")
        popup.configure(bg="#f5f7fa")
        popup.resizable(False, False)
        popup.transient(parent)
        popup.grab_set()

        # Center over main window
        try:
            parent.update_idletasks()
            w, h = 460, 300
            x = parent.winfo_rootx() + (parent.winfo_width() - w) // 2
            y = parent.winfo_rooty() + (parent.winfo_height() - h) // 2
            popup.geometry(f"{w}x{h}+{x}+{y}")
        except Exception:
            popup.geometry("460x300")

        # --- Header ---
        header = tk.Frame(popup, bg="#4285f4", height=40)
        header.pack(fill="x")
        header.pack_propagate(False)

        tk.Label(
            header,
            text="You changed your exam",
            bg="#4285f4",
            fg="white",
            font=("Segoe UI", 11, "bold"),
        ).pack(side="left", padx=16)

        # --- Body ---
        body = tk.Frame(popup, bg="#f5f7fa")
        body.pack(fill="both", expand=True, padx=18, pady=14)

        if old_exam_name:
            main_msg = (
                f"You changed your preparing exam from ‚Äú{old_exam_name}‚Äù "
                f"to ‚Äú{new_exam_name or 'New Exam'}‚Äù."
            )
        else:
            main_msg = f"You're now preparing for ‚Äú{new_exam_name or 'New Exam'}‚Äù."

        tk.Label(
            body,
            text=main_msg,
            bg="#f5f7fa",
            fg="#222222",
            wraplength=420,
            justify="left",
            font=("Segoe UI", 10, "bold"),
        ).pack(anchor="w")

        tk.Label(
            body,
            text=(
                "All sessions related to your previous exam have been cleared from "
                "the Plan tab and session selection area.\n\n"
                "If you want them back, just change the exam name again to your "
                "previous exam name."
            ),
            bg="#f5f7fa",
            fg="#555555",
            wraplength=420,
            justify="left",
            font=("Segoe UI", 9),
        ).pack(anchor="w", pady=(6, 10))

        tk.Label(
            body,
            text="Now create your new session strategy for this exam:",
            bg="#f5f7fa",
            fg="#111111",
            wraplength=420,
            justify="left",
            font=("Segoe UI", 10),
        ).pack(anchor="w", pady=(0, 8))

        # --- Buttons row ---
        btn_row = tk.Frame(body, bg="#f5f7fa")
        btn_row.pack(pady=(4, 0))

        def _open_ai_then_close():
            popup.destroy()
            # ‚úÖ Hooked to your existing AI plan creator
            if hasattr(self, "_open_ai_plan_creation"):
                self._open_ai_plan_creation()

        def _open_manual_then_close():
            popup.destroy()
            # ‚úÖ Hooked to your existing manual plan creator
            if hasattr(self, "_open_manual_plan_creation"):
                self._open_manual_plan_creation()

        ai_btn = tk.Button(
            btn_row,
            text="‚ú® Create with AI",
            font=("Segoe UI", 10, "bold"),
            bg="#4CAF50",
            fg="white",
            bd=0,
            padx=16,
            pady=6,
            cursor="hand2",
            command=_open_ai_then_close,
        )
        ai_btn.grid(row=0, column=0, padx=(0, 8))

        manual_btn = tk.Button(
            btn_row,
            text="‚úç Manual Create",
            font=("Segoe UI", 10),
            bg="#e0e0e0",
            fg="#333333",
            bd=0,
            padx=16,
            pady=6,
            cursor="hand2",
            command=_open_manual_then_close,
        )
        manual_btn.grid(row=0, column=1, padx=(8, 0))

        # Optional "later" text-button at bottom right
        footer = tk.Frame(body, bg="#f5f7fa")
        footer.pack(fill="x", pady=(10, 0))

        later_btn = tk.Button(
            footer,
            text="I'll do this later",
            font=("Segoe UI", 9),
            bg="#ffffff",
            fg="#666666",
            bd=0,
            padx=8,
            pady=4,
            cursor="hand2",
            command=popup.destroy,
        )
        later_btn.pack(anchor="e")
        
    def _cleanup_empty_plan(self, plan_name):
        """Remove plan if it's empty and switch to another plan."""
        # Check if plan is empty
        if plan_name in self.plans and (not self.plans[plan_name] or len(self.plans[plan_name]) == 0):
            print(f"üóë Plan '{plan_name}' is empty - removing it")
            
            # Don't delete if it's the only plan
            if len(self.plans) <= 1:
                print("‚ö† Cannot delete - this is the only plan")
                from tkinter import messagebox
                messagebox.showinfo("Empty Plan", "This plan is empty, but it's the only plan.\n\nPlease add sessions or create a new plan.")
                return False
            
            # Delete the empty plan
            del self.plans[plan_name]
            save_all_plans(self.plans)
            
            # Switch to first available plan
            remaining_plans = list(self.plans.keys())
            next_plan = remaining_plans[0]
            
            print(f"‚úÖ Deleted empty plan. Switching to: {next_plan}")
            
            # Update UI
            self.plan_var.set(next_plan)
            self.current_plan_name = next_plan
            self.schedule = self.plans[next_plan]
            
            if hasattr(self, "plan_display_btn"):
                self.plan_display_btn.config(
                    text=self._format_plan_button_label(next_plan)
                )
            
            save_last_active_plan(next_plan)
            
            # Refresh UI
            self.refresh_plan_tree()
            
            from tkinter import messagebox
            messagebox.showinfo("Plan Deleted", f"Empty plan '{plan_name}' was automatically deleted.\n\nSwitched to: {next_plan}")
            
            return True
        
        return False
        
    def _check_day_change_on_startup(self):
        """Check if days have passed since last app use and update accordingly."""
        try:
            old_day = self._get_global_study_day()  # This will auto-update if days passed
            print(f"üìÖ App started on Global Day {old_day}")
        except Exception as e:
            print(f"‚ö†Ô∏è Error checking day on startup: {e}")
        
    def _show_plan_splash_in_tree_area(self):
        """Show splash screen ONLY in the treeview container"""
        
        # ‚úÖ Clear only the treeview container (not entire plan_tab)
        for widget in self.treeview_container.winfo_children():
            widget.destroy()
        
        # ‚úÖ Create splash INSIDE the container
        splash_frame = tk.Frame(self.treeview_container, bg="#f8f9fa")
        splash_frame.pack(fill=tk.BOTH, expand=True)
        
        # Centered card
        center_frame = tk.Frame(
            splash_frame, 
            bg="#ffffff", 
            relief=tk.SOLID,
            bd=1
        )
        center_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Inner padding frame
        inner_frame = tk.Frame(center_frame, bg="#ffffff", padx=50, pady=35)
        inner_frame.pack()
        
        # Icon
        icon_label = tk.Label(
            inner_frame,
            text="üìÖ",
            font=("Segoe UI Emoji", 50),
            bg="#ffffff"
        )
        icon_label.pack(pady=(0, 8))
        
        # Title
        title_label = tk.Label(
            inner_frame,
            text="No Study Plan Yet",
            font=("Segoe UI", 16, "bold"),
            bg="#ffffff",
            fg="#333333"
        )
        title_label.pack(pady=(0, 4))
        
        # Subtitle
        subtitle_label = tk.Label(
            inner_frame,
            text="Let AI create a personalized study plan!",
            font=("Segoe UI", 10),
            bg="#ffffff",
            fg="#666666"
        )
        subtitle_label.pack(pady=(0, 18))
        
        # AI Button
        ai_button = tk.Button(
            inner_frame,
            text="ü§ñ Create Plan with AI",
            font=("Segoe UI", 11, "bold"),
            bg="#5856d6",
            fg="white",
            activebackground="#4845b5",
            activeforeground="white",
            relief=tk.FLAT,
            cursor="hand2",
            padx=25,
            pady=10,
            command=self._open_ai_plan_creation
        )
        ai_button.pack(pady=(0, 6))
        
        # Hover effect
        def on_enter(e):
            ai_button.config(bg="#4845b5")
        def on_leave(e):
            ai_button.config(bg="#5856d6")
        
        ai_button.bind("<Enter>", on_enter)
        ai_button.bind("<Leave>", on_leave)
        
        # OR text
        or_label = tk.Label(
            inner_frame,
            text="or",
            font=("Segoe UI", 8),
            bg="#ffffff",
            fg="#999999"
        )
        or_label.pack(pady=(6, 6))
        
        # Manual creation
        manual_button = tk.Button(
            inner_frame,
            text="Create Manually",
            font=("Segoe UI", 9, "underline"),
            bg="#ffffff",
            fg="#5856d6",
            relief=tk.FLAT,
            cursor="hand2",
            borderwidth=0,
            command=self._open_manual_plan_creation
        )
        manual_button.pack()

    def _open_ai_plan_creation(self):
        """Open AI Chat Dialog directly in Plan Creation tab"""
        
        try:
            from ai_chat_dialog import AIChatDialog
            
            def on_plans_created():
                """Callback after plans are created"""
                try:
                    # ‚úÖ FIX: Use reload_plans_from_disk instead of load_all_plans
                    self.reload_plans_from_disk()
                    print("‚úÖ Plans reloaded!")
                except Exception as e:
                    print(f"‚ö† Reload error: {e}")
            
            # Create and open the dialog
            dialog = AIChatDialog(self, on_plans_updated=on_plans_created)
            
            # Switch to Plan Creation tab (second tab, index 1)
            dialog.notebook.select(1)
            
            # Wait for dialog to close
            self.wait_window(dialog)
            
        except ImportError as e:
            error_msg = (
                "Could not open AI chat dialog.\n\n"
                f"Error: {e}\n\n"
                "Please check:\n"
                "1. Is 'ai_chat_dialog.py' in the same folder?\n\n"
                "Looking in: E:\\studytimer\\"
            )
            messagebox.showerror("Import Error", error_msg)
            print(f"Import error: {e}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open AI chat: {e}")
            print(f"Error: {e}")
            import traceback
            traceback.print_exc()

    def _open_manual_plan_creation(self):
        """Open manual plan creation"""
        if hasattr(self, 'add_session'):
            self.add_session()
        else:
            messagebox.showinfo(
                "Manual Creation",
                "Use the toolbar above to add sessions manually!"
            )
        
    def _convert_latex_to_plain(self, text):
        """Convert LaTeX math to readable plain text."""
        import re
        
        # Convert inline math \( ... \) or $ ... $
        text = re.sub(r'\\\((.+?)\\\)', r'[\1]', text)
        text = re.sub(r'\$(.+?)\$', r'[\1]', text)
        
        # Convert display math \[ ... \] or $$ ... $$
        text = re.sub(r'\\\[(.+?)\\\]', r'\n[\1]\n', text, flags=re.DOTALL)
        text = re.sub(r'\$\$(.+?)\$\$', r'\n[\1]\n', text, flags=re.DOTALL)
        
        # Common LaTeX commands
        replacements = {
            r'\\frac\{([^}]+)\}\{([^}]+)\}': r'(\1)/(\2)',
            r'\\sqrt\{([^}]+)\}': r'‚àö(\1)',
            r'\\eta': 'Œ∑',
            r'\\alpha': 'Œ±',
            r'\\beta': 'Œ≤',
            r'\\gamma': 'Œ≥',
            r'\\delta': 'Œ¥',
            r'\\theta': 'Œ∏',
            r'\\pi': 'œÄ',
            r'\\sigma': 'œÉ',
            r'\\omega': 'œâ',
            r'\\times': '√ó',
            r'\\div': '√∑',
            r'\\cdot': '¬∑',
            r'\\Delta': 'Œî',
            r'\\Sigma': 'Œ£',
            r'\\rightarrow': '‚Üí',
            r'\\leftarrow': '‚Üê',
            r'\\approx': '‚âà',
            r'\\leq': '‚â§',
            r'\\geq': '‚â•',
            r'\\neq': '‚â†',
            r'\\infty': '‚àû',
            r'\\partial': '‚àÇ',
            r'\\nabla': '‚àá',
            r'\\_': '_',
            r'\\text\{([^}]+)\}': r'\1',
            r'\\\,': ' ',
            r'\\\\': '\n',
            r'\^(\d)': r'^\1',  # superscript
            r'_(\d)': r'_\1',   # subscript
        }
        
        for pattern, replacement in replacements.items():
            text = re.sub(pattern, replacement, text)
        
        # Remove remaining backslashes
        text = text.replace('\\', '')
        
        return text
        
    def show_purchase_dialog(self):
        """Open the token purchase dialog."""
        try:
            from purchase_dialog import show_purchase_dialog
            show_purchase_dialog(self)  # ‚úÖ CORRECT - pass 'self' not 'self.root'
            self.refresh_token_usage_display()
        except Exception as e:
            print(f"‚ö† Error opening purchase dialog: {e}")
            import traceback
            traceback.print_exc()
            from tkinter import messagebox
            messagebox.showerror("Error", "Could not open purchase dialog.")

    def check_ai_features_enabled(self):
        """Check if user has tokens to use AI features."""
        tm = get_token_manager()
        balance_info = tm.get_balance()
        return balance_info.get("balance", 0) > 0    
        
    def refresh_token_usage_display(self):
        """Refresh token usage display with latest stats."""
        print("üîÑ Token display refresh called")
        if hasattr(self, 'token_widget') and self.token_widget:
            try:
                from token_tracker import refresh_token_display
                # Schedule refresh in main thread
                self.after(0, lambda: refresh_token_display(self.token_widget))
            except Exception as e:
                print(f"‚ö† Token refresh error: {e}")
                import traceback
                traceback.print_exc()
        
    def on_ai_button_gpt4o(self):
        """Generate study plan using GPT-4o mini"""
        import threading
        from tkinter import messagebox
        from ai_gpt_planner import generate_study_plan_via_gpt4o_mini

        self.ai_btn.config(state="disabled")

        def worker():
            try:
                result = generate_study_plan_via_gpt4o_mini()
                self.after(0, lambda: messagebox.showinfo("AI Coach", result))
            except Exception as e:
                self.after(0, lambda: messagebox.showerror("AI Coach", f"Failed:\n{e}"))
            finally:
                self.after(0, lambda: self.ai_btn.config(state="normal"))

        threading.Thread(target=worker, daemon=True).start()

        
    def _on_dev_shortcut(self, event):
        print("[DEV] Shortcut pressed")
        self._dev_cleanup()    
        
    def _on_send_diagnostics(self, event=None):
        """Ctrl+Shift+S -> send a diagnostics snapshot to the Diagnostics sheet."""
        from datetime import datetime
        import os

        print("[DIAG] Sending diagnostics snapshot...")

        # 1) Load profile for UID / name / install_id
        try:
            user_profile = _load_profile()
        except Exception as e:
            print(f"[DIAG] Failed to load profile: {e}")
            user_profile = {}

        uid = user_profile.get("uid", "")
        user_name = user_profile.get("user_name", "")
        install_id = user_profile.get("install_id", "")

        # 2) Init variables
        license_valid = False
        license_message = ""
        trial_status = ""
        trial_message = ""
        days_remaining = ""

        offline_status = {
            "payment": False,
            "license": False,
            "payment_count": 0,
            "license_count": 0,
            "total_locations": 0,
        }

        # offline trial status summary (we‚Äôll fill later)
        trial_offline_status = {
            "trial_ok": None,
            "valid_trial_locations": 0,
            "any_trial_locations": 0,
            "total_locations": 0,
        }

        internet_available = False
        online_status = None
        online_error = ""
        self._last_location_details_for_diag = ""
        trial_location_details = ""

        # ---- LICENSE + OFFLINE/ONLINE SNAPSHOT ----
        try:
            if hasattr(self, "license_manager") and self.license_manager:
                # Uses your online-first comprehensive_validation
                license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
                offline_status = self.license_manager.check_offline_status(user_profile)
                internet_available = self.license_manager._check_internet()

                # License/payment per-location diagnostics summary
                try:
                    loc_diags = self.license_manager.get_location_diagnostics(user_profile)
                    summary_parts = []
                    for d in loc_diags:
                        part = (
                            f"[{d.get('index')}] {d.get('path')} | "
                            f"pay={d.get('payment_status')} | "
                            f"lic={d.get('license_status')}"
                        )
                        summary_parts.append(part)
                    self._last_location_details_for_diag = " || ".join(summary_parts)
                except Exception as e:
                    print(f"[DIAG] Error while building location details: {e}")
                    self._last_location_details_for_diag = ""

                # Online snapshot (best-effort)
                try:
                    self.license_manager._connect_unified_gsheet()
                    online_status = self.license_manager.check_online_status(user_profile)
                except Exception as oe:
                    online_error = str(oe)
        except Exception as e:
            print(f"[DIAG] Error while collecting license status: {e}")

        # ---- TRIAL SNAPSHOT (logic + offline + per-location) ----
        try:
            if hasattr(self, "trial_manager") and self.trial_manager:
                # Logical trial status
                trial_status, trial_message, days_remaining = self.trial_manager.validate_trial(user_profile)

                # Aggregate offline trial status
                try:
                    trial_offline_status = self.trial_manager.get_offline_trial_status(user_profile)
                except Exception as te:
                    print(f"[DIAG] Error while collecting offline trial status: {te}")
                    trial_offline_status = {
                        "trial_ok": None,
                        "valid_trial_locations": 0,
                        "any_trial_locations": 0,
                        "total_locations": 0,
                    }

                # üîπ Per-location TRIAL diagnostics string (this is the column you want)
                try:
                    trial_loc_diags = self.trial_manager.get_trial_location_diagnostics(user_profile)
                    t_parts = []
                    for d in trial_loc_diags:
                        t_parts.append(
                            f"[{d.get('index')}] {d.get('path')} | trial={d.get('trial_status')}"
                        )
                    trial_location_details = " || ".join(t_parts)
                except Exception as te2:
                    print(f"[DIAG] Error while building trial location details: {te2}")
                    trial_location_details = ""
        except Exception as e:
            print(f"[DIAG] Error while collecting trial status: {e}")

        # 3) Determine which locations are missing any LICENSE files (simple flag)
        failed_locations = []
        try:
            if hasattr(self, "license_manager") and self.license_manager:
                for loc in getattr(self.license_manager, "storage_locations", []):
                    payment_path = os.path.join(loc, "payment_status.json")
                    license_path = os.path.join(loc, "app_license.dat")
                    if (not os.path.exists(payment_path)) or (not os.path.exists(license_path)):
                        failed_locations.append(loc)
        except Exception as e:
            print(f"[DIAG] Error while checking locations: {e}")

        # 4) Build diagnostics dict
        diagnostics = {
            # USER INFO
            "timestamp": datetime.now().isoformat(timespec="seconds"),
            "uid": uid,
            "user_name": user_name,
            "install_id": install_id,
            "machine_id": getattr(self.license_manager, "machine_id", "") if hasattr(self, "license_manager") else "",

            # TRIAL (logic + offline + locations)
            "trial_status": trial_status,
            "trial_message": trial_message,
            "trial_days_remaining": days_remaining,
            "offline_trial_ok": trial_offline_status.get("trial_ok"),
            "offline_trial_valid_locations": trial_offline_status.get("valid_trial_locations"),
            "offline_trial_any_locations": trial_offline_status.get("any_trial_locations"),
            "offline_trial_total_locations": trial_offline_status.get("total_locations"),
            "trial_location_details": trial_location_details,

            # LICENSE / PAYMENT (logic + offline + online + locations)
            "license_valid": license_valid,
            "license_message": license_message,
            "internet_available": internet_available,
            "offline_payment_ok": offline_status.get("payment"),
            "offline_license_ok": offline_status.get("license"),
            "offline_payment_count": offline_status.get("payment_count"),
            "offline_license_count": offline_status.get("license_count"),
            "offline_total_locations": offline_status.get("total_locations"),
            "online_status_payment": online_status.get("payment") if isinstance(online_status, dict) else "",
            "online_status_license": online_status.get("license") if isinstance(online_status, dict) else "",
            "online_status_error": online_error or (online_status.get("error") if isinstance(online_status, dict) else ""),
            "location_details": getattr(self, "_last_location_details_for_diag", ""),
        }

        # 5) Send to Diagnostics sheet via UnifiedLicenseManager
        success = False
        try:
            if hasattr(self, "license_manager") and self.license_manager:
                success = self.license_manager.append_diagnostics(user_profile, diagnostics)
        except Exception as e:
            print(f"[DIAG] Failed to append diagnostics: {e}")
            success = False

        # 6) Notify user
        try:
            if success:
                messagebox.showinfo(
                    "Diagnostics Sent",
                    "A diagnostics snapshot has been sent to the developer.\n"
                    "You can now contact support and mention your UID or Install ID."
                )
            else:
                messagebox.showwarning(
                    "Diagnostics Failed",
                    "Unable to send diagnostics snapshot.\n"
                    "Please check your internet connection and try again."
                )
        except Exception:
            pass

        print(f"[DIAG] Diagnostics send result: {success}")   
        
    def show_plan_menu(self):
        """Show plan menu with individual submenus per plan."""
        import tkinter as tk
        
        # Create main menu
        menu = tk.Menu(self.plan_display_btn, tearoff=0)
        
        # Store reference to submenus
        self._plan_submenus = {}
        
        for plan_name in sorted(self.plans.keys()):
            # Create a frame-based approach won't work, so use radiobutton trick
            submenu = tk.Menu(menu, tearoff=0)
            
            # Add switch option
            submenu.add_command(
                label=f"‚Üí Switch to {plan_name}",
                command=lambda p=plan_name: self.quick_switch_plan(p),
                font=("Segoe UI", 9, "bold")
            )
            submenu.add_separator()
            
            # Rename option
            if plan_name == "Default":
                submenu.add_command(label="‚úè Rename", state="disabled")
            else:
                submenu.add_command(
                    label="‚úè Rename",
                    command=lambda p=plan_name: self.quick_rename(p)
                )
            
            # Delete option
            if plan_name == "Default" or len(self.plans) <= 1:
                submenu.add_command(label="üóë Delete", state="disabled")
            else:
                submenu.add_command(
                    label="üóë Delete",
                    command=lambda p=plan_name: self.quick_delete(p)
                )
            
            self._plan_submenus[plan_name] = submenu
            
            # Add to main menu
            if plan_name == self.current_plan_name:
                menu.add_cascade(label=f"‚óè {plan_name}", menu=submenu)
            else:
                menu.add_cascade(label=f"   {plan_name}", menu=submenu)
        
        # Show menu
        try:
            x = self.plan_display_btn.winfo_rootx()
            y = self.plan_display_btn.winfo_rooty() + self.plan_display_btn.winfo_height()
            menu.tk_popup(x, y)
        finally:
            menu.grab_release()

    def quick_switch_plan(self, plan_name):
        """Switch to selected plan from menu."""
        # Validate plan exists
        if plan_name not in self.plans:
            print(f"‚ùå Plan '{plan_name}' not found!")
            return
        
        # ‚úÖ Check if plan is empty - cleanup instead of switching
        if not self.plans[plan_name] or len(self.plans[plan_name]) == 0:
            print(f"‚ö† Plan '{plan_name}' is empty - cleaning up")
            self._cleanup_empty_plan(plan_name)
            return
        
        # ‚úÖ STEP 1: SAVE current plan's data BEFORE changing anything
        old_plan_name = self.current_plan_name
        try:
            set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=old_plan_name)
            print(f"‚úÖ Saved {self.today_study_stopwatch_seconds}s for old plan '{old_plan_name}'")
        except Exception as e:
            print(f"‚ö† Error saving before switch: {e}")
        
        # ‚úÖ STEP 2: UPDATE to new plan
        self.plan_var.set(plan_name)
        self.plan_display_btn.config(
            text=self._format_plan_button_label(plan_name)
        )
        self.current_plan_name = plan_name
        self.schedule = self.plans[plan_name]
        save_last_active_plan(plan_name)
        
        # ‚úÖ NEW: Recalculate goal from new plan's schedule
        try:
            self._calculate_goal_from_schedule()
            print("‚úÖ Goal duration updated for new plan")
            
            # ‚úÖ Refresh required rates (short/long term labels)
            if hasattr(self, 'recompute_required_rates'):
                self.recompute_required_rates()
                print("‚úÖ Required rates refreshed")
                
        except Exception as e:
            print(f"‚ö† Error updating goal: {e}")
        
        # ‚úÖ STEP 3: LOAD new plan's data
        try:
            loaded_seconds = get_today_studied_elapsed(plan_name=self.current_plan_name)
            self.today_study_stopwatch_seconds = loaded_seconds
            print(f"‚úÖ Loaded {loaded_seconds}s for new plan '{self.current_plan_name}'")
        except Exception as e:
            print(f"‚ö† Error loading new plan time: {e}")
            self.today_study_stopwatch_seconds = 0
        
        # ‚úÖ STEP 4: Refresh all UI elements
        try:
            self.refresh_plan_tree()
        except Exception as e:
            print(f"‚ö† Error refreshing plan tree: {e}")
        
        try:
            self.refresh_wastage()
        except Exception as e:
            print(f"‚ö† Error refreshing wastage: {e}")
        
        # Update Live tab display
        try:
            idx, st_dt, en_dt = get_active_session_idx(self.schedule)
            if idx is not None:
                self.display_session(idx)
            else:
                self.display_no_active_session()
            print("‚úÖ Live tab updated")
        except Exception as e:
            print(f"‚ö† Error updating live tab: {e}")
        
        # Update RunRate graph
        try:
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                exam_date = self._load_exam_date() if hasattr(self, '_load_exam_date') else None
                self.runrate_graph.refresh_for_new_plan(plan_name, self.schedule, exam_date)
                print("‚úÖ RunRate graph refreshed")
        except Exception as e:
            print(f"‚ö† Error refreshing runrate graph: {e}")
        
        # Update time labels (plan-specific)
        try:
            if hasattr(self, "today_study_label"):
                self.today_study_label.config(
                    text=f"Today Studied: {hhmmss_from_seconds(int(self.today_study_stopwatch_seconds))}"
                )
            print("‚úÖ Today studied label updated")
        except Exception as e:
            print(f"‚ö† Error updating today label: {e}")
        
        # Update total studied label (all plans)
        try:
            self._update_total_study_label_live()
            print("‚úÖ Total studied label updated")
        except Exception as e:
            print(f"‚ö† Error updating total label: {e}")
        
        # Update progress bar (plan-specific)
        try:
            self.update_progress_bar(live_today_seconds=int(self.today_study_stopwatch_seconds))
            print("‚úÖ Progress bar refreshed")
        except Exception as e:
            print(f"‚ö† Error refreshing progress bar: {e}")
        
        print(f"‚úÖ Successfully switched from '{old_plan_name}' to '{plan_name}'")
              

    def show_plan_menu(self):
        """Show plan menu with individual submenus per plan."""
        import tkinter as tk
        
        # Create main menu
        menu = tk.Menu(self.plan_display_btn, tearoff=0)
        
        # Store reference to submenus
        self._plan_submenus = {}
        
        # ‚úÖ Filter out empty plans before showing menu
        valid_plans = {name: plan for name, plan in self.plans.items() 
                       if plan and len(plan) > 0}
        
        # If no valid plans, show message
        if not valid_plans:
            menu.add_command(label="No plans available", state="disabled")
            menu.add_separator()
            menu.add_command(
                label="üì• Import Plan",
                command=self.import_plan,
                font=("Segoe UI", 9, "bold")
            )
            try:
                x = self.plan_display_btn.winfo_rootx()
                y = self.plan_display_btn.winfo_rooty() + self.plan_display_btn.winfo_height()
                menu.tk_popup(x, y)
            finally:
                menu.grab_release()
            return
        
        for plan_name in sorted(self.plans.keys()):
            # Create submenu for each plan
            submenu = tk.Menu(menu, tearoff=0)
            
            # Add switch option
            submenu.add_command(
                label=f"‚Üí Switch to {plan_name}",
                command=lambda p=plan_name: self.quick_switch_plan(p),
                font=("Segoe UI", 9, "bold")
            )
            submenu.add_separator()
            
            # üÜï EXPORT SUBMENU
            export_submenu = tk.Menu(submenu, tearoff=0)
            export_submenu.add_command(
                label="üíæ Save Locally",
                command=lambda p=plan_name: self.export_plan_local(p)
            )
            export_submenu.add_command(
                label="üì± Send to Telegram",
                command=lambda p=plan_name: self.export_plan_telegram(p)
            )
            submenu.add_cascade(label="üì§ Export", menu=export_submenu)
            
            submenu.add_separator()
            
            # Rename option
            if plan_name == "Default":
                submenu.add_command(label="‚úè Rename", state="disabled")
            else:
                submenu.add_command(
                    label="‚úè Rename",
                    command=lambda p=plan_name: self.quick_rename(p)
                )
            
            # Delete option
            if plan_name == "Default" or len(self.plans) <= 1:
                submenu.add_command(label="üóë Delete", state="disabled")
            else:
                submenu.add_command(
                    label="üóë Delete",
                    command=lambda p=plan_name: self.quick_delete(p)
                )
            
            self._plan_submenus[plan_name] = submenu
            
            # Add to main menu
            if plan_name == self.current_plan_name:
                menu.add_cascade(label=f"‚óè {plan_name}", menu=submenu)
            else:
                menu.add_cascade(label=f"   {plan_name}", menu=submenu)
        
        # üÜï ADD IMPORT OPTION AT THE BOTTOM
        menu.add_separator()
        menu.add_command(
            label="üì• Import Plan",
            command=self.import_plan,
            font=("Segoe UI", 9, "bold")
        )
        
        # Show menu
        try:
            x = self.plan_display_btn.winfo_rootx()
            y = self.plan_display_btn.winfo_rooty() + self.plan_display_btn.winfo_height()
            menu.tk_popup(x, y)
        finally:
            menu.grab_release()


    # üÜï EXPORT PLAN - SAVE LOCALLY
    def export_plan_local(self, plan_name):
        """Export a plan to a JSON file on the local system."""
        from tkinter import filedialog, messagebox
        import json
        from datetime import datetime
        
        if plan_name not in self.plans:
            messagebox.showerror("Export Error", f"Plan '{plan_name}' not found.")
            return
        
        # Ask user where to save
        default_filename = f"{plan_name}_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        filepath = filedialog.asksaveasfilename(
            title=f"Export Plan: {plan_name}",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialfile=default_filename
        )
        
        if not filepath:
            return  # User cancelled
        
        try:
            # Create export data
            export_data = {
                "plan_name": plan_name,
                "exported_at": datetime.now().isoformat(),
                "sessions": self.plans[plan_name],
                "version": "1.0"
            }
            
            # Save to file
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            messagebox.showinfo(
                "Export Successful",
                f"‚úÖ Plan '{plan_name}' exported successfully!\n\n"
                f"üìÅ Location: {filepath}\n"
                f"üìä Sessions: {len(self.plans[plan_name])}"
            )
            
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export plan:\n{e}")

    # üÜï EXPORT PLAN - SEND TO TELEGRAM (Auto-credentials)
    def export_plan_telegram(self, plan_name):
        """Send plan as JSON file to Telegram using stored credentials."""
        from tkinter import messagebox
        import json
        import requests
        from datetime import datetime
        import tempfile
        import os
        from pathlib import Path
        from config_paths import app_paths
        
        if plan_name not in self.plans:
            messagebox.showerror("Export Error", f"Plan '{plan_name}' not found.")
            return
        
        try:
            # üîê Get credentials from secrets and profile
            from secrets_util import get_secret
            
            bot_token = get_secret("TELEGRAM_BOT_TOKEN")
            if not bot_token:
                messagebox.showerror("Error", "TELEGRAM_BOT_TOKEN not found in secrets!")
                return
            
            profile_file = Path(app_paths.appdata_dir) / "profile.json"
            if profile_file.exists():
                profile = json.loads(profile_file.read_text(encoding="utf-8"))
                chat_id = profile.get("telegram_chat_id", "")
            else:
                chat_id = ""
            
            if not chat_id:
                messagebox.showerror("Error", "telegram_chat_id not found in profile.json!")
                return
            
            # Show sending indicator
            # Create a simple progress popup
            progress_popup = tk.Toplevel(self)
            progress_popup.title("Sending to Telegram")
            progress_popup.geometry("350x120")
            progress_popup.resizable(False, False)
            progress_popup.transient(self)
            progress_popup.grab_set()
            
            # Center popup
            progress_popup.update_idletasks()
            x = (progress_popup.winfo_screenwidth() // 2) - 175
            y = (progress_popup.winfo_screenheight() // 2) - 60
            progress_popup.geometry(f"350x120+{x}+{y}")
            
            progress_popup.configure(bg="#f8f9fa")
            
            tk.Label(
                progress_popup,
                text="üì§ Sending to Telegram...",
                font=("Segoe UI", 12, "bold"),
                bg="#f8f9fa",
                fg="#2c3e50"
            ).pack(pady=20)
            
            status_label = tk.Label(
                progress_popup,
                text=f"Plan: {plan_name}",
                font=("Segoe UI", 10),
                bg="#f8f9fa",
                fg="#7f8c8d"
            )
            status_label.pack()
            
            progress_popup.update()
            
            # Create export data
            export_data = {
                "plan_name": plan_name,
                "exported_at": datetime.now().isoformat(),
                "sessions": self.plans[plan_name],
                "session_count": len(self.plans[plan_name]),
                "version": "1.0"
            }
            
            # Create temporary JSON file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{plan_name}_backup_{timestamp}.json"
            temp_file = tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.json',
                delete=False,
                encoding='utf-8'
            )
            json.dump(export_data, temp_file, indent=2, ensure_ascii=False)
            temp_file.close()
            
            print(f"üìÑ Created temporary file: {temp_file.name}")
            
            # Send to Telegram in background thread
            def send_worker():
                try:
                    url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
                    
                    with open(temp_file.name, 'rb') as f:
                        files = {'document': (filename, f, 'application/json')}
                        data = {
                            'chat_id': chat_id,
                            'caption': (
                                f"üìö Study Plan Backup\n\n"
                                f"üìã Plan: {plan_name}\n"
                                f"üìä Sessions: {len(self.plans[plan_name])}\n"
                                f"üìÖ Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                            )
                        }
                        
                        print(f"üì§ Sending to Telegram (Chat ID: {chat_id})...")
                        response = requests.post(url, files=files, data=data, timeout=30)
                    
                    # Clean up temp file
                    if os.path.exists(temp_file.name):
                        os.unlink(temp_file.name)
                        print(f"üóë Deleted temporary file")
                    
                    # Close progress popup and show result
                    self.after(0, lambda: progress_popup.grab_release())
                    self.after(0, lambda: progress_popup.destroy())
                    
                    if response.status_code == 200:
                        print("‚úÖ Sent successfully!")
                        self.after(0, lambda: messagebox.showinfo(
                            "Success",
                            f"‚úÖ Plan '{plan_name}' sent to Telegram!\n\n"
                            f"üìä Sessions: {len(self.plans[plan_name])}\n"
                            f"üì± Check your Telegram for the backup file."
                        ))
                    else:
                        error_msg = response.json().get('description', 'Unknown error')
                        print(f"‚ùå Failed: {error_msg}")
                        self.after(0, lambda: messagebox.showerror(
                            "Telegram Error",
                            f"Failed to send to Telegram:\n\n{error_msg}"
                        ))
                        
                except requests.exceptions.RequestException as e:
                    print(f"‚ùå Network error: {e}")
                    self.after(0, lambda: progress_popup.grab_release())
                    self.after(0, lambda: progress_popup.destroy())
                    self.after(0, lambda: messagebox.showerror(
                        "Network Error",
                        f"Failed to connect to Telegram:\n\n{str(e)}"
                    ))
                except Exception as e:
                    print(f"‚ùå Telegram error: {e}")
                    import traceback
                    traceback.print_exc()
                    
                    self.after(0, lambda: progress_popup.grab_release())
                    self.after(0, lambda: progress_popup.destroy())
                    self.after(0, lambda: messagebox.showerror(
                        "Error",
                        f"Failed to send to Telegram:\n\n{str(e)}"
                    ))
            
            # Start sending in background
            import threading
            threading.Thread(target=send_worker, daemon=True).start()
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to prepare Telegram export:\n{e}")
            import traceback
            traceback.print_exc()

    # üÜï IMPORT PLAN
    def import_plan(self):
        """Import a plan from a JSON file."""
        from tkinter import filedialog, messagebox
        import json
        
        # Ask user to select file
        filepath = filedialog.askopenfilename(
            title="Import Plan",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if not filepath:
            return  # User cancelled
        
        try:
            # Read the file
            with open(filepath, "r", encoding="utf-8") as f:
                import_data = json.load(f)
            
            # Validate structure
            if "plan_name" not in import_data or "sessions" not in import_data:
                messagebox.showerror(
                    "Invalid File",
                    "This file does not appear to be a valid plan export.\n\n"
                    "Required fields: 'plan_name', 'sessions'"
                )
                return
            
            plan_name = import_data["plan_name"]
            sessions = import_data["sessions"]
            
            # Check if plan already exists
            if plan_name in self.plans:
                response = messagebox.askyesnocancel(
                    "Plan Already Exists",
                    f"A plan named '{plan_name}' already exists.\n\n"
                    f"‚Ä¢ Yes: Overwrite existing plan\n"
                    f"‚Ä¢ No: Import with new name\n"
                    f"‚Ä¢ Cancel: Abort import"
                )
                
                if response is None:  # Cancel
                    return
                elif response is False:  # Import with new name
                    # Ask for new name
                    new_name = simpledialog.askstring(
                        "New Plan Name",
                        f"Enter a new name for the imported plan:",
                        initialvalue=f"{plan_name}_imported"
                    )
                    
                    if not new_name or not new_name.strip():
                        return
                    
                    plan_name = new_name.strip()
                    
                    # Check again if new name exists
                    counter = 1
                    original_name = plan_name
                    while plan_name in self.plans:
                        plan_name = f"{original_name}_{counter}"
                        counter += 1
            
            # Import the plan
            self.plans[plan_name] = sessions
            save_all_plans(self.plans)
            
            # Switch to imported plan
            self.plan_var.set(plan_name)
            self.current_plan_name = plan_name
            self.schedule = sessions
            save_last_active_plan(plan_name)
            self.plan_display_btn.config(
                text=self._format_plan_button_label(plan_name)
            )
            
            # Refresh UI
            self.refresh_plan_tree()
            try:
                self.refresh_wastage()
            except Exception as e:
                print(f"Error refreshing wastage: {e}")
            
            messagebox.showinfo(
                "Import Successful",
                f"‚úÖ Plan imported successfully!\n\n"
                f"üìö Plan Name: {plan_name}\n"
                f"üìä Sessions: {len(sessions)}\n"
                f"üìÖ Exported: {import_data.get('exported_at', 'Unknown')}"
            )
            
        except json.JSONDecodeError:
            messagebox.showerror("Invalid File", "The selected file is not a valid JSON file.")
        except Exception as e:
            messagebox.showerror("Import Error", f"Failed to import plan:\n{e}")

    def quick_rename(self, plan_name):
        """Rename plan from menu."""
        import tkinter as tk
        from tkinter import messagebox
        
        old_name = plan_name
        
        if not old_name:
            messagebox.showwarning("No Plan Selected", "Please select a plan to rename.")
            return
        
        if old_name == "Default":
            messagebox.showwarning("Cannot Rename", "The 'Default' plan cannot be renamed.")
            return
        
        # Create rename popup
        popup = tk.Toplevel(self)
        popup.title("Rename Plan")
        popup.geometry("420x250")
        popup.resizable(False, False)
        popup.transient(self)
        popup.grab_set()
        
        # Center on screen
        popup.update_idletasks()
        x = (popup.winfo_screenwidth() // 2) - 210
        y = (popup.winfo_screenheight() // 2) - 110
        popup.geometry(f"420x250+{x}+{y}")
        
        # Styling
        BG_COLOR = "#f8f9fa"
        TEXT_DARK = "#2c3e50"
        SUCCESS_COLOR = "#27ae60"
        
        popup.configure(bg=BG_COLOR)
        
        main_frame = tk.Frame(popup, bg=BG_COLOR)
        main_frame.pack(fill="both", expand=True, padx=20, pady=15)
        
        # Header
        tk.Label(main_frame, 
                 text=f"üìù Rename Plan",
                 font=("Segoe UI", 13, "bold"),
                 bg=BG_COLOR, fg=TEXT_DARK).pack(pady=(0, 5))
        
        tk.Label(main_frame, 
                 text=f"Current: {old_name}",
                 font=("Segoe UI", 9),
                 bg=BG_COLOR, fg="#7f8c8d").pack(pady=(0, 15))
        
        # Input
        tk.Label(main_frame, 
                 text="New Plan Name:",
                 font=("Segoe UI", 10, "bold"),
                 bg=BG_COLOR, fg=TEXT_DARK).pack(anchor="w", pady=(0, 5))
        
        new_name_var = tk.StringVar(value=old_name)
        name_entry = tk.Entry(main_frame, 
                             textvariable=new_name_var,
                             font=("Segoe UI", 11),
                             width=40,
                             relief="solid", bd=1)
        name_entry.pack(ipady=5, pady=(0, 5))
        name_entry.select_range(0, tk.END)
        name_entry.focus_set()
        
        validation_label = tk.Label(main_frame, text="", font=("Segoe UI", 8), bg=BG_COLOR, fg="#e74c3c")
        validation_label.pack(pady=(0, 10))
        
        def validate_name(*args):
            name = new_name_var.get().strip()
            if not name:
                validation_label.config(text="")
                return False
            elif name == old_name:
                validation_label.config(text="")
                return True
            elif name in self.plans:
                validation_label.config(text="‚ö† Plan name already exists")
                return False
            elif len(name) > 50:
                validation_label.config(text="‚ö† Plan name too long (max 50 characters)")
                return False
            else:
                validation_label.config(text="‚úì Valid plan name", fg=SUCCESS_COLOR)
                return True
        
        new_name_var.trace('w', validate_name)
        
        def on_rename():
            new_name = new_name_var.get().strip()
            
            if not new_name:
                validation_label.config(text="‚ö† Please enter a plan name", fg="#e74c3c")
                return
            
            if new_name == old_name:
                popup.grab_release()
                popup.destroy()
                return
            
            if new_name in self.plans:
                validation_label.config(text="‚ö† Plan name already exists", fg="#e74c3c")
                return
            
            if len(new_name) > 50:
                validation_label.config(text="‚ö† Plan name too long", fg="#e74c3c")
                return
            
            # Rename the plan
            self.plans[new_name] = self.plans.pop(old_name)
            save_all_plans(self.plans)
            
            # Update current plan name if it was the active one
            if self.current_plan_name == old_name:
                self.current_plan_name = new_name
                save_last_active_plan(new_name)
                self.plan_display_btn.config(
                    text=self._format_plan_button_label(new_name)
                )
            
            # Rename plan in wastage files
            self._rename_plan_in_wastage_files(old_name, new_name)
            
           
            popup.grab_release()
            popup.destroy()
        
        def on_cancel():
            popup.grab_release()
            popup.destroy()
        
        # Buttons
        button_frame = tk.Frame(main_frame, bg=BG_COLOR)
        button_frame.pack(fill="x", pady=(10, 0))
        
        cancel_btn = tk.Button(button_frame, text="Cancel", command=on_cancel,
                              font=("Segoe UI", 10), bg="#ecf0f1", fg=TEXT_DARK,
                              relief="flat", padx=20, pady=8, cursor="hand2")
        cancel_btn.pack(side="left", padx=(0, 10))
        
        rename_btn = tk.Button(button_frame, text="‚úì Rename", command=on_rename,
                      font=("Segoe UI", 10, "bold"), bg=SUCCESS_COLOR, fg="white",
                      relief="flat", padx=30, pady=8, cursor="hand2", width=10)
        rename_btn.pack(side="right")
        
        name_entry.bind('<Return>', lambda e: on_rename())
        popup.bind('<Escape>', lambda e: on_cancel())

    def quick_delete(self, plan_name):
        """Delete plan from menu."""
        from tkinter import messagebox
        
        if not plan_name:
            messagebox.showwarning("No Plan Selected", "Please select a plan to delete.")
            return
        
        if plan_name == "Default":
            messagebox.showwarning("Cannot Delete", "The 'Default' plan cannot be deleted.")
            return
        
        if len(self.plans) <= 1:
            messagebox.showwarning("Cannot Delete", "You must have at least one plan. Cannot delete the last plan.")
            return
        
        # Confirm deletion
        response = messagebox.askyesno(
            "Confirm Deletion",
            f"Are you sure you want to delete the plan '{plan_name}'?\n\n"
            f"‚ö† This will permanently delete:\n"
            f"‚Ä¢ All sessions in this plan\n"            
            f"This action cannot be undone!",
            icon='warning'
        )
        
        if not response:
            return
        
        # Delete the plan
        del self.plans[plan_name]
        save_all_plans(self.plans)
        
       
        # Switch to Default plan
        self.current_plan_name = "Default"
        save_last_active_plan("Default")
        self.schedule = self.plans["Default"]
        self.plan_display_btn.config(
            text=self._format_plan_button_label("Default")
        )
        
        # Refresh UI
        self.refresh_plan_tree()
        try:
            self.refresh_wastage()
        except Exception as e:
            print(f"Error refreshing wastage after plan deletion: {e}")
        
       

    def _rename_plan_in_wastage_files(self, old_name, new_name):
        """Rename plan in wastage log and wastage day summary."""
        try:
            # Update wastage log CSV
            load_wastage_log()
            for entry in wastage_log:
                if entry.get("Plan", "Default") == old_name:
                    entry["Plan"] = new_name
            save_wastage_log()
            
            # Update wastage day summary JSON
            if os.path.exists(WASTAGE_DAY_FILE):
                with open(WASTAGE_DAY_FILE, "r") as f:
                    all_summaries = json.load(f)
                
                if old_name in all_summaries:
                    all_summaries[new_name] = all_summaries.pop(old_name)
                
                with open(WASTAGE_DAY_FILE, "w") as f:
                    json.dump(all_summaries, f, indent=2)
            
            print(f"[RENAME] Updated wastage data from '{old_name}' to '{new_name}'")
        except Exception as e:
            print(f"Error renaming plan in wastage files: {e}")

    def _delete_plan_wastage_data(self, plan_name):
        """Delete all wastage data for a specific plan."""
        try:
            # Remove from wastage log CSV
            load_wastage_log()
            wastage_log[:] = [entry for entry in wastage_log if entry.get("Plan", "Default") != plan_name]
            save_wastage_log()
            
            # Remove from wastage day summary JSON
            if os.path.exists(WASTAGE_DAY_FILE):
                with open(WASTAGE_DAY_FILE, "r") as f:
                    all_summaries = json.load(f)
                
                if plan_name in all_summaries:
                    del all_summaries[plan_name]
                
                with open(WASTAGE_DAY_FILE, "w") as f:
                    json.dump(all_summaries, f, indent=2)
            
            print(f"[DELETE] Removed all wastage data for plan '{plan_name}'")
        except Exception as e:
            print(f"Error deleting plan wastage data: {e}")
        
    def _check_initial_trial_status(self):
        """Check trial status when app starts"""
        try:
            user_profile = _load_profile()
            
            if not user_profile:
                return
            
            # Check if trial manager exists
            if not hasattr(self, 'trial_manager'):
                return
            
            # Check trial status
            trial_status, message, days = self.trial_manager.validate_trial(user_profile)
            
            print(f"[INIT] Initial trial status: {trial_status}")
            
            # Check license status
            license_valid = False
            if hasattr(self, 'license_manager'):
                try:
                    license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
                except:
                    pass
            
            # If trial expired or tampered AND no license, hide features
            if (trial_status in ['expired', 'tampered']) and not license_valid:
                print(f"[INIT] Trial {trial_status} and no license - hiding features immediately")
                
                self.hide_title_bar_for_non_premium()
                self.disable_communication_features_for_non_premium()
                self.hide_live_tab_elements_for_non_premium()
                
                # Don't show popup yet - let validation flow handle it
                
        except Exception as e:
            print(f"[INIT] Error checking initial trial status: {e}")
            import traceback
            traceback.print_exc()
        
    def _check_initial_tampered_state(self):
        """Check if user is tampered on app start and hide features immediately"""
        try:
            user_profile = _load_profile()
            
            if user_profile.get('trial_tampered'):
                print("[INIT] User is flagged as tampered - hiding features immediately")
                
                # Hide all premium features
                self.hide_title_bar_for_non_premium()
                self.disable_communication_features_for_non_premium()
                self.hide_live_tab_elements_for_non_premium()
                
                print("[INIT] Features hidden for tampered user")
        except Exception as e:
            print(f"[INIT] Error checking tampered state: {e}")
        
    def _show_payment_wizard_no_skip(self):
        """Show payment wizard without skip button (for tampered users)"""
        try:
            from tkinter import messagebox
            
            # Create payment wizard with no skip option
            wizard = PaymentWizard(self, self.license_manager, allow_skip=False)
            
            # Make it impossible to close without payment
            wizard.protocol("WM_DELETE_WINDOW", lambda: None)
            
            self.wait_window(wizard)
            
            # After wizard closes, verify payment
            user_profile = _load_profile()
            valid, message = self.license_manager.comprehensive_validation(user_profile)
            
            if valid:
                # Payment successful - clear tampered flag
                user_profile['trial_tampered'] = False
                _save_profile(user_profile)
                print("[VALIDATION] Payment successful - tamper flag cleared")
                
                # Show features and continue
                self._validation_completed = True
                self._start_periodic_validation()
                
                messagebox.showinfo("Success", "Payment verified! You now have full access.")
            else:
                # Still not paid - exit app
                print("[VALIDATION] Payment not completed - exiting")
                messagebox.showerror("Payment Required", 
                    "You must complete payment to use this app.")
                self._force_exit()
                
        except Exception as e:
            print(f"[VALIDATION] Wizard error: {e}")
            import traceback
            traceback.print_exc()
            self._force_exit()
        
    def _dev_cleanup(self):
        print("[DEV] Triggered dev cleanup")
        try:
            if hasattr(self, 'trial_manager'):
                from tkinter import messagebox
                if messagebox.askyesno("DEV", "Delete ALL trial data?"):
                    self.trial_manager.dev_nuclear_cleanup()
                    messagebox.showinfo("DEV", "Done. Restart app.")
        except Exception as e:
            print(f"[DEV] Cleanup popup error: {e}")
               
    def backup_all_files_background(self):
        """Background cloud backup - runs in separate thread"""
        try:
            print("[BACKUP-BG] Background backup started")
            
            # Get auth data
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            with open(user_config_file, 'r') as f:
                auth_data = json.load(f)
            
            # Initialize auth system
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread, hashlib, platform
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = auth_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            auth_sys.appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            auth_sys.user_config_file = user_config_file
            
            # Ensure fingerprint
            if 'machine_fingerprint' not in auth_sys.user_data:
                system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                hostname = platform.node()
                auth_sys.user_data['machine_fingerprint'] = hashlib.md5(
                    f"{system_info}-{hostname}".encode()
                ).hexdigest()[:16]
            
            # Connect
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[BACKUP-BG] No credentials")
                return
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            
            print("[BACKUP-BG] Connected to Google Sheets")
            
            # Save user metadata
            auth_sys.save_user_to_sheet()
            
            # Save all files
            prof = _load_profile()
            auth_sys.save_profile_data(prof, app_paths_instance=app_paths)
            
            # Count backed up files
            file_list = []
            for attr in ['profile_file', 'wastage_file', 'study_total_file', 'wastage_day_file',
                        'study_today_file', 'exam_date_file', 'opened_days_file',
                        'goal_config_file', 'plans_file']:
                filepath = getattr(app_paths, attr, None)
                if filepath and os.path.exists(filepath):
                    file_list.append(os.path.basename(filepath))
            
            print(f"[BACKUP-BG] Completed - backed up {len(file_list)} files:")
            for fname in file_list:
                print(f"  ‚úì {fname}")
            
        except Exception as e:
            print(f"[BACKUP-BG] Error: {e}")
            import traceback
            traceback.print_exc()    
        
    def check_cloud_restore_on_startup_sync(self):
        """Synchronous restore - runs BEFORE any data loading in init"""
        import os
        
        try:
            print("[RESTORE-SYNC] Starting restore check...")
            
            appdata_dir = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            force_restore_flag = os.path.join(appdata_dir, '.force_full_restore')
            user_config_file = os.path.join(appdata_dir, 'user_config.json')
            profile_file = app_paths.profile_file  # Check if profile exists
            
            # Check if force restore is needed
            force_restore = os.path.exists(force_restore_flag)
            
            if force_restore:
                print("\n" + "="*60)
                print("[RESTORE-SYNC] ‚ö† FORCE RESTORE FLAG DETECTED")
                print("[RESTORE-SYNC] WILL RESTORE ALL FILES (OVERWRITE EXISTING)")
                print("="*60 + "\n")
            
            # ‚úÖ NEW LOGIC: Check restore eligibility
            auth_data = None
            check_method = None
            
            # CASE 1: user_config.json exists ‚Üí Normal authenticated user
            if os.path.exists(user_config_file):
                try:
                    with open(user_config_file, 'r') as f:
                        auth_data = json.load(f)
                    check_method = "email"
                    print(f"[RESTORE-SYNC] User authenticated - will check by email: {auth_data.get('email')}")
                except Exception as e:
                    print(f"[RESTORE-SYNC] Error reading user_config: {e}")
            
            # CASE 2: No user_config BUT profile exists ‚Üí User logged out intentionally
            elif os.path.exists(profile_file):
                print("[RESTORE-SYNC] Profile exists but no user_config")
                print("[RESTORE-SYNC] User appears to be logged out - skipping fingerprint check")
                print("[RESTORE-SYNC] (This prevents auto-login after manual logout)")
                return
            
            # CASE 3: No user_config AND no profile ‚Üí Try fingerprint match (device reset scenario)
            else:
                print("[RESTORE-SYNC] No user_config AND no profile found")
                print("[RESTORE-SYNC] Checking by machine fingerprint (device reset recovery)")
                
                # Generate current machine fingerprint
                import hashlib, platform
                system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                hostname = platform.node()
                current_fp = hashlib.md5(f"{system_info}-{hostname}".encode()).hexdigest()[:16]
                
                print(f"[RESTORE-SYNC] Current machine fingerprint: {current_fp}")
                
                # Connect to sheets and search by fingerprint
                try:
                    from Authenticator import UnifiedAuthSystem
                    from cryptography.fernet import Fernet
                    from dotenv import load_dotenv
                    import gspread
                    
                    load_dotenv()
                    
                    encryption_key = get_secret('ENCRYPTION_KEY')
                    encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
                    
                    if not encryption_key or not encrypted_creds:
                        print("[RESTORE-SYNC] No credentials - cannot check fingerprint")
                        return
                    
                    fernet = Fernet(encryption_key.encode())
                    decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
                    creds_dict = json.loads(decrypted_creds)
                    
                    
                    sheet_id =  get_secret("LB_SHEET_ID")
                    worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
                    
                    sheet = gspread_client.open_by_key(sheet_id)
                    worksheet = sheet.worksheet(worksheet_name)
                    records = worksheet.get_all_records()
                    
                    print(f"[RESTORE-SYNC] Searching {len(records)} records for matching fingerprint...")
                    
                    # Search for matching fingerprint
                    for record in records:
                        stored_fp = record.get('machine_fingerprint', '')
                        if stored_fp == current_fp:
                            print(f"[RESTORE-SYNC] ‚úì FOUND MATCH!")
                            print(f"[RESTORE-SYNC] Email: {record.get('email')}")
                            print(f"[RESTORE-SYNC] Name: {record.get('name')}")
                            
                            # Recreate auth_data from sheet record
                            auth_data = {
                                'uid': record.get('uid'),
                                'email': record.get('email'),
                                'name': record.get('name'),
                                'machine_fingerprint': stored_fp,
                                'auth_method': record.get('auth_method', 'email'),
                                'created_at': record.get('created_at', ''),
                                'google_id': record.get('google_id', ''),
                                'picture': record.get('picture', '')
                            }
                            
                            # Save to user_config.json
                            os.makedirs(appdata_dir, exist_ok=True)
                            with open(user_config_file, 'w') as f:
                                json.dump(auth_data, f, indent=2)
                            
                            print(f"[RESTORE-SYNC] ‚úì Restored user_config.json")
                            check_method = "fingerprint"
                            break
                    
                    if not auth_data:
                        print("[RESTORE-SYNC] No matching fingerprint found in cloud")
                        print("[RESTORE-SYNC] This device is not registered - user needs to sign in")
                        return
                        
                except Exception as e:
                    print(f"[RESTORE-SYNC] Error checking fingerprint: {e}")
                    import traceback
                    traceback.print_exc()
                    return
            
            # If we got here, we have auth_data (either from user_config or fingerprint match)
            if not auth_data or not auth_data.get('email'):
                print("[RESTORE-SYNC] No valid auth data - skipping")
                return
            
            print(f"[RESTORE-SYNC] User: {auth_data.get('email')} (found by {check_method})")
            
            # Check which files to restore
            file_check = {
                'wastage_log.csv': app_paths.wastage_file,
                'total_studied_time.json': app_paths.study_total_file,
                'wastage_by_day.json': app_paths.wastage_day_file,
                'studied_today_time.json': app_paths.study_today_file,
                'exam_date.json': app_paths.exam_date_file,
                'opened_days.txt': app_paths.opened_days_file,
                'goal_config.json': app_paths.goal_config_file,
                'plans.json': app_paths.plans_file
            }
            
            if force_restore:
                print("[RESTORE-SYNC] Force restore mode - will restore ALL files")
                
                # DELETE all existing files first
                for name, filepath in file_check.items():
                    if os.path.exists(filepath):
                        try:
                            os.remove(filepath)
                            print(f"[RESTORE-SYNC] Deleted existing: {name}")
                        except Exception as e:
                            print(f"[RESTORE-SYNC] Failed to delete {name}: {e}")
                
                files_to_restore = list(file_check.keys())
                
            else:
                # Normal mode - only restore missing files
                print("[RESTORE-SYNC] Normal mode - checking for missing files")
                files_to_restore = []
                
                for name, filepath in file_check.items():
                    if not os.path.exists(filepath):
                        files_to_restore.append(name)
                        print(f"[RESTORE-SYNC] Missing: {name}")
            
            if not files_to_restore:
                print("[RESTORE-SYNC] No files to restore")
                
                # Remove force restore flag if it exists
                if force_restore:
                    try:
                        os.remove(force_restore_flag)
                        print("[RESTORE-SYNC] Force restore flag removed")
                    except:
                        pass
                
                return
            
            print(f"\n[RESTORE-SYNC] Restoring {len(files_to_restore)} files...")
            
            # Perform restore
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread, hashlib, platform
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = auth_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            auth_sys.appdata_path = appdata_dir
            auth_sys.user_config_file = user_config_file
            
            # Connect
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[RESTORE-SYNC] No credentials")
                return
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
           
            print("[RESTORE-SYNC] Connected to Google Sheets")
            
            # Restore files
            loaded_prof = auth_sys.load_profile_from_sheet(app_paths_instance=app_paths)
            
            if loaded_prof:
                restored = []
                for name, filepath in file_check.items():
                    if name in files_to_restore and os.path.exists(filepath):
                        restored.append(name)
                
                print(f"\n[RESTORE-SYNC] ‚úì Restored {len(restored)} files")
                for fname in restored:
                    print(f"  ‚úì {fname}")
                
                # Check if profile was restored
                profile_restored = any('profile' in fname.lower() for fname in restored) or force_restore
                
                if profile_restored:
                    print("[RESTORE-SYNC] ‚úì Profile was restored - will reload UI")
                    self._profile_restored_flag = True
                    
                    # Schedule UI reload
                    def delayed_reload():
                        print("[RESTORE-SYNC] Reloading app with restored profile...")
                        if hasattr(self, 'reload_app_data'):
                            self.reload_app_data()
                    
                    self.after(1500, delayed_reload)
                
                # Remove force restore flag after successful restore
                if force_restore:
                    try:
                        os.remove(force_restore_flag)
                        print("[RESTORE-SYNC] ‚úì Force restore flag removed")
                    except Exception as e:
                        print(f"[RESTORE-SYNC] Flag removal error: {e}")
            else:
                print("[RESTORE-SYNC] No data to restore")
                
        except Exception as e:
            print(f"[RESTORE-SYNC] Error: {e}")
            import traceback
            traceback.print_exc()
        
    def backup_all_files_sync(self):
        """Backup ALL files on app close (not just modified)"""
        try:
            print("[BACKUP-CLOSE] Starting full backup of all files")
            
            # Get auth data
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            with open(user_config_file, 'r') as f:
                auth_data = json.load(f)
            
            print(f"[BACKUP-CLOSE] User: {auth_data.get('email')}")
            
            # Initialize auth system
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread, hashlib, platform
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = auth_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            auth_sys.appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            auth_sys.user_config_file = user_config_file
            
            # Ensure machine fingerprint
            if 'machine_fingerprint' not in auth_sys.user_data:
                system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                hostname = platform.node()
                auth_sys.user_data['machine_fingerprint'] = hashlib.md5(
                    f"{system_info}-{hostname}".encode()
                ).hexdigest()[:16]
            
            # Connect to sheets
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[BACKUP-CLOSE] No credentials")
                return
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            
            print("[BACKUP-CLOSE] Connected to Google Sheets")
            
            # Save user metadata
            auth_sys.save_user_to_sheet()
            
            # Save profile + ALL app data files
            prof = _load_profile()
            auth_sys.save_profile_data(prof, app_paths_instance=app_paths)
            
            # Count what was backed up
            file_list = []
            for attr in ['profile_file', 'wastage_file', 'study_total_file', 'wastage_day_file',
                        'study_today_file', 'exam_date_file', 'opened_days_file',
                        'goal_config_file', 'plans_file']:
                filepath = getattr(app_paths, attr, None)
                if filepath and os.path.exists(filepath):
                    file_list.append(os.path.basename(filepath))
            
            print(f"[BACKUP-CLOSE] Successfully backed up {len(file_list)} files:")
            for fname in file_list:
                print(f"  ‚úì {fname}")
            
        except Exception as e:
            print(f"[BACKUP-CLOSE] Error: {e}")
            import traceback
            traceback.print_exc()
        
    def check_profile_setup_needed(self):
        """Check if onboarding wizard should be shown"""
        try:
            # CHECK 1: Is user authenticated?
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            
            if os.path.exists(user_config_file):
                with open(user_config_file, 'r') as f:
                    auth_data = json.load(f)
                
                print("[ONBOARDING] User is authenticated")
                
                # CHECK 2: Does user have cloud data?
                has_cloud_data = self._check_cloud_data_exists(auth_data)
                print(f"[ONBOARDING] Cloud data exists: {has_cloud_data}")
                
                if has_cloud_data:
                    # CHECK 3: Is profile file missing locally?
                    profile_exists = os.path.exists(app_paths.profile_file)
                    print(f"[ONBOARDING] Local profile exists: {profile_exists}")
                    
                    if not profile_exists:
                        print("[ONBOARDING] Profile missing - restoring from cloud...")
                        
                        # Restore from cloud
                        from Authenticator import UnifiedAuthSystem
                        from cryptography.fernet import Fernet
                        from dotenv import load_dotenv
                        import gspread, hashlib, platform
                        
                        load_dotenv()
                        
                        auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
                        auth_sys.user_data = auth_data
                        auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
                        auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
                        
                        auth_sys.appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
                        auth_sys.user_config_file = user_config_file
                        
                        # Connect to sheets
                        encryption_key = get_secret('ENCRYPTION_KEY')
                        encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
                        
                        if encryption_key and encrypted_creds:
                            fernet = Fernet(encryption_key.encode())
                            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
                            creds_dict = json.loads(decrypted_creds)
                            
                            
                            print("[ONBOARDING] Connected to Google Sheets")
                            
                            # Verify fingerprint
                            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                            hostname = platform.node()
                            current_fp = hashlib.md5(f"{system_info}-{hostname}".encode()).hexdigest()[:16]
                            
                            sheet = auth_sys.gspread_client.open_by_key(auth_sys.sheet_id)
                            worksheet = sheet.worksheet(auth_sys.worksheet_name)
                            records = worksheet.get_all_records()
                            
                            stored_fp = None
                            for record in records:
                                if record.get('email') == auth_data.get('email'):
                                    stored_fp = record.get('machine_fingerprint', '')
                                    break
                            
                            if stored_fp and stored_fp != current_fp:
                                print("[ONBOARDING] Fingerprint mismatch - cannot restore")
                            else:
                                # Restore profile
                                loaded_prof = auth_sys.load_profile_from_sheet(app_paths_instance=app_paths)
                                
                                if loaded_prof:
                                    print("[ONBOARDING] ‚úì Profile restored from cloud")
                                else:
                                    print("[ONBOARDING] ‚ö† Failed to restore profile")
                        else:
                            print("[ONBOARDING] No credentials - cannot restore")
                    
                    # Cloud data exists - skip onboarding
                    print("[ONBOARDING] User has cloud data - skipping wizard")
                    self.after(500, self.reload_app_data)
                    return
            
            # CHECK 4: Local profile check (original logic for non-authenticated or no cloud data)
            prof = _load_profile()
            
            has_profile = bool(prof)
            has_onboarding_done = prof.get("onboarding_done", False)
            has_name = bool(prof.get("user_name", "").strip())
            
            print(f"[ONBOARDING] Profile check:")
            print(f"  - Profile exists: {has_profile}")
            print(f"  - Onboarding done: {has_onboarding_done}")
            print(f"  - Has name: {has_name}")
            
            if not has_profile or not has_onboarding_done or not has_name:
                print("[ONBOARDING] Showing wizard")
                
                # Create wizard
                wizard = OnboardingWizard(self)
                
                # Wait for wizard to close, THEN reload UI
                def check_wizard_closed():
                    try:
                        # Check if wizard still exists
                        wizard.winfo_exists()
                        # Still exists, check again in 500ms
                        self.after(500, check_wizard_closed)
                    except:
                        # Wizard closed, now reload UI with restored data
                        print("[ONBOARDING] Wizard closed - reloading UI now")
                        self.after(500, self.reload_app_data)
                
                # Start checking
                self.after(500, check_wizard_closed)
            else:
                print("[ONBOARDING] Skipping wizard")
                # No wizard shown, reload UI now
                self.after(500, self.reload_app_data)
                
        except Exception as e:
            print(f"[ONBOARDING] Error: {e}")
            import traceback
            traceback.print_exc()

    def is_authenticated(self):
        """Check if user is authenticated"""
        try:
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            return os.path.exists(user_config_file)
        except:
            return False

    
        
    def check_cloud_restore_on_startup(self):
        """Check and restore missing files from cloud on app startup"""
        try:
            print("\n=== STARTUP: Checking for missing files ===")
            
            # Check if authenticated
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            if not os.path.exists(user_config_file):
                print("[RESTORE] Not authenticated - skipping restore")
                return
            
            with open(user_config_file, 'r') as f:
                auth_data = json.load(f)
            
            if not auth_data.get('email'):
                print("[RESTORE] No email found - skipping restore")
                return
            
            print(f"[RESTORE] Authenticated as: {auth_data.get('email')}")
            print(f"[RESTORE] Machine fingerprint in config: {auth_data.get('machine_fingerprint', 'NOT SET')}")
            
            # Check for missing files
            missing_files = []
            file_check = {
                'wastage_log.csv': app_paths.wastage_file,
                'total_studied_time.json': app_paths.study_total_file,
                'wastage_by_day.json': app_paths.wastage_day_file,
                'studied_today_time.json': app_paths.study_today_file,
                'exam_date.json': app_paths.exam_date_file,
                'opened_days.txt': app_paths.opened_days_file,
                'goal_config.json': app_paths.goal_config_file,
                'plans.json': app_paths.plans_file
            }
            
            print("[RESTORE] Checking file existence:")
            for name, filepath in file_check.items():
                exists = os.path.exists(filepath)
                print(f"  - {name}: {'EXISTS' if exists else 'MISSING'}")
                if not exists:
                    missing_files.append(name)
            
            if not missing_files:
                print("[RESTORE] All files present - no restore needed")
                return
            
            print(f"\n[RESTORE] Attempting to restore {len(missing_files)} missing files...")
            print(f"[RESTORE] Missing: {', '.join(missing_files)}")
            
            # Perform restore
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread
            import hashlib, platform
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = auth_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            auth_sys.appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            auth_sys.user_config_file = user_config_file
            
            print(f"[RESTORE] Using Sheet ID: {auth_sys.sheet_id}")
            print(f"[RESTORE] Using Worksheet: {auth_sys.worksheet_name}")
            
            # Connect to sheets
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[RESTORE] ERROR: No credentials - cannot restore")
                return
            
            print("[RESTORE] Decrypting credentials...")
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            
            print("[RESTORE] Connected to Google Sheets")
            
            # Generate current machine fingerprint
            system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
            hostname = platform.node()
            current_machine_fp = hashlib.md5(f"{system_info}-{hostname}".encode()).hexdigest()[:16]
            print(f"[RESTORE] Current machine fingerprint: {current_machine_fp}")
            
            # Check fingerprint
            try:
                sheet = auth_sys.gspread_client.open_by_key(auth_sys.sheet_id)
                worksheet = sheet.worksheet(auth_sys.worksheet_name)
                records = worksheet.get_all_records()
                
                stored_fp = None
                for record in records:
                    if record.get('email') == auth_data.get('email'):
                        stored_fp = record.get('machine_fingerprint', '')
                        print(f"[RESTORE] Stored fingerprint in sheet: {stored_fp}")
                        break
                
                if stored_fp and stored_fp != current_machine_fp:
                    print(f"[RESTORE] ERROR: Fingerprint mismatch!")
                    print(f"  Current: {current_machine_fp}")
                    print(f"  Stored:  {stored_fp}")
                    print("[RESTORE] Access denied")
                    return
                
                if not stored_fp:
                    print("[RESTORE] WARNING: No fingerprint in sheet")
                    
            except Exception as e:
                print(f"[RESTORE] Error checking fingerprint: {e}")
            
            # Restore files
            print("[RESTORE] Calling load_profile_from_sheet...")
            loaded_prof = auth_sys.load_profile_from_sheet(app_paths_instance=app_paths)
            
            if loaded_prof:
                print("[RESTORE] load_profile_from_sheet returned data")
                
                # Count restored files
                restored_files = []
                print("\n[RESTORE] Checking which files were restored:")
                for name, filepath in file_check.items():
                    was_missing = name in missing_files
                    now_exists = os.path.exists(filepath)
                    
                    if was_missing and now_exists:
                        restored_files.append(name)
                        print(f"  ‚úì {name} - RESTORED")
                    elif was_missing and not now_exists:
                        print(f"  ‚úó {name} - STILL MISSING")
                    else:
                        print(f"  - {name} - (was not missing)")
                
                if restored_files:
                    print(f"\n[RESTORE] Successfully restored {len(restored_files)} files")
                    
                    # CRITICAL: Delay reload until UI is fully initialized
                    # Schedule reload after 2 more seconds
                    print("[RESTORE] Scheduling UI reload in 2 seconds...")
                    
                else:
                    print(f"\n[RESTORE] WARNING: No files were restored!")
            else:
                print("[RESTORE] ERROR: load_profile_from_sheet returned None")
                
        except Exception as e:
            print(f"[RESTORE] CRITICAL ERROR: {e}")
            import traceback
            traceback.print_exc()
        
        print("=== STARTUP RESTORE CHECK COMPLETE ===\n")
        
    def perform_cloud_backup(self):
        """Perform cloud backup of all data (called after 5 mins of profile setup + every 30 mins)"""
        if self.backup_in_progress:
            print("[BACKUP] Backup already in progress - skipping")
            return
        
        try:
            self.backup_in_progress = True
            print("\n=== PERFORMING CLOUD BACKUP ===")
            
            # Check if authenticated
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            if not os.path.exists(user_config_file):
                print("[BACKUP] Not authenticated - skipping")
                self.backup_in_progress = False
                return
            
            with open(user_config_file, 'r') as f:
                auth_data = json.load(f)
            
            if not auth_data.get('email'):
                print("[BACKUP] No email - skipping")
                self.backup_in_progress = False
                return
            
            print(f"[BACKUP] Backing up data for: {auth_data.get('email')}")
            
            # Initialize auth system
            from Authenticator import UnifiedAuthSystem
            from cryptography.fernet import Fernet
            from dotenv import load_dotenv
            import gspread
            import hashlib, platform
            
            load_dotenv()
            
            auth_sys = UnifiedAuthSystem.__new__(UnifiedAuthSystem)
            auth_sys.user_data = auth_data
            auth_sys.sheet_id =  get_secret("LB_SHEET_ID")
            auth_sys.worksheet_name = get_secret("USER_WORKSHEET") or "UserAccounts"
            
            auth_sys.appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            auth_sys.user_config_file = user_config_file
            
            # Ensure machine fingerprint is set
            if 'machine_fingerprint' not in auth_sys.user_data:
                system_info = f"{platform.system()}-{platform.machine()}-{platform.processor()}"
                hostname = platform.node()
                auth_sys.user_data['machine_fingerprint'] = hashlib.md5(
                    f"{system_info}-{hostname}".encode()
                ).hexdigest()[:16]
            
            # Connect to sheets
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            if not encryption_key or not encrypted_creds:
                print("[BACKUP] No credentials available")
                self.backup_in_progress = False
                return
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            
            print("[BACKUP] Connected to Google Sheets")
            
            # Save user metadata
            auth_sys.save_user_to_sheet()
            print("[BACKUP] User metadata saved")
            
            # Save profile + all app data
            prof = _load_profile()
            auth_sys.save_profile_data(prof, app_paths_instance=app_paths)
            
            # Count backed up files
            file_count = 0
            file_list = []
            for attr in ['wastage_file', 'study_total_file', 'wastage_day_file',
                        'study_today_file', 'exam_date_file', 'opened_days_file',
                        'goal_config_file', 'plans_file']:
                filepath = getattr(app_paths, attr, None)
                if filepath and os.path.exists(filepath):
                    file_count += 1
                    file_list.append(os.path.basename(filepath))
            
            print(f"[BACKUP] Successfully backed up profile + {file_count} data files:")
            for fname in file_list:
                print(f"  - {fname}")
            
            from datetime import datetime
            self.last_backup_time = datetime.now()
            
        except Exception as e:
            print(f"[BACKUP] Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.backup_in_progress = False
            print("=== CLOUD BACKUP COMPLETE ===\n")

    def schedule_auto_backup(self):
        """Schedule automatic backup every 30 minutes (recursive)"""
        # Only backup if authenticated
        try:
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            if os.path.exists(user_config_file):
                print("[AUTO-BACKUP] Running 30-minute scheduled backup")
                self.perform_cloud_backup()
            else:
                print("[AUTO-BACKUP] Not authenticated - skipping")
        except Exception as e:
            print(f"[AUTO-BACKUP] Error: {e}")
        
        # Schedule next backup in 30 minutes (1800000 ms)
        self.after(1800000, self.schedule_auto_backup)

    def reload_app_data(self):
        """Reload app data after restore and UPDATE UI"""
        try:
            print("[RELOAD] Reloading app data...")
            
            # 1. Force reload exam date from file
            try:
                if os.path.exists(app_paths.exam_date_file):
                    with open(app_paths.exam_date_file, 'r', encoding='utf-8') as f:
                        exam_data = json.load(f)
                        if exam_data.get('exam_date'):
                            from datetime import datetime
                            self.progress_exam_date = datetime.fromisoformat(exam_data['exam_date']).date()
                            print(f"[RELOAD] Exam date updated to: {self.progress_exam_date}")
            except Exception as e:
                print(f"[RELOAD] Error loading exam date: {e}")
            
            # 2. Reload total studied time
            try:
                if os.path.exists(app_paths.study_total_file):
                    with open(app_paths.study_total_file, 'r', encoding='utf-8') as f:
                        total_data = json.load(f)
                        # Update your total time variable
                        print(f"[RELOAD] Total study time reloaded")
            except Exception as e:
                print(f"[RELOAD] Error loading total time: {e}")
            
            # 3. Reload today's study time
            try:
                if os.path.exists(app_paths.study_today_file):
                    with open(app_paths.study_today_file, 'r', encoding='utf-8') as f:
                        today_data = json.load(f)
                        print(f"[RELOAD] Today's study time reloaded")
            except Exception as e:
                print(f"[RELOAD] Error loading today's time: {e}")
            
            # 4. Reload goals
            try:
                if os.path.exists(app_paths.goal_config_file):
                    with open(app_paths.goal_config_file, 'r', encoding='utf-8') as f:
                        goal_data = json.load(f)
                        print(f"[RELOAD] Goals reloaded")
            except Exception as e:
                print(f"[RELOAD] Error loading goals: {e}")
            
            # 5. CRITICAL: Recompute all rates and markers with new exam date
            try:
                self.recompute_required_rates()
                print("[RELOAD] Required rates recomputed")
            except Exception as e:
                print(f"[RELOAD] Error recomputing rates: {e}")
            
            # 6. CRITICAL: Refresh goal markers on graph
            try:
                if hasattr(self, 'refresh_goal_and_markers'):
                    self.refresh_goal_and_markers()
                    print("[RELOAD] Goal markers refreshed")
            except Exception as e:
                print(f"[RELOAD] Error refreshing markers: {e}")
            
            # 7. CRITICAL: Force update ALL UI labels that show exam date
            try:
                # Update exam date label if it exists
                if hasattr(self, 'exam_date_label'):
                    days_left = (self.progress_exam_date - datetime.now().date()).days
                    self.exam_date_label.config(text=f"Exam: {self.progress_exam_date} ({days_left} days)")
                    print(f"[RELOAD] Exam date label updated")
                
                # Update any other UI elements showing exam date
                if hasattr(self, 'update_exam_countdown'):
                    self.update_exam_countdown()
                    print("[RELOAD] Exam countdown updated")
                
                # Force redraw of the entire graph/canvas
                if hasattr(self, 'canvas'):
                    self.canvas.delete("all")
                    if hasattr(self, 'draw_graph'):
                        self.draw_graph()
                        print("[RELOAD] Graph redrawn")
            except Exception as e:
                print(f"[RELOAD] Error updating UI: {e}")
            
            # 8. Force window update
            try:
                self.update_idletasks()
                self.update()
                print("[RELOAD] UI refreshed")
            except Exception as e:
                print(f"[RELOAD] Error forcing UI update: {e}")
            
            print("[RELOAD] App data reload complete")
            
        except Exception as e:
            print(f"[RELOAD] Critical error: {e}")
            import traceback
            traceback.print_exc()
        
    def auto_save_profile(self):
        """Automatically save current profile state"""
        try:
            # Load current profile
            current_profile = _load_profile()
            
            # Update with any current app state you want to preserve
            # Add your app-specific data here
            current_profile.update({
                'last_app_close': datetime.now().isoformat(),
                'app_version': getattr(self, 'version', '1.0.0'),
                # Add any other current app state you want to save
            })
            
            # Save updated profile
            _save_profile(current_profile)
            
        except Exception as e:
            print(f"Auto save failed: {e}")
        
    def get_referral_program_stats(self):
        """Get aggregated stats from the referral program Google Sheet"""
        print(f"DEBUG: Starting method, self type = {type(self)}")
        
        try:
            print("DEBUG: Attempting to get client...")
            client = get_encrypted_gspread_client()
            print(f"DEBUG: Client result = {client}")
            
            if not client:
                print("DEBUG: No client, returning 0s")
                return "0", "0", "0"
            
            print("DEBUG: Opening sheet...")
            sheet = client.open_by_key(self.referral_sheet_id)
            print(f"DEBUG: Sheet opened: {sheet}")
            
            print("DEBUG: Getting worksheet...")
            worksheet = sheet.worksheet(self.referral_worksheet)
            print(f"DEBUG: Worksheet: {worksheet}")
            
            print("DEBUG: Getting all values...")
            all_records = worksheet.get_all_values()
            print(f"DEBUG: Got {len(all_records)} records")
            
            if not all_records or len(all_records) < 2:
                print("DEBUG: No data, returning 0s")
                return "0", "0", "0"
            
            # Simple counting without complex operations
            total_installs = 0
            total_subscriptions = 0
            
            for row in all_records[1:]:  # Skip header
                if len(row) > 14:
                    # Just check if there's data, don't do complex parsing
                    if row[12]:  # Install count
                        total_installs += 1
                    if row[14]:  # Subscription count  
                        total_subscriptions += 1
            
            print(f"DEBUG: Returning {total_installs}, {total_subscriptions}, 0")
            return str(total_installs), str(total_subscriptions), "0"
            
        except Exception as e:
            print(f"DEBUG: Exception in method: {e}")
            import traceback
            traceback.print_exc()
            return "0", "0", "0"
        
    def _early_license_check(self):
        """Check for payment without license immediately on app start"""
        try:
            user_profile = _load_profile()
            
            # Quick check - don't do full validation, just check if payment exists but license doesn't
            license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
            
            if not license_valid:
                # Check if payment exists (online or offline)
                payment_exists = False
                
                # Check offline first (faster)
                offline_status = self.license_manager.check_offline_status(user_profile)
                if offline_status.get("payment", False):
                    payment_exists = True
                
                # If no offline payment, check online
                if not payment_exists and self.license_manager._check_internet():
                    try:
                        online_status = self.license_manager.check_online_status(user_profile)
                        payment_exists = online_status.get("payment", False)
                    except:
                        pass
                
                # If payment exists but license is invalid, show activation popup immediately
                if payment_exists:
                    print("[EARLY CHECK] Payment found but license invalid - showing activation popup")
                    self.after(500, self._show_payment_wizard_with_license_ready)  # Small delay for UI to load
                    return
            
            # If license is valid or no payment exists, continue with normal flow
            print("[EARLY CHECK] No immediate action needed - scheduling periodic check")
            
        except Exception as e:
            print(f"[EARLY CHECK] Error: {e}")
        
    def disable_telegram_connection_for_non_premium(self):
        """Disable telegram by backing up and removing chat_id"""
        try:
            app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
            profile_file = os.path.join(app_data_dir, "profile.json")
            
            if os.path.exists(profile_file):
                with open(profile_file, 'r') as f:
                    profile = json.load(f)
                
                # Check if telegram is connected
                chat_id = profile.get("telegram_chat_id")
                if chat_id:
                    print(f"[TELEGRAM] Found chat_id: {chat_id}, backing up and removing...")
                    # Backup the original chat_id
                    profile["telegram_chat_id_backup"] = chat_id
                    # Remove the active chat_id
                    profile.pop("telegram_chat_id", None)
                    
                    # Save the modified profile
                    with open(profile_file, 'w') as f:
                        json.dump(profile, f, indent=2)
                    
                    print(f"[TELEGRAM] Chat ID backed up and removed successfully")
                    return True
                else:
                    print(f"[TELEGRAM] No chat_id found in profile")
            
        except Exception as e:
            print(f"[TELEGRAM] Error disabling connection: {e}")
            import traceback
            traceback.print_exc()
        
        return False

    # ADD this method to restore telegram connection after payment
    def restore_telegram_connection_after_payment(self):
        """Restore telegram connection by restoring backed up chat_id"""
        try:
            app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
            profile_file = os.path.join(app_data_dir, "profile.json")
            
            if os.path.exists(profile_file):
                with open(profile_file, 'r') as f:
                    profile = json.load(f)
                
                # Check if there's a backed up chat_id
                backup_chat_id = profile.get("telegram_chat_id_backup")
                if backup_chat_id:
                    # Restore the chat_id
                    profile["telegram_chat_id"] = backup_chat_id
                    # Remove the backup
                    profile.pop("telegram_chat_id_backup", None)
                    
                    # Save the restored profile
                    with open(profile_file, 'w') as f:
                        json.dump(profile, f, indent=2)
                    
                    print(f"[TELEGRAM] Chat ID restored for premium user")
                    return True
            
        except Exception as e:
            print(f"[TELEGRAM] Error restoring connection: {e}")
        
        return False
    
    def _open_telegram_with_premium_check(self):
        """Wrapper for telegram with premium check"""
        user_profile = _load_profile()
        
        license_valid = False
        license_message = ""
        trial_status = 'no_trial'
        
        if hasattr(self, 'license_manager'):
            try:
                license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
            except:
                pass
        
        if hasattr(self, 'trial_manager'):
            try:
                trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
            except:
                pass

        # ‚úÖ FIXED: Allow access for first-time users and active trials
        has_access = False
        
        if license_valid:
            has_access = True
        elif license_message == "first_time_user" or trial_status == 'no_trial':
            has_access = True  # First-time user - allow access
        elif trial_status == 'valid':
            has_access = True  # Active trial - allow access
        
        if not has_access:
            # Show premium message only if trial expired or tampered
            self._show_telegram_premium_message()
            return

        # Call your original function
        _open_telegram()

    def setup_simple_email_recipients_with_premium_check(self):
        """Wrapper for email setup with premium check"""
        user_profile = _load_profile()
        
        license_valid = False
        license_message = ""
        trial_status = 'no_trial'
        
        if hasattr(self, 'license_manager'):
            try:
                license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
            except:
                pass
        
        if hasattr(self, 'trial_manager'):
            try:
                trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
            except:
                pass

        # ‚úÖ FIXED: Allow access for first-time users and active trials
        has_access = False
        
        if license_valid:
            has_access = True
        elif license_message == "first_time_user" or trial_status == 'no_trial':
            has_access = True  # First-time user - allow access
        elif trial_status == 'valid':
            has_access = True  # Active trial - allow access
        
        if not has_access:
            # Show premium message only if trial expired or tampered
            self._show_email_premium_message()
            return

        # Call your original method
        self.setup_simple_email_recipients()

    def disable_communication_features_for_non_premium(self):
        """Disable telegram and email features for non-premium users"""
        try:
            user_profile = _load_profile()
            profile_exists = bool(user_profile)
            
            # Check license FIRST
            license_valid = False
            if hasattr(self, 'license_manager'):
                try:
                    license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
                except:
                    pass
            
            # ‚úÖ NEW: If license is valid, ALWAYS enable features
            if license_valid:
                print("[COMM] Valid license - enabling features")
                
                # Ensure buttons are enabled
                if hasattr(self, 'telegram_btn'):
                    self.telegram_btn.config(
                        text="Connect Telegram",
                        bg="#0088cc",
                        fg="white",
                        activebackground="#006ba3",
                        activeforeground="white",
                        cursor="hand2",
                        command=_open_telegram
                    )
                
                if hasattr(self, 'email_btn'):
                    self.email_btn.config(
                        text="üìß Setup Email Reports",
                        bg="#4CAF50",
                        fg="white",
                        activebackground="#45a049",
                        activeforeground="white",
                        cursor="hand2",
                        command=self.setup_simple_email_recipients
                    )
                
                if hasattr(self, 'test_telegram_btn'):
                    self.test_telegram_btn.config(state="normal")
                
                return
            
            # Only check trial if no license
            trial_valid = False
            trial_status = 'no_trial'
            
            if hasattr(self, 'trial_manager'):
                try:
                    trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
                    trial_valid = (trial_status == 'valid')
                except:
                    pass

            should_show_features = (
                trial_valid or
                (not profile_exists) or
                (profile_exists and trial_status == 'no_trial' and
                 not user_profile.get('trial_tampered'))
            )
            
            print(f"[COMM] License: {license_valid}, Trial: {trial_status}, Should enable: {should_show_features}")

            if not should_show_features:
                # Disable features
                if hasattr(self, 'telegram_btn'):
                    self.telegram_btn.config(
                        text="üîí Connect Telegram (Premium)",
                        bg="#d3d3d3",
                        fg="#888888",
                        activebackground="#d3d3d3",
                        activeforeground="#888888",
                        cursor="arrow",
                        command=self._show_telegram_premium_message
                    )
                
                if hasattr(self, 'email_btn'):
                    self.email_btn.config(
                        text="üîí Setup Email Reports (Premium)",
                        bg="#d3d3d3",
                        fg="#888888",
                        activebackground="#d3d3d3",
                        activeforeground="#888888",
                        cursor="arrow",
                        command=self._show_email_premium_message
                    )
                
                if hasattr(self, 'test_telegram_btn'):
                    self.test_telegram_btn.config(state="disabled")
                
                self.disable_telegram_connection_for_non_premium()
                
                print("[COMM] Communication features disabled")
            else:
                # Enable features
                if hasattr(self, 'telegram_btn'):
                    self.telegram_btn.config(
                        text="Connect Telegram",
                        bg="#0088cc",
                        fg="white",
                        activebackground="#006ba3",
                        activeforeground="white",
                        cursor="hand2",
                        command=_open_telegram
                    )
                
                if hasattr(self, 'email_btn'):
                    self.email_btn.config(
                        text="üìß Setup Email Reports",
                        bg="#4CAF50",
                        fg="white",
                        activebackground="#45a049",
                        activeforeground="white",
                        cursor="hand2",
                        command=self.setup_simple_email_recipients
                    )
                
                if hasattr(self, 'test_telegram_btn'):
                    self.test_telegram_btn.config(state="normal")
                
                print("[COMM] Communication features enabled")
            
        except Exception as e:
            print(f"[COMM] Error: {e}")
            import traceback
            traceback.print_exc()

    # ADD popup methods and reapply fade methods
    def _show_telegram_premium_message(self):
        """Show premium required message for telegram"""
        from tkinter import messagebox
        messagebox.showinfo("Premium Feature",
            "üîí Telegram Notifications\n\n"
            "This is a premium feature.\n\n"
            "Subscribe now to get instant study notifications on Telegram!")
        self._show_payment_wizard()

    def _show_email_premium_message(self):
        """Show premium required message for email"""
        from tkinter import messagebox
        messagebox.showinfo("Premium Feature",
            "üîí Email Reports\n\n"
            "This is a premium feature.\n\n"
            "Subscribe now to get automated daily email reports!")
        self._show_payment_wizard()

    def _reapply_telegram_fade(self):
        """Re-apply faded appearance to telegram button"""
        if hasattr(self, 'telegram_btn'):
            self.telegram_btn.config(
                text="üîí Connect Telegram",
                bg="#d3d3d3",
                fg="#888888",
                activebackground="#d3d3d3",
                activeforeground="#888888"
            )

    def _reapply_email_fade(self):
        """Re-apply faded appearance to email button"""
        if hasattr(self, 'email_btn'):
            self.email_btn.config(
                text="üîí Setup Email Reports",
                bg="#d3d3d3",
                fg="#888888",
                activebackground="#d3d3d3",
                activeforeground="#888888"
            )
    
    def hide_title_bar_for_non_premium(self):
        """Hide title bar elements for non-premium users"""
        try:
            user_profile = {}
            profile_exists = False
            
            try:
                app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
                profile_file = os.path.join(app_data_dir, "profile.json")
                if os.path.exists(profile_file):
                    with open(profile_file, 'r') as f:
                        user_profile = json.load(f)
                    profile_exists = True
            except:
                pass

            # Check license FIRST
            license_valid = False
            if hasattr(self, 'license_manager'):
                try:
                    license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
                except:
                    pass
            
            # ‚úÖ NEW: If license is valid, ALWAYS show features (ignore trial tampering)
            if license_valid:
                print("[TITLE] Valid license - showing features")
                return
            
            # Only check trial if no license
            trial_valid = False
            trial_status = 'no_trial'
            
            if hasattr(self, 'trial_manager'):
                try:
                    trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
                    trial_valid = (trial_status == 'valid')
                except:
                    pass

            # Determine if features should be shown
            should_show_features = (
                trial_valid or                                      # Has active trial
                (not profile_exists) or                            # Brand new user
                (profile_exists and trial_status == 'no_trial' and  # First-time user
                 not user_profile.get('trial_tampered'))           # but not tampered
            )
            
            print(f"[TITLE] License: {license_valid}, Trial: {trial_status}, Should show: {should_show_features}")

            if not should_show_features:
                # Hide elements...
                if hasattr(self, 'data_usage_label'):
                    self.data_usage_label.pack_forget()
                
                if hasattr(self, 'short_term_label'):
                    self.short_term_label.pack_forget()
                
                if hasattr(self, 'long_term_label'):
                    self.long_term_label.pack_forget()
                if hasattr(self, 'long_info_btn'):
                    self.long_info_btn.pack_forget()
                
                if hasattr(self, 'export_pdf_btn'):
                    self.export_pdf_btn.pack_forget()
                
                if hasattr(self, 'data_usage_label'):
                    parent_frame = self.data_usage_label.master.master
                    
                    self.title_premium_overlay = tk.Frame(parent_frame, bg=parent_frame.cget("bg"))
                    self.title_premium_overlay.pack(side="left", padx=(180, 0), fill="x", expand=True)
                    
                    premium_msg = tk.Label(
                        self.title_premium_overlay,
                        text="üîí ",
                        font=("Arial", 11, "bold"),
                        fg="#666666",
                        bg=parent_frame.cget("bg")
                    )
                    premium_msg.pack(pady=8, padx=20)
                
                print("[TITLE] Title bar elements hidden")
            
        except Exception as e:
            print(f"[TITLE] Error: {e}")
            import traceback
            traceback.print_exc()

    # 2. HIDE LIVE TAB ELEMENTS FOR NON-PREMIUM USERS
    # Add this method to your main class:
    def hide_live_tab_elements_for_non_premium(self):
        """Hide live tab elements for non-premium users"""
        try:
            user_profile = {}
            profile_exists = False
            
            try:
                app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
                profile_file = os.path.join(app_data_dir, "profile.json")
                if os.path.exists(profile_file):
                    with open(profile_file, 'r') as f:
                        user_profile = json.load(f)
                    profile_exists = True
            except:
                pass

            # Check license FIRST
            license_valid = False
            if hasattr(self, 'license_manager'):
                try:
                    license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
                except:
                    pass
            
            # ‚úÖ NEW: If license is valid, ALWAYS show features
            if license_valid:
                print("[LIVE] Valid license - showing features")
                return
            
            # Only check trial if no license
            trial_valid = False
            trial_status = 'no_trial'
            
            if hasattr(self, 'trial_manager'):
                try:
                    trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
                    trial_valid = (trial_status == 'valid')
                except:
                    pass

            should_show_features = (
                trial_valid or
                (not profile_exists) or
                (profile_exists and trial_status == 'no_trial' and
                 not user_profile.get('trial_tampered'))
            )
            
            print(f"[LIVE] License: {license_valid}, Trial: {trial_status}, Should show: {should_show_features}")

            if not should_show_features:
                if hasattr(self, 'progress_canvas'):
                    self.progress_canvas.pack_forget()
                
                if hasattr(self, 'progress_text_label'):
                    self.progress_text_label.master.pack_forget()
                
                if hasattr(self, 'extra_study_btn'):
                    self.extra_study_btn.pack_forget()
                
                if hasattr(self, 'pause_credit_label'):
                    self.pause_credit_label.pack_forget()
                
                print("[LIVE] Live tab elements hidden")
            
        except Exception as e:
            print(f"[LIVE] Error: {e}")
            import traceback
            traceback.print_exc()
    
        
    def check_sheet_and_remove_overlays(self):
        """Check Google Sheet and remove overlays if license exists"""
        try:
            # Load user profile
            user_profile = {}
            try:
                app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
                profile_file = os.path.join(app_data_dir, "profile.json")
                if os.path.exists(profile_file):
                    with open(profile_file, 'r') as f:
                        user_profile = json.load(f)
            except:
                pass
            
            # Check Google Sheet for license
            if hasattr(self, 'license_manager') and self.license_manager:
                has_license = self.license_manager.check_license_in_sheet(user_profile)
                
                if has_license:
                    # Remove all overlays
                    overlay_list = [
                        'lb_table_overlay', 'lb_top3_overlay', 'runrate_graph_overlay', 
                        'bar_chart_overlay', 'header_overlay', 
                        'wastage_premium_msg', 'wastage_subscribe_btn'
                        # Note: removed 'title_premium_overlay' since we're not creating it anymore
                    ]
                    
                    for overlay_name in overlay_list:
                        if hasattr(self, overlay_name):
                            try:
                                overlay_widget = getattr(self, overlay_name)
                                overlay_widget.destroy()
                                delattr(self, overlay_name)
                                print(f"[REMOVED] {overlay_name}")
                            except Exception as e:
                                print(f"[ERROR] Removing {overlay_name}: {e}")
                    self.restore_telegram_connection_after_payment()
                    # Restore title bar elements
                    if hasattr(self, 'data_usage_label'):
                        self.data_usage_label.pack(side="left", padx=(20, 80))
                    if hasattr(self, 'short_term_label'):
                        self.short_term_label.pack(side="left")
                    if hasattr(self, 'long_term_label'):
                        self.long_term_label.pack(side="left")
                    if hasattr(self, 'long_info_btn'):
                        self.long_info_btn.pack(side="left", padx=(8, 0))
                    if hasattr(self, 'export_pdf_btn'):
                        self.export_pdf_btn.pack(side="right", padx=(4,2), pady=2)
                    
                    # Restore live tab elements
                    if hasattr(self, 'progress_canvas'):
                        self.progress_canvas.pack(pady=(0, 1))
                    if hasattr(self, 'progress_text_label') and hasattr(self.progress_text_label, 'master'):
                        self.progress_text_label.master.pack(pady=(0, 0))
                    if hasattr(self, 'extra_study_btn'):
                        self.extra_study_btn.pack(pady=(0, 4))
                    if hasattr(self, 'pause_credit_label'):
                        self.pause_credit_label.pack()
                        
                    if hasattr(self, 'telegram_btn'):
                        self.telegram_btn.config(
                            text="Connect Telegram",
                            bg="#0088cc",
                            fg="white",
                            activebackground="#006ba3",
                            activeforeground="white",
                            command=_open_telegram  # Back to original function
                        )
                    
                    if hasattr(self, 'email_btn'):
                        self.email_btn.config(
                            text="üìß Setup Email Reports",
                            bg="#4CAF50", 
                            fg="white",
                            activebackground="#45a049",
                            activeforeground="white",
                            command=self.setup_simple_email_recipients  # Back to original method
                        )
                    
                    # Also raise premium widgets to make sure they're visible
                    premium_widgets = ['lb_table', 'lb_top3', 'runrate_graph']
                    for widget_name in premium_widgets:
                        if hasattr(self, widget_name):
                            try:
                                widget = getattr(self, widget_name)
                                widget.lift()
                                widget.tkraise()
                                print(f"[RAISED] {widget_name}")
                            except Exception as e:
                                print(f"[ERROR] Raising {widget_name}: {e}")
                    
                    print("[SUCCESS] All overlays removed and premium widgets raised!")
                    return True
            
            return False
            
        except Exception as e:
            print(f"[ERROR] {e}")
            return False
    
    def _create_premium_overlay(self, parent, x, y, width, height, message, use_relx=False, relx=None, rel_x=None, info_only=False):
        """Create a semi-transparent overlay with subscribe message"""
        import tkinter as tk
        
        # Create overlay frame with semi-transparent background
        overlay = tk.Frame(parent, bg='gray90', relief='raised', bd=2)
        
        # Position the overlay
        if use_relx and relx is not None:
            overlay.place(relx=relx, x=rel_x, y=y, width=width, height=height, anchor="nw")
        else:
            overlay.place(x=x, y=y, width=width, height=height)
        
        # Create semi-transparent background
        canvas = tk.Canvas(overlay, highlightthickness=0)
        canvas.pack(fill='both', expand=True)
        
        # Configure canvas background with transparency effect
        canvas.configure(bg='#f0f0f0')
        canvas.create_rectangle(0, 0, width, height, fill='#ffffff', stipple='gray50', outline='')
        
        # Add subscribe message
        message_frame = tk.Frame(canvas, bg='#ffffff', relief='solid', bd=1)
        message_frame.place(relx=0.5, rely=0.5, anchor='center')
        
        # Icon (you can replace with actual icon)
        icon_label = tk.Label(message_frame, text="üîí", font=('Arial', 16 if info_only else 20), bg='#ffffff')
        icon_label.pack(pady=(8 if info_only else 10, 3 if info_only else 5))
        
        # Main message
        msg_label = tk.Label(
            message_frame, 
            text=message,
            font=('Arial', 9 if info_only else 12, 'bold'),
            fg='#666666',
            bg='#ffffff',
            wraplength=width-20 if info_only else width-40
        )
        msg_label.pack(pady=3 if info_only else 5, padx=10 if info_only else 20)
        
        # Only add subscribe button if not info_only
        if not info_only:
            # Subscribe button
            subscribe_btn = tk.Button(
                message_frame,
                text="Subscribe Now",
                font=('Arial', 10, 'bold'),
                bg='#4CAF50',
                fg='white',
                relief='flat',
                padx=20,
                pady=8,
                cursor='hand2',
                command=self._open_subscription_dialog
            )
            subscribe_btn.pack(pady=(5, 15))
        else:
            # Add some bottom padding for info-only overlays
            spacer = tk.Label(message_frame, text="", bg='#ffffff', height=1)
            spacer.pack(pady=(0, 8))
        
        return overlay

    def _open_subscription_dialog(self):
        """Open subscription/payment dialog - implement this based on your payment flow"""
        try:
            # This should open your existing subscription/payment window
            # For example:
            if hasattr(self, '_show_payment_wizard'):
                self._show_payment_wizard()
            else:
                # Fallback: show a simple message
                import tkinter.messagebox as msgbox
                msgbox.showinfo("Subscription Required", 
                              "Please subscribe to access premium features!\n\n" +
                              "Contact support for subscription options.")
        except Exception as e:
            print(f"[SUBSCRIPTION] Error opening dialog: {e}")
        
    def check_first_run_referral(self):
        """Check if this is first run and show referral prompt ONLY after onboarding is complete"""
        try:
            print("[DEBUG] Starting referral check...")
            
            # Use consistent AppData path
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            print(f"[DEBUG] Profile path: {profile_path}")
            
            should_show_referral = False
            
            if not os.path.exists(profile_path):
                print("[DEBUG] No profile.json found")
                should_show_referral = False
            else:
                try:
                    with open(profile_path, 'r') as f:
                        profile = json.load(f)
                    
                    print(f"[DEBUG] Profile loaded: {profile}")
                    
                    # Check onboarding status
                    onboarding_done = profile.get('onboarding_done', False)
                    referral_checked = profile.get('referral_checked', False)
                    
                    print(f"[DEBUG] onboarding_done: {onboarding_done}")
                    print(f"[DEBUG] referral_checked: {referral_checked}")
                    
                    if not onboarding_done:
                        print("[DEBUG] Onboarding not complete - skipping referral")
                        should_show_referral = False
                    elif referral_checked:
                        print("[DEBUG] Referral already checked")
                        should_show_referral = False
                    else:
                        print("[DEBUG] Should show referral dialog!")
                        should_show_referral = True
                        
                except Exception as e:
                    print(f"[DEBUG] Error reading profile: {e}")
                    should_show_referral = False
            
            print(f"[DEBUG] Final decision - should_show_referral: {should_show_referral}")
            
            if should_show_referral:
                print("[DEBUG] Calling show_referral_validation")
                self.after(500, self.show_referral_validation)
            else:
                print("[DEBUG] Not showing referral dialog")
            
        except Exception as e:
            print(f"[DEBUG] Error in check_first_run_referral: {e}")
    
    def show_referral_validation(self):
        """Show the referral validation window"""
        try:
            print("[DEBUG] show_referral_validation called")
            
            if not self.referral_validator:
                print("[DEBUG] Creating new ReferralValidator")
                self.referral_validator = ReferralValidator(self)
            else:
                print("[DEBUG] Using existing ReferralValidator")
            
            print("[DEBUG] Calling check_and_show_referral")
            result = self.referral_validator.check_and_show_referral()
            print(f"[DEBUG] check_and_show_referral returned: {result}")
            
            # The flag is now set inside check_and_show_referral
            # No need to call _mark_referral_checked here
            
            if not result:
                print("[DEBUG] check_and_show_referral returned False, calling after_referral_check")
                self.after_referral_check()
                
        except Exception as e:
            print(f"[DEBUG] Error in show_referral_validation: {e}")
            import traceback
            traceback.print_exc()
    
    def after_referral_check(self):
        """Called after referral check is complete"""
        try:
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            
            if os.path.exists(profile_path):
                with open(profile_path, 'r') as f:
                    profile = json.load(f)
                
                # Check referral status for pricing logic
                if profile.get('used_referral', False):
                    referral_id = profile.get('referral_id_used', 'unknown')
                    print(f"User joined with referral code: {referral_id}")
                    # Use discounted pricing in your payment logic
                    self.subscription_price = 150
                else:
                    print("User skipped referral code or no referral used")
                    # Use standard pricing
                    self.subscription_price = 200
                    
                # You can also check other profile data
                print(f"User UID: {profile.get('uid', 'not set')}")
                
        except Exception as e:
            print(f"Error in after_referral_check: {e}")
            # Default to standard pricing if error
            self.subscription_price = 200
    
    def trigger_subscription_update(self):
        """Call this when user completes subscription payment"""
        try:
            if self.referral_validator:
                success = self.referral_validator.update_to_subscription()
                if success:
                    print("Referral subscription update triggered successfully")
                else:
                    print("No referral to update or update failed")
        except Exception as e:
            print(f"Error triggering subscription update: {e}")
    
    def manual_trigger_referral_check(self):
        """Manually trigger referral check (for testing or special cases)"""
        try:
            print("[REFERRAL] Manual trigger - forcing referral check")
            self.show_referral_validation()
        except Exception as e:
            print(f"Error in manual referral trigger: {e}")
    
    def reset_referral_for_testing(self):
        """Reset referral status for testing (keeps onboarding_done=True)"""
        try:
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            
            if os.path.exists(profile_path):
                with open(profile_path, 'r') as f:
                    profile = json.load(f)
                
                # Reset only referral flags, keep onboarding complete
                profile['referral_checked'] = False
                profile.pop('used_referral', None)
                profile.pop('referral_id_used', None)
                profile.pop('referral_skipped', None)
                
                with open(profile_path, 'w') as f:
                    json.dump(profile, f, indent=2)
                
                print("Referral status reset - dialog will show on next call to check_first_run_referral()")
                return True
            else:
                print("No profile to reset")
                return False
                
        except Exception as e:  # This was missing!
            print(f"Error resetting referral status: {e}")
            return False


    def get_subscription_price(self):
        """Get the appropriate subscription price based on referral status"""
        try:
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_path = os.path.join(appdata_path, 'profile.json')
            
            if os.path.exists(profile_path):
                with open(profile_path, 'r') as f:
                    profile = json.load(f)
                
                if profile.get('used_referral', False):
                    return 150  # Discounted price
                    
            return 100  # Standard price
            
        except Exception as e:
            print(f"Error getting subscription price: {e}")
            return 100  # Default to standard price
        
    def setup_email_and_referral_ui(self):
        """Setup both email and referral buttons"""
        pass
    
    def join_referral_program(self):
        """Handler for referral program button"""
        try:
            if not self.referral_system:
                self.referral_system = ReferralSystem(self)
            self.referral_system.join_referral_program()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to start referral program: {str(e)}")
    
    def reset_all_wastage_data(self):
        """
        Reset all wastage data after confirmation.
        Clears:
        1. The wastage_log (all entries)
        2. The wastage day summary
        3. Refreshes both trees
        """
        # Show confirmation dialog
        result = messagebox.askyesno(
            "Reset All Wastage Data",
            "Are you sure you want to reset ALL wastage data?\n\n"
            "This will permanently delete:\n"
            "‚Ä¢ All daily wastage records\n"
            "‚Ä¢ All session tracking data\n"
            "‚Ä¢ All historical summaries\n\n"
            "This action CANNOT be undone!",
            icon='warning'
        )
        
        if not result:
            return
        
        try:
            # Clear the global wastage_log
            global wastage_log
            wastage_log.clear()
            
            # Save empty log to file
            save_wastage_log()
            
            
            # Clear the wastage day summary
            empty_summary = {}
            save_wastage_day_summary(empty_summary)
            
            # Refresh the UI
            self.refresh_wastage()
            
            # Show success message
            messagebox.showinfo(
                "Reset Complete", 
                "All wastage data has been successfully cleared."
            )
            
        except Exception as e:
            messagebox.showerror(
                "Error", 
                f"An error occurred while resetting data:\n{str(e)}"
            )

    def reset_all_wastage_data(self):
        """
        Reset all wastage data after confirmation.
        Clears:
        1. The wastage_log (all entries)
        2. The wastage day summary
        3. Refreshes both trees
        4. Writes a reset flag so no auto-history is rebuilt on next launch
        """
        result = messagebox.askyesno(
            "Reset All Wastage Data",
            "Are you sure you want to reset ALL wastage data?\n\n"
            "This will permanently delete:\n"
            "‚Ä¢ All daily wastage records\n"
            "‚Ä¢ All session tracking data\n"
            "‚Ä¢ All historical summaries\n\n"
            "This action CANNOT be undone!",
            icon='warning'
        )
        if not result:
            return

        try:
            # 1Ô∏è‚É£  clear in-memory log and save
            global wastage_log
            wastage_log.clear()
            save_wastage_log()

            # 2Ô∏è‚É£  remove any persisted day-summary file
            try:
                if os.path.exists(WASTAGE_DAY_FILE):
                    os.remove(WASTAGE_DAY_FILE)
            except Exception as e:
                print("Could not remove WASTAGE_DAY_FILE:", e)

            # 3Ô∏è‚É£  write the permanent reset flag
            try:
                os.makedirs(app_paths.appdata_dir, exist_ok=True)
                with open(RESET_WASTAGE_FLAG, "w", encoding="utf-8") as f:
                    f.write("all reset\n")
            except Exception as e:
                print("Could not write reset flag:", e)

            # 4Ô∏è‚É£  refresh the UI
            self.refresh_wastage()

            messagebox.showinfo(
                "Reset Complete",
                "All wastage data has been successfully cleared."
            )

        except Exception as e:
            messagebox.showerror(
                "Error",
                f"An error occurred while resetting data:\n{str(e)}"
            )
        
    def show_help_menu(self):
        """Show a popup menu with Help/Support and Guide options"""
        # Create a popup menu
        help_menu = tk.Menu(self, tearoff=0, bg='white', fg='black', 
                           activebackground='#3498DB', activeforeground='white',
                           font=("Arial", 10))
        
        # Add menu items
        help_menu.add_command(
            label="  üìù  Help & Bug Report", 
            command=self.show_help_support_dialog  # Your existing help dialog
        )
        help_menu.add_separator()
        help_menu.add_command(
            label="  üöÄ  User Guide", 
            command=self.start_interactive_guide  # The guide function
        )
        
        # Get button position to show menu
        try:
            x = self.help_btn.winfo_rootx()
            y = self.help_btn.winfo_rooty() + self.help_btn.winfo_height()
            help_menu.post(x, y)
        except:
            help_menu.post(self.winfo_pointerx(), self.winfo_pointery())
        
    def check_first_time_user(self):
        """Check if this is the first time user opens the app"""
        try:
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_file = os.path.join(appdata_path, 'user_config.json')
            os.makedirs(appdata_path, exist_ok=True)
            
            with open(profile_file, 'r') as f:
                config = json.load(f)
                if not config.get('guide_shown', False):  # Changed from 'first_time_completed'
                    self.after(500, self.start_interactive_guide)
        except FileNotFoundError:
            self.after(500, self.start_interactive_guide)
            
    def mark_guide_completed(self):
        """Mark that user has completed the guide"""
        try:
            # Use same AppData/Roaming/StudyTimer path as profile
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_file = os.path.join(appdata_path, 'user_config.json')
            
            # Ensure directory exists
            os.makedirs(appdata_path, exist_ok=True)
            
            config = {}
            try:
                with open(profile_file, 'r') as f:
                    config = json.load(f)
            except:
                pass
            config['first_time_completed'] = True
            with open(profile_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error saving guide completion: {e}")
            
    def mark_guide_shown(self):
        """Mark that guide was shown (whether completed or exited)"""
        try:
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_file = os.path.join(appdata_path, 'user_config.json')
            os.makedirs(appdata_path, exist_ok=True)
            
            config = {}
            try:
                with open(profile_file, 'r') as f:
                    config = json.load(f)
            except:
                pass
            config['guide_shown'] = True
            with open(profile_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error saving guide status: {e}")

    def start_interactive_guide(self):
        """Start the interactive guide"""
        self.mark_guide_shown()
        guide_steps = [
            {
                'title': 'Welcome to Study Planner!',
                'description': 'This interactive guide will help you understand all the features of the app. Let\'s explore the interface together!',
                'widget': None,
                'tab': None
            },
            
            # === TODAY'S PLAN TAB - TOP BAR ===
            {
                'title': 'Today\'s Plan Tab',
                'description': 'This is where you plan and organize your daily study sessions. Let\'s start with the top controls.',
                'widget': None,
                'tab': 'plan'
            },
            {
                'title': 'Edit Profile',
                'description': 'Click the ‚úé button to edit your profile name and avatar.',
                'widget': self.profile_badge.edit if hasattr(self, 'profile_badge') and hasattr(self.profile_badge, 'edit') else None,
                'tab': 'plan'
            },
            {
                'title': 'Data Usage Monitor',
                'description': 'This shows how much data the app is using.',
                'widget': self.data_usage_label if hasattr(self, 'data_usage_label') else None,
                'tab': 'plan',
                'highlight_color': '#27AE60'
            },
            {
                'title': 'Short-term Timer',
                'description': 'Based on your next marked day in progress bar (on live session tab).Keeps you aligned with the nearest checkpoint.',
                'widget': self.short_term_label if hasattr(self, 'short_term_label') else None,
                'tab': 'plan',
                'highlight_color': '#3498DB'
            },
            {
                'title': 'Long-term Timer',
                'description': 'Based on total remaining days for your exam ,Keeps you aligned with your goal untill exam.',
                'widget': self.long_term_label if hasattr(self, 'long_term_label') else None,
                'tab': 'plan',
                'highlight_color': '#3498DB'
            },
            {
                'title': 'Goal Information',
                'description': 'Click the "i" button to view detailed information about short and long term concept',
                'widget': self.long_info_btn if hasattr(self, 'long_info_btn') else None,
                'tab': 'plan',
                'highlight_color': '#F39C12'
            },
            
            # === TOP RIGHT BUTTONS ===
            {
                'title': 'Export PDF Button',
                'description': 'Export your detailed study report pdf by manually at desired location.',
                'widget': self.export_pdf_btn if hasattr(self, 'export_pdf_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Help & Support',
                'description': 'you can contact admin related to bug reports, feature request, will get reply within 24h and can access this interactive guide.',
                'widget': self.help_btn if hasattr(self, 'help_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Notifications',
                'description': 'Here you will get reply as notification related to your query or feature request that you made through help option',
                'widget': self.notification_btn if hasattr(self, 'notification_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Set Exam Date',
                'description': 'Configure your exam date to track your preparation timeline.',
                'widget': self.change_exam_btn if hasattr(self, 'change_exam_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Set Alarm',
                'description': 'Set alarm, you can select custom songs or music from desired path.',
                'widget': self.set_alarm_btn if hasattr(self, 'set_alarm_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Alarm Sound',
                'description': 'For select custom sound that will play at every session start & end.',
                'widget': self.alarm_btn if hasattr(self, 'alarm_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Theme Toggle',
                'description': 'Switch between light and dark themes for comfortable studying.',
                'widget': self.theme_btn if hasattr(self, 'theme_btn') else None,
                'tab': 'plan'
            },
            
            # === PLAN MANAGEMENT BUTTONS ===
            {
                'title': 'Plan Selector',
                'description': 'Switch between different study plans using this dropdown. you can add new plan by click create new plan button',
                'widget': self.plan_dropdown if hasattr(self, 'plan_dropdown') else None,
                'tab': 'plan'
            },
            {
                'title': 'Create New Plan',
                'description': 'Click the üÜï button to create a new study plan.',
                'widget': self.new_plan_btn if hasattr(self, 'new_plan_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Undo Action',
                'description': 'Use ‚Ü© to undo your last action.',
                'widget': self.undo_btn if hasattr(self, 'undo_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Redo Action',
                'description': 'Use ‚Ü™ to redo an action you just undid.',
                'widget': self.redo_btn if hasattr(self, 'redo_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Add Study Session',
                'description': 'Click ‚ûï to add a new study sess.',
                'widget': self.add_btn if hasattr(self, 'add_btn') else None,
                'tab': 'plan'
            },
            {
            'title': 'Edit Session',
            'description': 'Modify session details.',
            'widget': self.plan_edit_btn if hasattr(self, 'plan_edit_btn') else None,
            'tab': 'plan'
            },
            {
                'title': 'Delete Session',
                'description': 'Remove unwanted sessions using the üóë delete button.',
                'widget': self.delete_btn if hasattr(self, 'delete_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Session History',
                'description': 'View Edit/Deleted session history with the üìñ button.',
                'widget': self.history_btn if hasattr(self, 'history_btn') else None,
                'tab': 'plan'
            },
            
            # === INTEGRATION BUTTONS ===
            {
                'title': 'Telegram Integration',
                'description': 'Connect your Telegram account to receive session Start/End notification, Study reports,\n\n you can also view/control session state through telegram bot, etc..\n\n setup procedure;\n\n 1) login to telegram from pc/laptop using chrome or any browser\n 2) click connect telegram button,\n\n it will redirect you telegram website then click open in web ,\n\n you are all done! Now your account will connect with out studytimer bot automatically,\n you will receive guide msg on your account ',
                'widget': self.telegram_btn if hasattr(self, 'telegram_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Test Telegram',
                'description': 'Test your Telegram connection to ensure notifications are working. you will get connection success notification on your account ',
                'widget': self.test_telegram_btn if hasattr(self, 'test_telegram_btn') else None,
                'tab': 'plan'
            },
            {
                'title': 'Email Reports',
                'description': 'Set up automatic email reports to get your daily report on everyday at 11:59 PM or when internet available, enter gmail id that want to receieve reports and click add button, you can also add more than 1 id, then check connction with test button',
                'widget': self.email_btn if hasattr(self, 'email_btn') else None,
                'tab': 'plan'
            },            
            
            # === LIVE SESSION TAB ===
            {
                'title': 'Live Session Tab',
                'description': 'Now let\'s explore the Live Session tab where you track active study sessions and compete with others!',
                'widget': None,
                'tab': 'live'
            },
            # Study tracking elements
            {
            'title': 'Study Days Counter',
            'description': 'Shows how many days you\'ve been studying for your current exam. This tracks your consistency and dedication over time. This will be reseted for every exam date change ',
            'widget': self.day_label if hasattr(self, 'day_label') else None,
            'tab': 'live',
            'highlight_color': '#27AE60'
            },
            {
                'title': 'Study Hours Bar Chart',
                'description': 'Visual bar chart showing your study hours for the last 3 days. Helps you track daily patterns and maintain consistency.',
                'widget': self.bar_canvas if hasattr(self, 'bar_canvas') else None,
                'tab': 'live',
                'highlight_color': '#E74C3C'
            },
            
            # Leaderboard panels
            {
                'title': 'Leaderboard Panel',
                'description': 'View the global leaderboard showing top performers. Compare your study time with others and stay motivated to climb the rankings! ensure internet connection to access leaderboard',
                'widget': self.lb_table if hasattr(self, 'lb_table') else None,
                'tab': 'live',
                'highlight_color': '#9B59B6'
            },
            {
                'title': 'Last Week Top Rankers',
                'description': 'See who were the top 3 performers last week. These are your champions to beat! Gold, Silver, and Bronze medals for the top achievers.',
                'widget': self.lb_top3 if hasattr(self, 'lb_top3') else None,
                'tab': 'live',
                'highlight_color': '#F39C12'
            },
            {
                'title': 'Graph analyser',
                'description': 'Visual representation of your study progress over time based on long and short term values, Keep long and short term indicating lines (red & blue) below required line (black doted line) to achieve your goal.',
                'widget': self.runrate_graph if hasattr(self, 'runrate_graph') else None,
                'tab': 'live',
                'highlight_color': '#3498DB'
            },
            
            {
                'title': 'Goal Progress Bar',
                'description': 'This red mark will indicate your custom targets btw exam date, you can set your short term targets like every "x" days.',
                'widget': self.progress_canvas if hasattr(self, 'progress_canvas') else None,
                'tab': 'live',
                'highlight_color': '#2ECC71'
            },
            {
                'title': 'Progress Duration',
                'description': 'Displays your current studied duration with your total goal duration. Goal duration = planned study hours/day * no of days for exam at the time of session duration/exam date modification',
                'widget': self.progress_text_label if hasattr(self, 'progress_text_label') else None,
                'tab': 'live',
                'highlight_color': '#3498DB'
            },
            {
            'title': 'Edit Custom Goal Indicator',
            'description': 'Click the ‚úé button to edit your custom short term goal like every "x" red mark will indicate. you can be more aware of your current progress',
            'widget': self.live_edit_btn if hasattr(self, 'live_edit_btn') else None,
            'tab': 'live',
            'highlight_color': '#F39C12'
            },
            {
                'title': 'Extra Study Button',
                'description': 'Start an extra study session beyond your planned schedule. Great for when you want to put in additional effort!',
                'widget': self.extra_study_btn if hasattr(self, 'extra_study_btn') else None,
                'tab': 'live',
                'highlight_color': '#F1C40F'
            },
            {
                'title': 'Pause Credit',
                'description': 'Shows accumulated extra studied time you can use. Take breaks without losing study momentum - your pause credit allows short breaks without increase wastage duration untill it fall to zero',
                'widget': self.pause_credit_label if hasattr(self, 'pause_credit_label') else None,
                'tab': 'live',
                'highlight_color': '#1976D2'
            },
            
            # === WASTAGE REPORT TAB ===
            {
                'title': 'Wastage Report Tab',
                'description': 'Finally, the Wastage Report tab shows detailed analysis of your study time efficiency and areas for improvement. Even app close duration on sheduled session time also will be recorded as wastage, so you can get precise data. ',
                'widget': None,
                'tab': 'wastage'
            },
            {
            'title': 'Today\'s Total',
            'description': 'Current day wastage summary.',
            'widget': self.today_total_label if hasattr(self, 'today_total_label') else None,
            'tab': 'wastage',
            'highlight_color': '#333333'
            },
            {
                'title': 'Reset Selected Entry',
                'description': 'Clear individual wastage record.',
                'widget': self.reset_button if hasattr(self, 'reset_button') else None,
                'tab': 'wastage',
                'highlight_color': '#FFC107'
            },
            {
                'title': 'Reset All Data',
                'description': 'Clear all wastage history.\n‚ö† This cannot be undone!',
                'widget': self.reset_all_button if hasattr(self, 'reset_all_button') else None,
                'tab': 'wastage',
                'highlight_color': '#DC3545'
            },
            # Add wastage tab widgets here when you identify them
            
            {
                'title': 'You\'re All Set!',
                'description': 'Congratulations! You now know all the features. Track your progress, compete on leaderboards, monitor study patterns, and achieve your goals! Good luck! üéì',
                'widget': None,
                'tab': None
            }
        ]
        
        self.guide = InteractiveGuide(self, guide_steps)
        self.guide.start()
        
        
    def reset_first_time_flag(self):
        """Reset the first time flag to show guide again"""
        try:
            # Use same AppData/Roaming/StudyTimer path as profile
            appdata_path = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
            profile_file = os.path.join(appdata_path, 'user_config.json')
            
            with open(profile_file, 'r') as f:
                config = json.load(f)
            config['first_time_completed'] = False
            with open(profile_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error resetting first time flag: {e}")
            

        
    def setup_notebook_effects(self):
        """Setup hover effects and cursor for notebook tabs"""
        style = ttk.Style()
        
        # Configure tab appearance and hover effects
        style.map('TNotebook.Tab',
            background=[
                ('selected', '#0078d4'),      # Active tab - blue
                ('active', '#e6f3ff'),        # Hover - light blue
                ('!active', '#f5f5f5')        # Normal - light gray
            ],
            foreground=[
                ('selected', 'white'),        # Active tab text - white
                ('active', '#0078d4'),        # Hover text - blue
                ('!active', 'black')          # Normal text - black
            ],
            focuscolor='none'
        )
        
        # Configure tab padding and appearance
        style.configure('TNotebook.Tab', 
            padding=[15, 10],               # More padding for better appearance
            font=('Arial', 10, 'normal')
        )
        
        # Add hand cursor
        def on_enter(event):
            event.widget.configure(cursor="hand2")
        
        def on_leave(event):
            event.widget.configure(cursor="")
        
        self.notebook.bind("<Enter>", on_enter)
        self.notebook.bind("<Leave>", on_leave)
        
    def add_hover_effect(self, button, hover_bg=None, hover_fg=None, normal_bg=None, normal_fg=None):
        """Add hover effect to a button"""
        # Get current colors if not specified
        if normal_bg is None:
            normal_bg = button.cget('bg')
        if normal_fg is None:
            normal_fg = button.cget('fg')
        
        # Set default hover colors if not specified
        if hover_bg is None:
            hover_bg = "#E8E8E8"  # Light gray
        if hover_fg is None:
            hover_fg = normal_fg
        
        # Set cursor to hand2 if not already set
        if button.cget('cursor') != 'hand2':
            button.config(cursor="hand2")
        
        def on_enter(event):
            button.config(bg=hover_bg, fg=hover_fg)
        
        def on_leave(event):
            button.config(bg=normal_bg, fg=normal_fg)
        
        button.bind("<Enter>", on_enter)
        button.bind("<Leave>", on_leave)
        
    

    # Add these methods to your existing app class

    def get_current_user_info(self):
        """Get current user name and ID from profile"""
        try:
            if os.path.exists(app_paths.profile_file):
                with open(app_paths.profile_file, "r", encoding="utf-8") as f:
                    profile_data = json.load(f)
                user_name = profile_data.get("user_name", "Unknown User").strip()
                user_id = profile_data.get("uid", "Unknown ID")
                return user_name, user_id
            else:
                return "Unknown User", "Unknown ID"
        except Exception as e:
            print(f"Error reading profile: {e}")
            return "Unknown User", "Unknown ID"

    def check_for_new_notifications(self):
        """Check for new replies from admin and show flash message if any"""
        try:
            user_name, user_id = self.get_current_user_info()
            unread_count = self.get_unread_notifications_count(user_id)
            
            if unread_count > 0:
                # Update bell icon with red badge
                self.update_notification_badge(unread_count)
                
                # Show flash message for unread notifications
                self.show_notification_flash(unread_count)
            else:
                # Remove red badge if no unread notifications
                self.update_notification_badge(0)
                
        except Exception as e:
            print(f"Error checking notifications: {e}")

    def get_unread_notifications_count(self, user_id):
        """Get count of unread notifications for current user"""
        try:
            import gspread
            
            # Get the encrypted gspread client
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback
                LB_CREDENTIALS = get_secret("LB_CREDENTIALS", None)
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    return 0
            
            # Open the spreadsheet
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Try to open 'reports' worksheet
            try:
                worksheet = spreadsheet.worksheet("reports")
            except gspread.WorksheetNotFound:
                return 0
            
            # Get all records
            records = worksheet.get_all_records()
            
            # Count unread replies for current user
            unread_count = 0
            for record in records:
                if (str(record.get("User ID", "")) == str(user_id) and 
                    record.get("Admin Reply", "").strip() and 
                    record.get("Reply Status", "").lower() != "read"):
                    unread_count += 1
            
            return unread_count
            
        except Exception as e:
            print(f"Error getting unread notifications count: {e}")
            return 0

    def show_notification_flash(self, count):
        """Show flash message for unread notifications - only once per session"""
        try:
            # Check if flash was already shown this session
            if hasattr(self, '_flash_shown_this_session') and self._flash_shown_this_session:
                return
            
            # Mark flash as shown for this session
            self._flash_shown_this_session = True
            
            # Create a temporary flash message window
            flash = tk.Toplevel(self)
            flash.title("New Notifications")
            flash.geometry("280x100")
            flash.resizable(False, False)
            flash.configure(bg="#E74C3C")
            
            # Center the flash window
            flash.transient(self)
            flash.geometry("+%d+%d" % (
                self.winfo_rootx() + 100,
                self.winfo_rooty() + 50
            ))
            
            # Flash message content - more compact
            message_label = tk.Label(
                flash,
                text=f"üîî {count} new notification{'s' if count > 1 else ''}",
                font=("Arial", 11, "bold"),
                bg="#E74C3C",
                fg="white"
            )
            message_label.pack(pady=20)
            
            # Auto-close after 2 seconds (shorter)
            flash.after(2000, flash.destroy)
            
            # Make flash window stay on top briefly
            flash.lift()
            flash.attributes('-topmost', True)
            flash.after(100, lambda: flash.attributes('-topmost', False))
            
        except Exception as e:
            print(f"Error showing notification flash: {e}")

    def update_notification_badge(self, count):
        """Update the bell icon with red badge if there are unread notifications"""
        try:
            if hasattr(self, 'notification_btn'):
                if count > 0:
                    # Show bell with red badge
                    self.notification_btn.config(
                        text=f"üîî {count}",
                        bg="#E74C3C",
                        fg="white"
                    )
                else:
                    # Show normal bell
                    self.notification_btn.config(
                        text="üîî",
                        bg="#95A5A6",
                        fg="white"
                    )
        except Exception as e:
            print(f"Error updating notification badge: {e}")

    def show_notifications_inbox(self):
        """Show the notifications inbox dialog - professional compact version"""
        user_name, user_id = self.get_current_user_info()
        
        # Create modal dialog with professional styling
        self.inbox_dialog = tk.Toplevel(self)
        self.inbox_dialog.title("Notifications")
        self.inbox_dialog.geometry("500x250")
        self.inbox_dialog.resizable(False, False)
        self.inbox_dialog.grab_set()
        
        # Configure dialog background
        self.inbox_dialog.configure(bg="#F8F9FA")
        
        # Center the dialog
        self.inbox_dialog.transient(self)
        self.inbox_dialog.geometry("+%d+%d" % (
            self.winfo_rootx() + 50,
            self.winfo_rooty() + 30
        ))
        
        # Main container with professional background
        main_frame = tk.Frame(self.inbox_dialog, bg="#FFFFFF", relief="flat", bd=1)
        main_frame.pack(fill="both", expand=True, padx=2, pady=2)
        
        # Header section with gradient effect (simulated with frame)
        header_frame = tk.Frame(main_frame, bg="#2C3E50", height=40)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        # Title in header with icon
        title_container = tk.Frame(header_frame, bg="#2C3E50")
        title_container.pack(expand=True)
        
        title_label = tk.Label(
            title_container,
            text="üì¨  NOTIFICATIONS",
            font=("Segoe UI", 11, "bold"),
            fg="#FFFFFF",
            bg="#2C3E50"
        )
        title_label.pack(pady=10)
        
        # Content area with padding
        content_frame = tk.Frame(main_frame, bg="#FFFFFF", padx=15, pady=10)
        content_frame.pack(fill="both", expand=True)
        
        # List container with border
        list_container = tk.Frame(content_frame, bg="#FFFFFF", relief="solid", bd=1)
        list_container.pack(fill="both", expand=True)
        
        # Create styled Treeview
        style = ttk.Style()
        
        # Configure Treeview colors and fonts
        style.configure("Notifications.Treeview",
                        background="#FFFFFF",
                        foreground="#2C3E50",
                        fieldbackground="#FFFFFF",
                        font=("Segoe UI", 9))
        
        style.configure("Notifications.Treeview.Heading",
                        background="#F1F3F5",
                        foreground="#495057",
                        font=("Segoe UI", 9, "bold"),
                        relief="flat")
        
        style.map("Notifications.Treeview",
                  background=[("selected", "#E3F2FD")],
                  foreground=[("selected", "#1976D2")])
        
        # Create Treeview with professional styling
        columns = ("Date", "Type", "Reply")
        self.notifications_tree = ttk.Treeview(
            list_container,
            columns=columns,
            show="tree headings",
            height=4,
            style="Notifications.Treeview",
            selectmode="browse"
        )
        
        # Configure columns with better proportions
        self.notifications_tree.column("#0", width=0, stretch=False)
        self.notifications_tree.column("Date", width=90, minwidth=90, stretch=False, anchor="center")
        self.notifications_tree.column("Type", width=110, minwidth=110, stretch=False, anchor="center")
        self.notifications_tree.column("Reply", width=265, minwidth=265, stretch=True, anchor="w")
        
        # Configure headings with better labels
        self.notifications_tree.heading("Date", text="DATE", anchor="center")
        self.notifications_tree.heading("Type", text="TYPE", anchor="center")
        self.notifications_tree.heading("Reply", text="ADMIN REPLY", anchor="w")
        
        # Professional scrollbar
        scrollbar = ttk.Scrollbar(
            list_container,
            orient="vertical",
            command=self.notifications_tree.yview
        )
        self.notifications_tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack treeview and scrollbar
        self.notifications_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Add alternating row colors tags
        self.notifications_tree.tag_configure('oddrow', background='#FAFAFA')
        self.notifications_tree.tag_configure('evenrow', background='#FFFFFF')
        self.notifications_tree.tag_configure('unread', foreground='#1976D2', font=("Segoe UI", 9, "bold"))
        
        # Load notifications using YOUR EXISTING METHOD
        self.load_user_notifications(user_id)
        
        # Apply styling to loaded notifications
        self.apply_notification_styling()
        
        # Footer section with separator
        separator = tk.Frame(content_frame, bg="#E9ECEF", height=1)
        separator.pack(fill="x", pady=(8, 0))
        
        # Professional button frame
        button_frame = tk.Frame(content_frame, bg="#FFFFFF")
        button_frame.pack(fill="x", pady=(10, 5))
        
        # View Reply button with hover effect
        self.view_reply_btn = tk.Button(
            button_frame,
            text="VIEW REPLY",
            font=("Segoe UI", 9, "bold"),
            bg="#1976D2",
            fg="white",
            bd=0,
            padx=20,
            pady=7,
            cursor="hand2",
            activebackground="#1565C0",
            activeforeground="white",
            command=self.view_selected_reply_and_mark_read
        )
        self.view_reply_btn.pack(side="left")
        
        # Close button with professional styling
        close_btn = tk.Button(
            button_frame,
            text="CLOSE",
            font=("Segoe UI", 9),
            bg="#6C757D",
            fg="white",
            bd=0,
            padx=20,
            pady=7,
            cursor="hand2",
            activebackground="#5A6268",
            activeforeground="white",
            command=self.close_inbox_dialog
        )
        close_btn.pack(side="right")
        
        # Bind hover effects
        self.add_button_hover_effects(self.view_reply_btn, "#1976D2", "#1565C0")
        self.add_button_hover_effects(close_btn, "#6C757D", "#5A6268")
        
        # Bind double-click to view reply
        self.notifications_tree.bind("<Double-Button-1>", lambda e: self.view_selected_reply_and_mark_read())
        
        # Update notification count after loading
        notification_count = len(self.notifications_tree.get_children())
        if notification_count > 0:
            count_label = tk.Label(
                content_frame,
                text=f"{notification_count} notification(s)",
                font=("Segoe UI", 9),
                fg="#6C757D",
                bg="#FFFFFF"
            )
            count_label.place(x=5, y=2)


    def apply_notification_styling(self):
        """Apply professional styling to loaded notifications"""
        items = self.notifications_tree.get_children()
        for index, item in enumerate(items):
            # Apply alternating row colors
            row_tag = 'evenrow' if index % 2 == 0 else 'oddrow'
            
            # Get current tags and add styling
            current_tags = list(self.notifications_tree.item(item, 'tags'))
            if row_tag not in current_tags:
                current_tags.append(row_tag)
            
            # Check if it's unread (you may need to adjust this based on your data structure)
            values = self.notifications_tree.item(item, 'values')
            if values and len(values) > 2:
                # If the reply column indicates unread (e.g., starts with "UNREAD" or is empty)
                reply_text = str(values[2])
                if "unread" in reply_text.lower() or reply_text == "" or reply_text == "No reply yet":
                    if 'unread' not in current_tags:
                        current_tags.append('unread')
            
            # Apply the tags
            self.notifications_tree.item(item, tags=current_tags)


    def add_button_hover_effects(self, button, normal_color, hover_color):
        """Add hover effects to buttons"""
        button.bind("<Enter>", lambda e: button.config(bg=hover_color))
        button.bind("<Leave>", lambda e: button.config(bg=normal_color))


    def close_inbox_dialog(self):
        """Close the notifications dialog"""
        if hasattr(self, 'inbox_dialog'):
            self.inbox_dialog.destroy()

    def load_user_notifications(self, user_id):
        """Load notifications for the current user from Google Sheets - compact version"""
        try:
            # Clear existing items
            for item in self.notifications_tree.get_children():
                self.notifications_tree.delete(item)
            
            import gspread
            
            # Get the encrypted gspread client
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback
                
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    # Show no connection message
                    self.notifications_tree.insert("", "end", values=("", "No connection", ""))
                    return
            
            # Open the spreadsheet
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Try to open 'reports' worksheet
            try:
                worksheet = spreadsheet.worksheet("reports")
            except gspread.WorksheetNotFound:
                # Show no data message
                self.notifications_tree.insert("", "end", values=("", "No reports", ""))
                return
            
            # Get all records
            records = worksheet.get_all_records()
            
            # Filter and display user's notifications with replies only
            user_notifications = []
            for i, record in enumerate(records):
                if (str(record.get("User ID", "")) == str(user_id) and 
                    record.get("Admin Reply", "").strip()):  # Only show items with replies
                    user_notifications.append((i + 2, record))  # +2 because row 1 is header
            
            if not user_notifications:
                self.notifications_tree.insert("", "end", values=("", "No replies yet", ""))
                return
            
            # Sort by timestamp (newest first)
            user_notifications.sort(key=lambda x: x[1].get("Timestamp", ""), reverse=True)
            
            for row_num, record in user_notifications:
                timestamp = record.get("Timestamp", "")
                request_type = record.get("Request Type", "")
                admin_reply = record.get("Admin Reply", "")
                reply_status = record.get("Reply Status", "New")
                
                # Format date - shorter
                try:
                    if timestamp:
                        dt = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")
                        formatted_date = dt.strftime("%m/%d")
                    else:
                        formatted_date = ""
                except:
                    formatted_date = timestamp[:5] if timestamp else ""
                
                # Truncate type and reply for compact display
                display_type = (request_type[:15] + "...") if len(request_type) > 15 else request_type
                display_reply = (admin_reply[:35] + "...") if len(admin_reply) > 35 else admin_reply
                
                # Add unread indicator
                if reply_status.lower() != "read":
                    display_reply = "üî¥ " + display_reply
                
                # Insert item
                item = self.notifications_tree.insert("", "end", values=(
                    formatted_date,
                    display_type,
                    display_reply
                ), tags=(f"row_{row_num}",))
        
        except Exception as e:
            print(f"Error loading notifications: {e}")
            self.notifications_tree.insert("", "end", values=("", f"Error: {str(e)}", ""))

    def mark_reply_as_read(self, row_num, dialog=None):
        """Mark a reply as read in Google Sheets"""
        try:
            import gspread
            
            # Get the encrypted gspread client
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback
                
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    raise Exception("No Google Sheets credentials available")
            
            # Open the spreadsheet
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Get the reports worksheet
            worksheet = spreadsheet.worksheet("reports")
            
            # Update the Reply Status column (column I - index 9)
            worksheet.update_cell(row_num, 9, "Read")
            
            print(f"[NOTIFICATION] Marked row {row_num} as read")
            
        except Exception as e:
            print(f"Error marking reply as read: {e}")
            raise e

    def view_selected_reply_and_mark_read(self):
        """View the full reply for selected notification and automatically mark as read"""
        selection = self.notifications_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a notification to view.")
            return
        
        try:
            # Get row number from tags
            item = selection[0]
            tags = self.notifications_tree.item(item, "tags")
            if not tags:
                return
            
            row_num = int(tags[0].replace("row_", ""))
            user_name, user_id = self.get_current_user_info()
            
            # Get full details from Google Sheets
            reply_data = self.get_reply_details(user_id, row_num)
            
            if reply_data and reply_data['admin_reply'].strip():
                # Mark as read FIRST
                try:
                    self.mark_reply_as_read(row_num)
                    print(f"Successfully marked row {row_num} as read")
                except Exception as e:
                    print(f"Error marking as read: {e}")
                
                # Show simple reply dialog
                self.show_simple_reply_dialog(reply_data)
                
                # Update bell icon and refresh list after marking as read
                try:
                    # Small delay to ensure Google Sheets is updated
                    self.after(500, lambda: self.refresh_after_read(user_id))
                except Exception as e:
                    print(f"Error refreshing after read: {e}")
            else:
                messagebox.showinfo("No Reply", "This notification doesn't have a reply yet.")
        
        except Exception as e:
            print(f"Error viewing reply: {e}")
            messagebox.showerror("Error", f"Failed to view reply: {str(e)}")

    def refresh_after_read(self, user_id):
        """Refresh notification count and list after marking as read"""
        try:
            # Update bell icon immediately
            unread_count = self.get_unread_notifications_count(user_id)
            self.update_notification_badge(unread_count)
            print(f"Updated badge count to: {unread_count}")
            
            # Refresh the notifications list if inbox is still open
            if hasattr(self, 'inbox_dialog') and self.inbox_dialog.winfo_exists():
                self.load_user_notifications(user_id)
                print("Refreshed inbox list")
        except Exception as e:
            print(f"Error in refresh_after_read: {e}")

    def close_inbox_dialog(self):
        """Close inbox dialog and refresh notification count"""
        try:
            self.inbox_dialog.destroy()
            # Refresh notification count after closing inbox with a small delay
            self.after(100, self.final_notification_refresh)
        except Exception as e:
            print(f"Error closing inbox dialog: {e}")

    def final_notification_refresh(self):
        """Final refresh of notification count"""
        try:
            user_name, user_id = self.get_current_user_info()
            unread_count = self.get_unread_notifications_count(user_id)
            self.update_notification_badge(unread_count)
            print(f"Final notification refresh - count: {unread_count}")
        except Exception as e:
            print(f"Error in final notification refresh: {e}")

    def show_simple_reply_dialog(self, reply_data):
        """Show simple reply dialog - only admin reply"""
        # Create reply dialog - compact
        reply_dialog = tk.Toplevel(self.inbox_dialog)
        reply_dialog.title("Admin Reply")
        reply_dialog.geometry("900x400")
        reply_dialog.resizable(False, False)
        reply_dialog.grab_set()
        
        # Center the dialog
        reply_dialog.transient(self.inbox_dialog)
        reply_dialog.geometry("+%d+%d" % (
            self.inbox_dialog.winfo_rootx() + 50,
            self.inbox_dialog.winfo_rooty() + 25
        ))
        
        # Main frame
        main_frame = tk.Frame(reply_dialog, padx=20, pady=15)
        main_frame.pack(fill="both", expand=True)
        
        # Title - simple
        title_label = tk.Label(
            main_frame,
            text="üí¨ Admin Reply",
            font=("Arial", 12, "bold"),
            fg="#27AE60"
        )
        title_label.pack(pady=(0, 10))
        
        # Admin Reply only
        reply_frame = tk.Frame(main_frame, bg="#E8F5E8", relief="solid", bd=1)
        reply_frame.pack(fill="both", expand=True, pady=(0, 15))
        
        reply_text_widget = tk.Text(
            reply_frame,
            font=("Arial", 10),
            wrap="word",
            relief="flat",
            bg="#E8F5E8",
            fg="#2C3E50"
        )
        reply_text_widget.pack(fill="both", expand=True, padx=10, pady=10)
        reply_text_widget.insert("1.0", reply_data['admin_reply'])
        reply_text_widget.config(state="disabled")
        
        # Close button only
        close_btn = tk.Button(
            main_frame,
            text="Close",
            font=("Arial", 10),
            bg="#95A5A6",
            fg="white",
            padx=20,
            pady=6,
            command=reply_dialog.destroy
        )
        close_btn.pack()

    def get_reply_details(self, user_id, row_num):
        """Get full reply details from Google Sheets"""
        try:
            import gspread
            
            # Get the encrypted gspread client
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback
                
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    return None
            
            # Open the spreadsheet
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Get the reports worksheet
            worksheet = spreadsheet.worksheet("reports")
            
            # Get the specific row
            row_data = worksheet.row_values(row_num)
            
            if len(row_data) >= 8:  # Ensure we have enough columns
                return {
                    "timestamp": row_data[0] if len(row_data) > 0 else "",
                    "user_name": row_data[1] if len(row_data) > 1 else "",
                    "user_id": row_data[2] if len(row_data) > 2 else "",
                    "request_type": row_data[3] if len(row_data) > 3 else "",
                    "feature_request": row_data[4] if len(row_data) > 4 else "",
                    "help_report": row_data[5] if len(row_data) > 5 else "",
                    "status": row_data[6] if len(row_data) > 6 else "",
                    "admin_reply": row_data[7] if len(row_data) > 7 else "",
                    "reply_status": row_data[8] if len(row_data) > 8 else "New",
                    "row_number": row_num
                }
            
            return None
            
        except Exception as e:
            print(f"Error getting reply details: {e}")
            return None

    # Remove the old complex show_reply_dialog method and mark_selected_as_read method
    # They are replaced by the simpler versions above

    def check_for_new_notifications(self):
        """Check for new replies from admin and show flash message if any - only once per session"""
        try:
            user_name, user_id = self.get_current_user_info()
            unread_count = self.get_unread_notifications_count(user_id)
            
            if unread_count > 0:
                # Update bell icon with red badge
                self.update_notification_badge(unread_count)
                
                # Show flash message for unread notifications (only once)
                self.show_notification_flash(unread_count)
            else:
                # Remove red badge if no unread notifications
                self.update_notification_badge(0)
                
        except Exception as e:
            print(f"Error checking notifications: {e}")

            help_text = tk.Text(
                scrollable_frame,
                height=4,
                font=("Arial", 9),
                wrap="word",
                relief="solid",
                bd=1,
                bg="#F8F9FA"
            )
            help_text.pack(fill="x", pady=(10, 5))
            help_text.insert("1.0", reply_data['help_report'])
            help_text.config(state="disabled")
        
        # Admin Reply
        if reply_data['admin_reply'].strip():
            tk.Label(
                scrollable_frame,
                text="üí¨ Admin Reply:",
                font=("Arial", 10, "bold"),
                fg="#27AE60",
                anchor="w"
            ).pack(fill="x", pady=(20, 5))
            
            reply_frame = tk.Frame(scrollable_frame, bg="#E8F5E8", relief="solid", bd=1)
            reply_frame.pack(fill="x", pady=(0, 10))
            
            reply_text_widget = tk.Text(
                reply_frame,
                height=6,
                font=("Arial", 10),
                wrap="word",
                relief="flat",
                bg="#E8F5E8",
                fg="#2C3E50"
            )
            reply_text_widget.pack(fill="x", padx=10, pady=10)
            reply_text_widget.insert("1.0", reply_data['admin_reply'])
            reply_text_widget.config(state="disabled")
        else:
            tk.Label(
                scrollable_frame,
                text="‚è≥ No reply yet. We'll get back to you soon!",
                font=("Arial", 10, "italic"),
                fg="#95A5A6",
                anchor="w"
            ).pack(fill="x", pady=(20, 10))
        
        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Buttons frame
        button_frame = tk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(20, 0))
        
        # Mark as Read button (only if there's a reply)
        if reply_data['admin_reply'].strip() and reply_data['reply_status'].lower() != "read":
            mark_read_btn = tk.Button(
                button_frame,
                text="Mark as Read",
                font=("Arial", 10, "bold"),
                bg="#27AE60",
                fg="white",
                padx=20,
                pady=8,
                command=lambda: self.mark_reply_as_read(reply_data['row_number'], reply_dialog)
            )
            mark_read_btn.pack(side="left", padx=(0, 10))
        
        # Close button
        close_btn = tk.Button(
            button_frame,
            text="Close",
            font=("Arial", 10),
            bg="#95A5A6",
            fg="white",
            padx=20,
            pady=8,
            command=reply_dialog.destroy
        )
        close_btn.pack(side="right")

    def mark_selected_as_read(self):
        """Mark selected notification as read"""
        selection = self.notifications_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a notification to mark as read.")
            return
        
        try:
            # Get row number from tags
            item = selection[0]
            tags = self.notifications_tree.item(item, "tags")
            if not tags:
                return
            
            row_num = int(tags[0].replace("row_", ""))
            
            # Mark as read in Google Sheets
            self.mark_reply_as_read(row_num)
            
            # Refresh the list
            user_name, user_id = self.get_current_user_info()
            self.load_user_notifications(user_id)
            
            messagebox.showinfo("Success", "Notification marked as read.")
            
        except Exception as e:
            print(f"Error marking as read: {e}")
            messagebox.showerror("Error", f"Failed to mark as read: {str(e)}")

    def mark_reply_as_read(self, row_num, dialog=None):
        """Mark a reply as read in Google Sheets"""
        try:
            import gspread
            
            # Get the encrypted gspread client
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback
                
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    raise Exception("No Google Sheets credentials available")
            
            # Open the spreadsheet
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Get the reports worksheet
            worksheet = spreadsheet.worksheet("reports")
            
            # Update the Reply Status column (column I - index 9)
            worksheet.update_cell(row_num, 9, "Read")
            
            print(f"[NOTIFICATION] Marked row {row_num} as read")
            
            # Close dialog if provided
            if dialog:
                dialog.destroy()
            
            # Update notification badge
            user_name, user_id = self.get_current_user_info()
            unread_count = self.get_unread_notifications_count(user_id)
            self.update_notification_badge(unread_count)
            
        except Exception as e:
            print(f"Error marking reply as read: {e}")
            raise e

    def close_inbox_dialog(self):
        """Close inbox dialog and refresh notification count"""
        try:
            self.inbox_dialog.destroy()
            # Refresh notification count after closing inbox
            self.check_for_new_notifications()
        except:
            pass

    def show_help_support_dialog(self):
        """Show the help and support dialog - professional version"""
        # Get current user info
        user_name, user_id = self.get_current_user_info()
        
        # Create modal dialog with professional styling
        self.help_dialog = tk.Toplevel(self)
        self.help_dialog.title("Help & Support")
        self.help_dialog.geometry("480x580")
        self.help_dialog.resizable(False, False)
        self.help_dialog.grab_set()
        
        # Configure dialog background
        self.help_dialog.configure(bg="#F8F9FA")
        
        # Center the dialog
        self.help_dialog.transient(self)
        self.help_dialog.geometry("+%d+%d" % (
            self.winfo_rootx() + 50,
            self.winfo_rooty() + 50
        ))
        
        # Main container
        main_container = tk.Frame(self.help_dialog, bg="#FFFFFF", relief="flat", bd=1)
        main_container.pack(fill="both", expand=True, padx=2, pady=2)
        
        # Header with gradient effect
        header_frame = tk.Frame(main_container, bg="#2C3E50", height=50)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        # Header content
        header_content = tk.Frame(header_frame, bg="#2C3E50")
        header_content.pack(expand=True)
        
        title_label = tk.Label(
            header_content,
            text="üõü  HELP & SUPPORT CENTER",
            font=("Segoe UI", 12, "bold"),
            fg="#FFFFFF",
            bg="#2C3E50"
        )
        title_label.pack(pady=13)
        
        # Content area
        content_frame = tk.Frame(main_container, bg="#FFFFFF", padx=25, pady=20)
        content_frame.pack(fill="both", expand=True)
        
        # User info card with modern styling
        user_card = tk.Frame(content_frame, bg="#F0F8FF", relief="flat", bd=0)
        user_card.pack(fill="x", pady=(0, 15))
        
        # User info with icon and styling
        user_info_container = tk.Frame(user_card, bg="#F0F8FF")
        user_info_container.pack(pady=10, padx=15)
        
        user_label = tk.Label(
            user_info_container,
            text=f"üë§  {user_name}",
            font=("Segoe UI Semibold", 10),
            bg="#F0F8FF",
            fg="#2C3E50"
        )
        user_label.pack(side="left")
        
        status_label = tk.Label(
            user_info_container,
            text="‚óè Online",
            font=("Segoe UI", 9),
            bg="#F0F8FF",
            fg="#28A745"
        )
        status_label.pack(side="left", padx=(15, 0))
        
        # Response time banner with icon
        banner_frame = tk.Frame(content_frame, bg="#E3F2FD", relief="flat", bd=0)
        banner_frame.pack(fill="x", pady=(0, 20))
        
        banner_content = tk.Frame(banner_frame, bg="#E3F2FD")
        banner_content.pack(pady=12, padx=15)
        
        tk.Label(
            banner_content,
            text="‚ö°",
            font=("Segoe UI", 14),
            bg="#E3F2FD",
            fg="#1976D2"
        ).pack(side="left", padx=(0, 8))
        
        tk.Label(
            banner_content,
            text="Quick Response",
            font=("Segoe UI Semibold", 10),
            bg="#E3F2FD",
            fg="#1976D2"
        ).pack(side="left", anchor="w")
        
        tk.Label(
            banner_content,
            text="‚Ä¢ Typically within 24 hours",
            font=("Segoe UI", 9),
            bg="#E3F2FD",
            fg="#546E7A"
        ).pack(side="left", padx=(8, 0))
        
        # Tab-like selector for request type
        tab_frame = tk.Frame(content_frame, bg="#FFFFFF")
        tab_frame.pack(fill="x", pady=(0, 15))
        
        # Request type variable
        self.request_type = tk.StringVar(value="feature")
        
        # Feature Request Tab
        self.feature_tab = tk.Frame(tab_frame, bg="#1976D2", relief="flat", bd=0)
        self.feature_tab.pack(side="left", fill="x", expand=True, padx=(0, 2))
        
        self.feature_tab_btn = tk.Label(
            self.feature_tab,
            text="üí° FEATURE REQUEST",
            font=("Segoe UI Semibold", 9),
            bg="#1976D2",
            fg="white",
            pady=8,
            cursor="hand2"
        )
        self.feature_tab_btn.pack(fill="both", expand=True)
        self.feature_tab_btn.bind("<Button-1>", lambda e: self.switch_tab("feature"))
        
        # Help/Bug Report Tab
        self.help_tab = tk.Frame(tab_frame, bg="#E0E0E0", relief="flat", bd=0)
        self.help_tab.pack(side="left", fill="x", expand=True, padx=(2, 0))
        
        self.help_tab_btn = tk.Label(
            self.help_tab,
            text="üêõ HELP & BUG REPORT",
            font=("Segoe UI Semibold", 9),
            bg="#E0E0E0",
            fg="#757575",
            pady=8,
            cursor="hand2"
        )
        self.help_tab_btn.pack(fill="both", expand=True)
        self.help_tab_btn.bind("<Button-1>", lambda e: self.switch_tab("help"))
        
        # Content container for both sections
        self.content_container = tk.Frame(content_frame, bg="#FFFFFF")
        self.content_container.pack(fill="both", expand=True, pady=(0, 15))
        
        # Feature Request Content (initially visible)
        self.feature_content = tk.Frame(self.content_container, bg="#FFFFFF")
        self.feature_content.pack(fill="both", expand=True)
        
        # Feature request header
        feature_header = tk.Frame(self.feature_content, bg="#FFFFFF")
        feature_header.pack(fill="x", pady=(0, 10))
        
        tk.Label(
            feature_header,
            text="Suggest New Features",
            font=("Segoe UI Semibold", 11),
            bg="#FFFFFF",
            fg="#2C3E50"
        ).pack(side="left")
        
        tk.Label(
            feature_header,
            text="Help us improve!",
            font=("Segoe UI", 9),
            bg="#FFFFFF",
            fg="#7F8C8D"
        ).pack(side="left", padx=(10, 0))
        
        # Feature text area with border
        feature_text_frame = tk.Frame(self.feature_content, bg="#E8E8E8", relief="flat", bd=1)
        feature_text_frame.pack(fill="both", expand=True)
        
        self.feature_text = tk.Text(
            feature_text_frame,
            height=8,
            font=("Segoe UI", 10),
            wrap="word",
            relief="flat",
            bd=0,
            padx=10,
            pady=10,
            bg="#FAFAFA",
            fg="#2C3E50"
        )
        self.feature_text.pack(fill="both", expand=True, padx=1, pady=1)
        
        # Placeholder text for feature request
        self.feature_text.insert("1.0", "Describe your feature idea here...")
        self.feature_text.bind("<FocusIn>", lambda e: self.clear_placeholder(self.feature_text, "Describe your feature idea here..."))
        self.feature_text.bind("<FocusOut>", lambda e: self.add_placeholder(self.feature_text, "Describe your feature idea here..."))
        
        # Help/Bug Report Content (initially hidden)
        self.help_content = tk.Frame(self.content_container, bg="#FFFFFF")
        
        # Help request header
        help_header = tk.Frame(self.help_content, bg="#FFFFFF")
        help_header.pack(fill="x", pady=(0, 10))
        
        tk.Label(
            help_header,
            text="Report an Issue",
            font=("Segoe UI Semibold", 11),
            bg="#FFFFFF",
            fg="#2C3E50"
        ).pack(side="left")
        
        tk.Label(
            help_header,
            text="We're here to help!",
            font=("Segoe UI", 9),
            bg="#FFFFFF",
            fg="#7F8C8D"
        ).pack(side="left", padx=(10, 0))
        
        # Priority selector
        priority_frame = tk.Frame(self.help_content, bg="#FFFFFF")
        priority_frame.pack(fill="x", pady=(0, 10))
        
        tk.Label(
            priority_frame,
            text="Priority:",
            font=("Segoe UI", 9),
            bg="#FFFFFF",
            fg="#546E7A"
        ).pack(side="left", padx=(0, 10))
        
        self.priority_var = tk.StringVar(value="Normal")
        priorities = ["Low", "Normal", "High", "Critical"]
        priority_colors = {"Low": "#28A745", "Normal": "#17A2B8", "High": "#FFC107", "Critical": "#DC3545"}
        
        for priority in priorities:
            rb = tk.Radiobutton(
                priority_frame,
                text=priority,
                variable=self.priority_var,
                value=priority,
                font=("Segoe UI", 9),
                bg="#FFFFFF",
                fg=priority_colors[priority],
                activebackground="#FFFFFF",
                selectcolor="#FFFFFF",
                cursor="hand2"
            )
            rb.pack(side="left", padx=(0, 15))
        
        # Help text area with border
        help_text_frame = tk.Frame(self.help_content, bg="#E8E8E8", relief="flat", bd=1)
        help_text_frame.pack(fill="both", expand=True, pady=(10, 0))
        
        self.help_text = tk.Text(
            help_text_frame,
            height=6,
            font=("Segoe UI", 10),
            wrap="word",
            relief="flat",
            bd=0,
            padx=10,
            pady=10,
            bg="#FAFAFA",
            fg="#2C3E50"
        )
        self.help_text.pack(fill="both", expand=True, padx=1, pady=1)
        
        # Placeholder text for help request
        self.help_text.insert("1.0", "Describe your issue or question...")
        self.help_text.bind("<FocusIn>", lambda e: self.clear_placeholder(self.help_text, "Describe your issue or question..."))
        self.help_text.bind("<FocusOut>", lambda e: self.add_placeholder(self.help_text, "Describe your issue or question..."))
        
        # Character counter
        self.char_counter = tk.Label(
            content_frame,
            text="0 / 500 characters",
            font=("Segoe UI", 8),
            bg="#FFFFFF",
            fg="#95A5A6"
        )
        self.char_counter.pack(anchor="e", pady=(5, 10))
        
        # Bind text change event for character counting
        self.feature_text.bind("<KeyRelease>", lambda e: self.update_char_counter(self.feature_text))
        self.help_text.bind("<KeyRelease>", lambda e: self.update_char_counter(self.help_text))
        
        # Footer separator
        separator = tk.Frame(content_frame, bg="#E9ECEF", height=1)
        separator.pack(fill="x", pady=(0, 15))
        
        # Buttons frame
        button_frame = tk.Frame(content_frame, bg="#FFFFFF")
        button_frame.pack(fill="x")
        
        # Submit button with modern styling
        self.submit_btn = tk.Button(
            button_frame,
            text="‚úì  SUBMIT REQUEST",
            font=("Segoe UI Semibold", 10),
            bg="#28A745",
            fg="white",
            bd=0,
            padx=25,
            pady=10,
            cursor="hand2",
            activebackground="#218838",
            activeforeground="white",
            command=lambda: self.submit_help_request(user_name, user_id)
        )
        self.submit_btn.pack(side="right")
        
        # Cancel button
        cancel_btn = tk.Button(
            button_frame,
            text="CANCEL",
            font=("Segoe UI", 10),
            bg="#6C757D",
            fg="white",
            bd=0,
            padx=25,
            pady=10,
            cursor="hand2",
            activebackground="#5A6268",
            activeforeground="white",
            command=self.help_dialog.destroy
        )
        cancel_btn.pack(side="right", padx=(0, 10))
        
        # Add hover effects
        self.add_button_hover_effects(self.submit_btn, "#28A745", "#218838")
        self.add_button_hover_effects(cancel_btn, "#6C757D", "#5A6268")


    def switch_tab(self, tab_type):
        """Switch between Feature Request and Help tabs"""
        if tab_type == "feature":
            self.request_type.set("feature")
            # Update tab colors
            self.feature_tab.configure(bg="#1976D2")
            self.feature_tab_btn.configure(bg="#1976D2", fg="white")
            self.help_tab.configure(bg="#E0E0E0")
            self.help_tab_btn.configure(bg="#E0E0E0", fg="#757575")
            # Show feature content, hide help content
            self.help_content.pack_forget()
            self.feature_content.pack(fill="both", expand=True)
            # Update character counter
            self.update_char_counter(self.feature_text)
        else:
            self.request_type.set("help")
            # Update tab colors
            self.help_tab.configure(bg="#1976D2")
            self.help_tab_btn.configure(bg="#1976D2", fg="white")
            self.feature_tab.configure(bg="#E0E0E0")
            self.feature_tab_btn.configure(bg="#E0E0E0", fg="#757575")
            # Show help content, hide feature content
            self.feature_content.pack_forget()
            self.help_content.pack(fill="both", expand=True)
            # Update character counter
            self.update_char_counter(self.help_text)


    def clear_placeholder(self, text_widget, placeholder):
        """Clear placeholder text when focused"""
        if text_widget.get("1.0", "end-1c") == placeholder:
            text_widget.delete("1.0", "end")
            text_widget.configure(fg="#2C3E50")


    def add_placeholder(self, text_widget, placeholder):
        """Add placeholder text when unfocused and empty"""
        if text_widget.get("1.0", "end-1c") == "":
            text_widget.insert("1.0", placeholder)
            text_widget.configure(fg="#95A5A6")


    def update_char_counter(self, text_widget):
        """Update character counter"""
        text = text_widget.get("1.0", "end-1c")
        # Don't count placeholder text
        if text in ["Describe your feature idea here...", "Describe your issue or question..."]:
            count = 0
        else:
            count = len(text)
        
        self.char_counter.configure(text=f"{count} / 500 characters")
        
        # Change color if approaching limit
        if count > 450:
            self.char_counter.configure(fg="#DC3545")
        elif count > 400:
            self.char_counter.configure(fg="#FFC107")
        else:
            self.char_counter.configure(fg="#95A5A6")


    def submit_help_request(self, user_name, user_id):
        """Submit the help request to Google Sheets"""
        request_type = self.request_type.get()
        
        # Get text from appropriate field based on selected tab
        if request_type == "feature":
            feature_request = self.feature_text.get("1.0", tk.END).strip()
            help_report = ""
            placeholder = "Describe your feature idea here..."
            
            # Check if it's just placeholder text
            if feature_request == placeholder:
                feature_request = ""
        else:
            feature_request = ""
            help_report = self.help_text.get("1.0", tk.END).strip()
            placeholder = "Describe your issue or question..."
            
            # Check if it's just placeholder text
            if help_report == placeholder:
                help_report = ""
            
            # Add priority to help report
            if help_report:
                priority = self.priority_var.get()
                help_report = f"[Priority: {priority}]\n{help_report}"
        
        # Validate input
        if not feature_request and not help_report:
            self.show_custom_message(
                self.help_dialog,
                "warning",
                "Input Required",
                "Please fill in at least one field before submitting."
            )
            return
        
        # Check character limit
        if len(feature_request) > 500 or len(help_report) > 500:
            self.show_custom_message(
                self.help_dialog,
                "warning",
                "Text Too Long",
                "Please limit your request to 500 characters."
            )
            return
        
        # Try to save to Google Sheets
        try:
            self.save_help_to_gsheets(user_name, user_id, feature_request, help_report)
            self.show_custom_message(
                self.help_dialog,
                "success",
                "Request Submitted Successfully!",
                "Thank you! Your request has been submitted.\nWe'll get back to you within 24 hours.",
                callback=lambda: self.help_dialog.destroy()
            )
        except Exception as e:
            print(f"Google Sheets save failed: {e}")
            # Fallback: Save locally and show different message
            try:
                self.save_help_locally(user_name, user_id, feature_request, help_report)
                self.show_custom_message(
                    self.help_dialog,
                    "info",
                    "Request Saved Locally",
                    "Your request has been saved locally.\nWe'll process it when connection is restored.",
                    callback=lambda: self.help_dialog.destroy()
                )
            except Exception as local_error:
                self.show_custom_message(
                    self.help_dialog,
                    "error",
                    "Submission Error",
                    f"Failed to submit your request.\nError: {str(local_error)}"
                )


    def show_custom_message(self, parent, msg_type, title, message, callback=None):
        """Show a custom styled message popup"""
        # Create custom popup window
        popup = tk.Toplevel(parent)
        popup.title(title)  # Keep title for taskbar visibility
        popup.resizable(False, False)
        popup.configure(bg="#FFFFFF")
        
        # Don't use overrideredirect to ensure it's visible
        # popup.overrideredirect(True)  # Commented out to keep window controls
        
        # Make it transient to parent
        popup.transient(parent)
        
        # Update parent to ensure we get correct position
        parent.update_idletasks()
        popup.update_idletasks()
        
        # Set size first
        popup.geometry("380x200")
        
        # Calculate center position
        parent_x = parent.winfo_rootx()
        parent_y = parent.winfo_rooty()
        parent_width = parent.winfo_width()
        parent_height = parent.winfo_height()
        
        popup_width = 380
        popup_height = 200
        
        # Calculate centered position
        x = parent_x + (parent_width // 2) - (popup_width // 2)
        y = parent_y + (parent_height // 2) - (popup_height // 2)
        
        # Ensure it's not off-screen
        x = max(0, x)
        y = max(0, y)
        
        # Apply the position
        popup.geometry(f"{popup_width}x{popup_height}+{x}+{y}")
        
        # Add border
        border_frame = tk.Frame(popup, bg="#E0E0E0", bd=2, relief="solid")
        border_frame.pack(fill="both", expand=True, padx=0, pady=0)
        
        # Main content frame
        content = tk.Frame(border_frame, bg="#FFFFFF")
        content.pack(fill="both", expand=True)
        
        # Icon and color based on message type
        icons = {
            "success": ("‚úì", "#28A745", "#D4EDDA", "#155724"),
            "warning": ("‚ö†", "#FFC107", "#FFF3CD", "#856404"),
            "error": ("‚úï", "#DC3545", "#F8D7DA", "#721C24"),
            "info": ("‚Ñπ", "#17A2B8", "#D1ECF1", "#0C5460")
        }
        
        icon, icon_color, bg_color, text_color = icons.get(msg_type, icons["info"])
        
        # Header with icon
        header = tk.Frame(content, bg=icon_color, height=50)
        header.pack(fill="x")
        header.pack_propagate(False)
        
        # Icon label
        icon_label = tk.Label(
            header,
            text=icon,
            font=("Segoe UI", 20),
            bg=icon_color,
            fg="#FFFFFF"
        )
        icon_label.pack(expand=True)
        
        # Message area
        msg_frame = tk.Frame(content, bg=bg_color, padx=20, pady=15)
        msg_frame.pack(fill="both", expand=True)
        
        # Title
        title_label = tk.Label(
            msg_frame,
            text=title,
            font=("Segoe UI Semibold", 11),
            bg=bg_color,
            fg=text_color
        )
        title_label.pack(anchor="w", pady=(0, 5))
        
        # Message
        msg_label = tk.Label(
            msg_frame,
            text=message,
            font=("Segoe UI", 9),
            bg=bg_color,
            fg=text_color,
            justify="left",
            wraplength=340
        )
        msg_label.pack(anchor="w")
        
        # Button frame
        btn_frame = tk.Frame(content, bg="#FFFFFF", pady=10)
        btn_frame.pack(fill="x")
        
        # For success messages, show two buttons
        if msg_type == "success":
            # OK button
            ok_btn = tk.Button(
                btn_frame,
                text="OK",
                font=("Segoe UI", 10),
                bg=icon_color,
                fg="#FFFFFF",
                bd=0,
                padx=30,
                pady=6,
                cursor="hand2",
                command=lambda: self.close_popup(popup, callback)
            )
            ok_btn.pack(side="left", padx=5)
            
            # Auto-close label
            auto_close_label = tk.Label(
                btn_frame,
                text="(Auto-closing in 5 seconds)",
                font=("Segoe UI", 8),
                bg="#FFFFFF",
                fg="#6C757D"
            )
            auto_close_label.pack(side="left", padx=10)
            
            # Auto close after 5 seconds (increased from 3)
            popup.after(5000, lambda: self.safe_close_popup(popup, callback))
        else:
            # Single OK button for other message types
            ok_btn = tk.Button(
                btn_frame,
                text="OK",
                font=("Segoe UI", 10),
                bg=icon_color,
                fg="#FFFFFF",
                bd=0,
                padx=30,
                pady=6,
                cursor="hand2",
                command=lambda: self.close_popup(popup, callback)
            )
            ok_btn.pack()
        
        # Add hover effect
        darker_color = self.darken_color(icon_color)
        ok_btn.bind("<Enter>", lambda e: ok_btn.config(bg=darker_color))
        ok_btn.bind("<Leave>", lambda e: ok_btn.config(bg=icon_color))
        
        # Make popup modal and bring to front
        popup.grab_set()
        popup.focus_set()
        popup.lift()  # Bring window to front
        popup.attributes('-topmost', True)  # Keep on top
        popup.after(100, lambda: popup.attributes('-topmost', False))  # Remove topmost after showing
        
        # Allow closing with Escape key and Enter key
        popup.bind("<Escape>", lambda e: self.close_popup(popup, callback))
        popup.bind("<Return>", lambda e: self.close_popup(popup, callback))
        
        # Force update to ensure it's visible
        popup.update()
        
        return popup


    def safe_close_popup(self, popup, callback=None):
        """Safely close popup if it still exists"""
        try:
            if popup.winfo_exists():
                self.close_popup(popup, callback)
        except:
            pass  # Window already closed


    def close_popup(self, popup, callback=None):
        """Close the custom popup and execute callback if provided"""
        popup.destroy()
        if callback:
            callback()


    def darken_color(self, color):
        """Darken a hex color by 20%"""
        # Convert hex to RGB
        color = color.lstrip('#')
        r, g, b = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
        
        # Darken by 20%
        r = int(r * 0.8)
        g = int(g * 0.8)
        b = int(b * 0.8)
        
        # Convert back to hex
        return f"#{r:02x}{g:02x}{b:02x}"

    def save_help_to_gsheets(self, user_name, user_id, feature_request, help_report):
        """Save the help/report data to Google Sheets using existing SheetSync connection"""
        try:
            import gspread
            
            # Get the encrypted gspread client (same as SheetSync uses)
            gc = get_encrypted_gspread_client()
            
            if not gc:
                # Try file fallback like SheetSync does
                
                if LB_CREDENTIALS and os.path.exists(LB_CREDENTIALS):
                    try:
                        gc = gspread_client
                    except Exception:
                        from oauth2client.service_account import ServiceAccountCredentials
                        scope = ["https://www.googleapis.com/auth/spreadsheets","https://www.googleapis.com/auth/drive"]
                        creds = ServiceAccountCredentials.from_json_keyfile_name(LB_CREDENTIALS, scope)
                        gc = gspread.authorize(creds)
                else:
                    raise Exception("No Google Sheets credentials available")
            
            # Open the same spreadsheet as SheetSync uses
            sheet_id = get_secret("LB_SHEET_ID")
            
            if sheet_id.startswith("http"):
                spreadsheet = gc.open_by_url(sheet_id)
            else:
                spreadsheet = gc.open_by_key(sheet_id)
            
            # Try to open 'reports' worksheet, create if it doesn't exist
            try:
                worksheet = spreadsheet.worksheet("reports")
            except gspread.WorksheetNotFound:
                # Create the reports worksheet with headers including the new columns
                worksheet = spreadsheet.add_worksheet(title="reports", rows=1000, cols=9)
                headers = [
                    "Timestamp",
                    "User Name",
                    "User ID",
                    "Request Type",
                    "Feature Request",
                    "Help/Bug Report",
                    "Status",
                    "Admin Reply",        # NEW COLUMN FOR ADMIN REPLIES
                    "Reply Status"        # NEW COLUMN FOR REPLY STATUS (New/Read)
                ]
                worksheet.append_row(headers)
            
            # Check if we need to add the new columns to existing sheet
            try:
                headers = worksheet.row_values(1)
                if len(headers) < 9:
                    # Add missing headers
                    if len(headers) < 8:
                        worksheet.update_cell(1, 8, "Admin Reply")
                    if len(headers) < 9:
                        worksheet.update_cell(1, 9, "Reply Status")
            except:
                pass
            
            # Prepare data to insert
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Determine request type
            request_type = []
            if feature_request:
                request_type.append("Feature Request")
            if help_report:
                request_type.append("Help/Bug Report")
            request_type_str = " & ".join(request_type)
            
            # Add the data
            row_data = [
                timestamp,
                user_name,
                str(user_id),
                request_type_str,
                feature_request,
                help_report,
                "New",
                "",           # Empty admin reply initially
                "New"         # Reply status starts as "New"
            ]
            
            worksheet.append_row(row_data)
            print(f"[HELP] Saved to reports sheet: {user_name} ({user_id}) - {request_type_str}")
            
        except Exception as e:
            print(f"Error saving help request to Google Sheets: {e}")
            raise e

    def save_help_locally(self, user_name, user_id, feature_request, help_report):
        """Save help request locally as fallback when Google Sheets is unavailable"""
        try:
            # Create reports directory if it doesn't exist
            reports_dir = os.path.dirname(app_paths.profile_file)
            reports_file = os.path.join(reports_dir, "help_reports.json")
            
            # Prepare data
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            request_type = []
            if feature_request:
                request_type.append("Feature Request")
            if help_report:
                request_type.append("Help/Bug Report")
            request_type_str = " & ".join(request_type)
            
            report_data = {
                "timestamp": timestamp,
                "user_name": user_name,
                "user_id": str(user_id),
                "request_type": request_type_str,
                "feature_request": feature_request,
                "help_report": help_report,
                "status": "New",
                "admin_reply": "",
                "reply_status": "New",
                "sync_status": "Pending"
            }
            
            # Load existing reports
            reports = []
            if os.path.exists(reports_file):
                try:
                    with open(reports_file, "r", encoding="utf-8") as f:
                        reports = json.load(f)
                except:
                    reports = []
            
            # Add new report
            reports.append(report_data)
            
            # Save back to file
            with open(reports_file, "w", encoding="utf-8") as f:
                json.dump(reports, f, indent=2, ensure_ascii=False)
            
            print(f"[HELP] Saved locally: {user_name} ({user_id}) - {request_type_str}")
            
        except Exception as e:
            print(f"Error saving help request locally: {e}")
            raise e
            
    def periodic_notification_check(self):
        """Periodically check for new notifications"""
        try:
            self.check_for_new_notifications()
            # Schedule next check
            self.after(300000, self.periodic_notification_check)  # Check every 5 minutes
        except Exception as e:
            print(f"Error in periodic notification check: {e}")
            # Schedule next check even if this one failed
            self.after(300000, self.periodic_notification_check)
        
    def get_current_timer_state(self):
        """Helper method to get current timer state for Telegram commands"""
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        return {
            'in_session': idx is not None,
            'extra_study_running': getattr(self, 'extra_study_running', False),
            'timer_running': getattr(self, 'timer_running', False)  # Assuming you have this attribute
        }
        
    def unhide_files_manually(self):
        """Manual unhide function"""
        files_directory = os.path.join(os.getenv('APPDATA'), 'StudyTimer')
        
        csv_files = glob.glob(os.path.join(files_directory, "*.csv"))
        json_files = glob.glob(os.path.join(files_directory, "*.json"))
        files = csv_files + json_files
        
        for file_path in files:
            subprocess.run(['attrib', '-H', '-R', '-S', file_path], shell=True)
        
        print(f"Manually unhidden {len(files)} files")
        # Optional: Show message box
        import tkinter.messagebox as msgbox
        msgbox.showinfo("Files Unhidden", f"Made {len(files)} files visible and editable") 
        
    def switch_plan(self, event=None):
        """Switch to selected plan and refresh UI."""
        name = self.plan_var.get()
        if name in self.plans:
            self.current_plan_name = name
            self.schedule = self.plans[name]

            # ‚úÖ Save the last active plan
            save_last_active_plan(name)
            # Mark this plan as (re)activated right now
            _record_plan_activation(name)
            
            # ‚úÖ Register all sessions in this plan
            self._register_all_plan_sessions()
            
            self.refresh_plan_tree()
            
            # Refresh wastage tab to show new plan's data
            try:
                self.refresh_wastage()
            except Exception as e:
                print(f"Error refreshing wastage after plan switch: {e}")
                
    def reload_plans_from_disk(self):
        """Reload plans from disk and refresh UI completely."""
        print("üîÑ reload_plans_from_disk called")
        
        # SAVE current plan before reloading
        current_plan = self.plan_var.get() if hasattr(self, 'plan_var') else None
        print(f"üìå Current plan before reload: {current_plan}")
        
        # Load fresh plans from file
        self.plans = load_all_plans()
        
        if not self.plans:
            print("‚ö† No plans found after reload")
            return
        
        print(f"‚úÖ Loaded plans: {list(self.plans.keys())}")
        
        # Determine which plan to select
        plan_names = list(self.plans.keys())
        
        # RESTORE previous plan if it still exists, otherwise use first plan
        if current_plan and current_plan in plan_names:
            selected_plan = current_plan
            print(f"‚úÖ Restored previous plan: {current_plan}")
        else:
            selected_plan = plan_names[0]
            print(f"‚úÖ Switched to new plan: {selected_plan}")
        
        # Set the selected plan
        self.plan_var.set(selected_plan)
        self.current_plan_name = selected_plan
        self.schedule = self.plans[selected_plan]
        
        # ‚úÖ FIX 1: Update dropdown button text
        if hasattr(self, 'plan_display_btn'):
            self.plan_display_btn.config(
                text=self._format_plan_button_label(selected_plan)
            )
        
        # ‚úÖ FIX 2: Save as last active plan
        save_last_active_plan(selected_plan)
        
        # Register all sessions in the current plan
        self._register_all_plan_sessions()
        
        # ‚úÖ FIX 3: Use setup_plan_tab instead of refresh_plan_tree
        # This properly switches from splash to treeview
        self.setup_plan_tab()

    def save_current_plan(self):
        """Save current schedule to plans.json."""
        self.plans[self.current_plan_name] = self.schedule
        save_all_plans(self.plans)
        print(f"Plan '{self.current_plan_name}' saved!")

    def create_new_plan(self):
        # Create popup
        popup = tk.Toplevel(self)
        popup.title("Create New Plan")
        popup.geometry("420x400")  # Slightly increased height
        popup.resizable(False, False)
        popup.transient(self)
        popup.grab_set()

        # Center on screen
        popup.update_idletasks()
        x = (popup.winfo_screenwidth() // 2) - 210
        y = (popup.winfo_screenheight() // 2) - 200
        popup.geometry(f"420x400+{x}+{y}")

        # Color scheme
        BG_COLOR = "#f8f9fa"
        HEADER_BG = "#2c3e50"
        HEADER_FG = "#ffffff"
        CARD_BG = "#ffffff"
        BORDER_COLOR = "#dce1e7"
        TEXT_DARK = "#2c3e50"
        TEXT_LIGHT = "#7f8c8d"
        SUCCESS_COLOR = "#27ae60"
        AI_COLOR = "#5856d6"
        ACCENT_COLOR = "#3498db"

        popup.configure(bg=BG_COLOR)

        # Main container
        main_frame = tk.Frame(popup, bg=BG_COLOR)
        main_frame.pack(fill="both", expand=True, padx=20, pady=15)

        # Header
        header_frame = tk.Frame(main_frame, bg=HEADER_BG, height=50)
        header_frame.pack(fill="x", pady=(0, 15))
        header_frame.pack_propagate(False)

        header_label = tk.Label(header_frame, 
                                text="üìÖ Create New Study Plan",
                                font=("Segoe UI", 13, "bold"),
                                bg=HEADER_BG, fg=HEADER_FG)
        header_label.pack(expand=True)

        # Info card
        info_card = tk.Frame(main_frame, bg=CARD_BG, relief="flat", bd=1,
                             highlightbackground=BORDER_COLOR, highlightthickness=1)
        info_card.pack(fill="x", pady=(0, 12))

        info_inner = tk.Frame(info_card, bg=CARD_BG)
        info_inner.pack(padx=15, pady=10)

        tk.Label(info_inner, 
                 text="Create a new study plan to organize your sessions separately.",
                 font=("Segoe UI", 9),
                 bg=CARD_BG, fg=TEXT_LIGHT,
                 wraplength=350,
                 justify="left").pack(anchor="w")

        # Input card
        input_card = tk.Frame(main_frame, bg=CARD_BG, relief="flat", bd=1,
                             highlightbackground=BORDER_COLOR, highlightthickness=1)
        input_card.pack(fill="x", pady=(0, 15))

        input_inner = tk.Frame(input_card, bg=CARD_BG)
        input_inner.pack(padx=15, pady=12)

        tk.Label(input_inner, 
                 text="Plan Name",
                 font=("Segoe UI", 10, "bold"),
                 bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w", pady=(0, 6))

        # Entry field
        plan_name_var = tk.StringVar()
        name_entry = tk.Entry(input_inner, 
                             textvariable=plan_name_var,
                             font=("Segoe UI", 11),
                             relief="solid", bd=1,
                             bg="#f7f9fc", fg=TEXT_DARK,
                             width=35)
        name_entry.pack(ipady=5)
        name_entry.focus_set()

        # Validation label
        validation_label = tk.Label(input_inner,
                                   text="",
                                   font=("Segoe UI", 8),
                                   bg=CARD_BG, fg="#e74c3c")
        validation_label.pack(anchor="w", pady=(4, 0))

        # Real-time validation
        def validate_name(*args):
            name = plan_name_var.get().strip()
            if not name:
                validation_label.config(text="")
                return False
            elif name in self.plans:
                validation_label.config(text="‚ö† Plan name already exists")
                return False
            elif len(name) > 50:
                validation_label.config(text="‚ö† Plan name too long (max 50 characters)")
                return False
            else:
                validation_label.config(text="‚úì Valid plan name", fg=SUCCESS_COLOR)
                return True

        plan_name_var.trace('w', validate_name)

        # Button frame
        button_frame = tk.Frame(main_frame, bg=BG_COLOR)
        button_frame.pack(fill="x", pady=(5, 0))

        def on_cancel():
            popup.grab_release()
            popup.destroy()

        def on_create():
            name = plan_name_var.get().strip()
            
            if not name:
                validation_label.config(text="‚ö† Please enter a plan name", fg="#e74c3c")
                name_entry.focus_set()
                return
            
            if name in self.plans:
                validation_label.config(text="‚ö† Plan name already exists", fg="#e74c3c")
                name_entry.focus_set()
                return
            
            if len(name) > 50:
                validation_label.config(text="‚ö† Plan name too long", fg="#e74c3c")
                name_entry.focus_set()
                return
            
            # Create the plan
            self.plans[name] = []
            save_all_plans(self.plans)
            
            self.plan_var.set(name)
            self.current_plan_name = name  # ‚úÖ Set current plan name
            self.schedule = []  # ‚úÖ Empty schedule initially
            
            # ‚úÖ Save as last active plan
            save_last_active_plan(name)
            
            # ‚úÖ Register all sessions (currently none)
            self._register_all_plan_sessions()
            
            self.refresh_plan_tree()  # ‚úÖ Use refresh_plan_tree instead of switch_plan
            
            popup.grab_release()
            popup.destroy()

        # ‚úÖ NEW: Create with AI button
        def on_create_with_ai():
            """Start AI plan creation without requiring a manual name."""

            # Close the popup immediately so AI dialog can take over
            popup.grab_release()
            popup.destroy()

            # Open AI plan creation dialog (AI will create and name plans)
            self.after(100, self._open_ai_plan_creation)

        # Bind Enter key
        name_entry.bind('<Return>', lambda e: on_create())
        popup.bind('<Escape>', lambda e: on_cancel())

        # Cancel button
        cancel_btn = tk.Button(button_frame, 
                              text="Cancel",
                              command=on_cancel,
                              font=("Segoe UI", 10),
                              bg="#ecf0f1", fg=TEXT_DARK,
                              relief="flat", bd=0,
                              padx=20, pady=8,
                              cursor="hand2")
        cancel_btn.pack(side="left", padx=(0, 10))

        # ‚úÖ NEW: Create with AI button (in the middle)
        create_ai_btn = tk.Button(button_frame,
                                  text="ü§ñ Create with AI",
                                  command=on_create_with_ai,
                                  font=("Segoe UI", 10, "bold"),
                                  bg=AI_COLOR, fg="white",
                                  relief="flat", bd=0,
                                  padx=20, pady=8,
                                  cursor="hand2")
        create_ai_btn.pack(side="left", padx=(0, 10))

        # Create button (manual)
        create_btn = tk.Button(button_frame,
                              text="‚úì Create Plan",
                              command=on_create,
                              font=("Segoe UI", 10, "bold"),
                              bg=SUCCESS_COLOR, fg="white",
                              relief="flat", bd=0,
                              padx=25, pady=8,
                              cursor="hand2")
        create_btn.pack(side="right")

        # Hover effects
        def on_enter_create(e):
            create_btn['bg'] = '#229954'

        def on_leave_create(e):
            create_btn['bg'] = SUCCESS_COLOR

        def on_enter_ai(e):
            create_ai_btn['bg'] = '#4845b5'

        def on_leave_ai(e):
            create_ai_btn['bg'] = AI_COLOR

        def on_enter_cancel(e):
            cancel_btn['bg'] = '#d5dbdb'

        def on_leave_cancel(e):
            cancel_btn['bg'] = '#ecf0f1'

        create_btn.bind("<Enter>", on_enter_create)
        create_btn.bind("<Leave>", on_leave_create)
        create_ai_btn.bind("<Enter>", on_enter_ai)
        create_ai_btn.bind("<Leave>", on_leave_ai)
        cancel_btn.bind("<Enter>", on_enter_cancel)
        cancel_btn.bind("<Leave>", on_leave_cancel)


    def auto_save_plan(self):
        """Auto-save whenever schedule changes."""
        self.plans[self.current_plan_name] = self.schedule
        save_all_plans(self.plans)            
        
    def delete_session(self):
        from tkinter import messagebox
        from config_paths import app_paths
        import copy
        
        # Save COMPLETE state before deleting
        state_backup = {
            'schedule': copy.deepcopy(self.schedule),
            'plan_session_names': copy.deepcopy(getattr(self, 'plan_session_names', [])),
            'current_plan_name': getattr(self, 'current_plan_name', 'Default'),
            'plans': copy.deepcopy(getattr(self, 'plans', {}))
        }
        self.undo_stack.append(state_backup)
        self.redo_stack = []
        
        tv = getattr(self, "plan_tree", None)
        if not tv:
            return

        sel = list(tv.selection())
        if not sel:
            messagebox.showinfo("Delete Session", "Please select a session to delete.")
            return

        # Confirm deletion
        if not messagebox.askyesno("Delete Session", "Are you sure you want to delete the selected session(s)?"):
            return

        # Convert selected tree items to schedule indices and delete bottom‚Üíup
        try:
            idxs = []
            for iid in sel:
                try:
                    idxs.append(int(tv.index(iid)))
                except Exception:
                    pass
            idxs = sorted(set(idxs), reverse=True)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to resolve selected rows.\n{e}")
            return

        # Keep names for cleanup
        deleted_names = []
        for idx in idxs:
            try:
                if 0 <= idx < len(self.schedule):
                    deleted_names.append(self.schedule[idx][0])
                    del self.schedule[idx]
                    if hasattr(self, 'plan_session_names') and idx < len(self.plan_session_names):
                        del self.plan_session_names[idx]
            except Exception as e:
                print("[DELETE] delete idx failed:", idx, e)

        # üÜï DELETE STUDY MATERIALS for deleted sessions
        try:
            materials_deleted = []
            deep_dives_deleted = []
            
            # Clean session_materials.json
            materials_file = Path(app_paths.appdata_dir) / "session_materials.json"
            if materials_file.exists():
                materials = json.loads(materials_file.read_text(encoding="utf-8"))
                keys_to_delete = []
                
                for key in materials.keys():
                    # Key format: planname_sessionname_Xdays
                    for deleted_name in deleted_names:
                        if f"{self.current_plan_name}{deleted_name}" in key:
                            keys_to_delete.append(key)
                            materials_deleted.append(deleted_name)
                
                for key in keys_to_delete:
                    del materials[key]
                
                materials_file.write_text(json.dumps(materials, indent=2, ensure_ascii=False), encoding="utf-8")
            
            # Clean deep_dive_content.json
            deep_dive_file = Path(app_paths.appdata_dir) / "deep_dive_content.json"
            if deep_dive_file.exists():
                deep_dives = json.loads(deep_dive_file.read_text(encoding="utf-8"))
                keys_to_delete = []
                
                for key in deep_dives.keys():
                    # Key format: planname_sessionname_topic_dayX
                    for deleted_name in deleted_names:
                        if f"{self.current_plan_name}{deleted_name}" in key:
                            keys_to_delete.append(key)
                            if deleted_name not in deep_dives_deleted:
                                deep_dives_deleted.append(deleted_name)
                
                for key in keys_to_delete:
                    del deep_dives[key]
                
                deep_dive_file.write_text(json.dumps(deep_dives, indent=2, ensure_ascii=False), encoding="utf-8")
            
            # Clean study_progress.json
            progress_file = Path(app_paths.appdata_dir) / "study_progress.json"
            if progress_file.exists():
                progress = json.loads(progress_file.read_text(encoding="utf-8"))
                keys_to_delete = []
                
                for key in progress.keys():
                    # Key format: planname_sessionname
                    for deleted_name in deleted_names:
                        if key == f"{self.current_plan_name}_{deleted_name}":
                            keys_to_delete.append(key)
                
                for key in keys_to_delete:
                    del progress[key]
                
                progress_file.write_text(json.dumps(progress, indent=2, ensure_ascii=False), encoding="utf-8")
            
            # Show cleanup summary
            if materials_deleted or deep_dives_deleted:
                cleanup_msg = "üìö Study Material Cleanup:\n\n"
                if materials_deleted:
                    cleanup_msg += f"‚úÖ Deleted {len(set(materials_deleted))} session material(s)\n"
                if deep_dives_deleted:
                    cleanup_msg += f"‚úÖ Deleted deep dive content for {len(set(deep_dives_deleted))} session(s)\n"
                cleanup_msg += "\nüóë All associated study data has been removed."
                
                messagebox.showinfo("Study Material Deleted", cleanup_msg)
            
        except Exception as e:
            print(f"‚ö† Study material cleanup error: {e}")
            import traceback
            traceback.print_exc()

        # Update plans dictionary with modified schedule
        if hasattr(self, 'plans') and hasattr(self, 'current_plan_name'):
            self.plans[self.current_plan_name] = copy.deepcopy(self.schedule)

        # Normalize + persist
        try:
            if hasattr(self, "clean_schedule"):
                self.clean_schedule()
            
            if "save_schedule" in globals():
                save_schedule(self.schedule)
            
            if hasattr(self, 'auto_save_plan'):
                self.auto_save_plan()
            elif hasattr(self, 'save_current_plan'):
                self.save_current_plan()
            elif 'save_all_plans' in globals():
                save_all_plans(self.plans)
                
        except Exception as e:
            print("[DELETE] save after delete:", e)

        # Refresh plan table
        try:
            self.refresh_plan_tree()
            tv.selection_remove(*sel)
        except Exception as e:
            print("[DELETE] refresh_plan_tree:", e)

        # Recompute labels/markers
        try:
            if hasattr(self, "recompute_required_rates"):
                self.recompute_required_rates()
            if hasattr(self, "refresh_goal_and_markers"):
                self.refresh_goal_and_markers()
        except Exception as e:
            print("[DELETE] recompute/markers:", e)

        # Update timer display
        try:
            self.update_timer()
        except Exception as e:
            print("[DELETE] update_timer:", e)

        # Save history
        try:
            for nm in deleted_names:
                self.save_session_history("Deleted", [nm, "", "", ""])
        except Exception as e:
            print("[DELETE] history save:", e)

        # Clean wastage log
        try:
            import re
            load_wastage_log()
            backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
            global wastage_log
            wastage_log[:] = [e for e in wastage_log if e.get("Session", "") not in set(deleted_names)]
            save_wastage_log()
            if hasattr(self, "update_wastage_day_summary"):
                self.update_wastage_day_summary()
            if hasattr(self, "refresh_wastage"):
                self.refresh_wastage()
            if hasattr(self, "update_wastage_labels"):
                self.update_wastage_labels()
        except Exception as e:
            print("[DELETE] wastage cleanup:", e)

        self.manual_plan_row_selected = False
        # ‚úÖ NEW: Check if plan is now empty and cleanup
        self._cleanup_empty_plan(self.current_plan_name)


    def undo_last_action(self):
        if not self.undo_stack:
            return  # nothing to undo

        import copy
        
        # Save current complete state for redo
        current_state = {
            'schedule': copy.deepcopy(self.schedule),
            'plan_session_names': copy.deepcopy(getattr(self, 'plan_session_names', [])),
            'current_plan_name': getattr(self, 'current_plan_name', 'Default'),
            'plans': copy.deepcopy(getattr(self, 'plans', {}))
        }
        self.redo_stack.append(current_state)
        
        # Restore complete previous state
        previous_state = self.undo_stack.pop()
        
        # Restore all backed up data
        self.schedule = copy.deepcopy(previous_state['schedule'])
        
        if 'plan_session_names' in previous_state:
            self.plan_session_names = copy.deepcopy(previous_state['plan_session_names'])
        else:
            # Regenerate from schedule if not backed up
            self.plan_session_names = [sess[0] for sess in self.schedule] if self.schedule else []
        
        if 'current_plan_name' in previous_state:
            self.current_plan_name = previous_state['current_plan_name']
            
        if 'plans' in previous_state:
            self.plans = copy.deepcopy(previous_state['plans'])
            
        # Update the current plan in plans dict with restored schedule
        if hasattr(self, 'plans') and hasattr(self, 'current_plan_name'):
            self.plans[self.current_plan_name] = copy.deepcopy(self.schedule)

        # Save using existing methods
        try:
            save_schedule(self.schedule)
            
            # Update the plan dropdown if it exists
            if hasattr(self, 'plan_var') and hasattr(self, 'plan_dropdown'):
                self.plan_var.set(self.current_plan_name)
                
            # Use existing save methods
            if hasattr(self, 'auto_save_plan'):
                self.auto_save_plan()
            elif hasattr(self, 'save_current_plan'):
                self.save_current_plan()
            elif 'save_all_plans' in globals():
                save_all_plans(self.plans)
                    
        except Exception as e:
            print(f"[UNDO] Error saving data: {e}")

        # Refresh UI completely
        try:
            self.refresh_plan_tree()
            if hasattr(self, "recompute_required_rates"):
                self.recompute_required_rates()
            if hasattr(self, "refresh_goal_and_markers"):
                self.refresh_goal_and_markers()
            self.update_timer()
            
            # Also refresh wastage data
            if hasattr(self, "refresh_wastage"):
                self.refresh_wastage()
            if hasattr(self, "update_wastage_labels"):
                self.update_wastage_labels()
                
        except Exception as e:
            print(f"[UNDO] Error refreshing UI after undo: {e}")


    def redo_last_action(self):
        if not self.redo_stack:
            return  # nothing to redo

        import copy
        
        # Save current state for potential undo
        current_state = {
            'schedule': copy.deepcopy(self.schedule),
            'plan_session_names': copy.deepcopy(getattr(self, 'plan_session_names', [])),
            'current_plan_name': getattr(self, 'current_plan_name', 'Default'),
            'plans': copy.deepcopy(getattr(self, 'plans', {}))
        }
        self.undo_stack.append(current_state)
        
        # Restore redo state
        redo_state = self.redo_stack.pop()
        
        # Restore all data
        self.schedule = redo_state['schedule']
        
        if 'plan_session_names' in redo_state:
            self.plan_session_names = redo_state['plan_session_names']
        else:
            self.plan_session_names = [sess[0] for sess in self.schedule] if self.schedule else []
        
        if 'current_plan_name' in redo_state:
            self.current_plan_name = redo_state['current_plan_name']
            
        if 'plans' in redo_state:
            self.plans = redo_state['plans']
            self.plans[self.current_plan_name] = copy.deepcopy(self.schedule)

        # Save restored data
        save_schedule(self.schedule)
        if hasattr(self, 'save_plans'):
            self.save_plans()

        # Refresh UI completely
        try:
            self.refresh_plan_tree()
            if hasattr(self, "recompute_required_rates"):
                self.recompute_required_rates()
            if hasattr(self, "refresh_goal_and_markers"):
                self.refresh_goal_and_markers()
            self.update_timer()
            
            # Also refresh wastage data
            if hasattr(self, "refresh_wastage"):
                self.refresh_wastage()
            if hasattr(self, "update_wastage_labels"):
                self.update_wastage_labels()
                
        except Exception as e:
            print(f"[PLAN] Error refreshing UI after redo: {e}")

        print(f"[PLAN] Redo completed - restored {len(self.schedule)} sessions")
    
   
    def _show_custom_dialog(self, title, message, dialog_type='info', show_cancel=False):
        """
        Compact professional dialog
        dialog_type: 'info', 'warning', 'error', 'success'
        """
        import tkinter as tk
        
        dialog = tk.Toplevel(self.master if hasattr(self, 'master') else None)
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.configure(bg='white')
        dialog.overrideredirect(True)
        
        dialog.wm_attributes('-topmost', True)
        
        # Color schemes
        colors = {
            'info': {'accent': '#2196F3', 'icon': '‚óè', 'bg': '#E3F2FD'},
            'success': {'accent': '#4CAF50', 'icon': '‚úì', 'bg': '#E8F5E9'},
            'warning': {'accent': '#FF9800', 'icon': '!', 'bg': '#FFF3E0'},
            'error': {'accent': '#F44336', 'icon': '√ó', 'bg': '#FFEBEE'}
        }
        
        color_scheme = colors.get(dialog_type, colors['info'])
        
        # Main container with border
        main_frame = tk.Frame(dialog, bg=color_scheme['accent'], bd=0)
        main_frame.pack(fill='both', expand=True)
        
        inner_frame = tk.Frame(main_frame, bg='white', bd=0)
        inner_frame.pack(fill='both', expand=True, padx=3, pady=3)
        
        # Compact header with icon
        header_frame = tk.Frame(inner_frame, bg=color_scheme['bg'])
        header_frame.pack(fill='x', pady=(0,0))
        
        # Icon circle
        icon_canvas = tk.Canvas(header_frame, width=32, height=32, 
                               bg=color_scheme['bg'], highlightthickness=0)
        icon_canvas.pack(side='left', padx=15, pady=12)
        icon_canvas.create_oval(2, 2, 30, 30, fill=color_scheme['accent'], outline='')
        icon_canvas.create_text(16, 16, text=color_scheme['icon'], 
                              font=('Arial', 16, 'bold'), fill='white')
        
        # Title
        title_label = tk.Label(header_frame, text=title, 
                              font=('Segoe UI', 11, 'bold'), 
                              bg=color_scheme['bg'], fg='#212121')
        title_label.pack(side='left', pady=12)
        
        # Message area
        message_label = tk.Label(inner_frame, text=message, 
                                font=('Segoe UI', 9), bg='white', fg='#424242',
                                wraplength=350, justify='left')
        message_label.pack(padx=20, pady=20)
        
        # Button area
        button_frame = tk.Frame(inner_frame, bg='white')
        button_frame.pack(fill='x', padx=20, pady=(0, 20))
        
        result = {'value': True}
        
        def on_ok():
            result['value'] = True
            dialog.destroy()
        
        def on_cancel():
            result['value'] = False
            dialog.destroy()
        
        # Compact buttons
        if show_cancel:
            cancel_btn = tk.Button(button_frame, text="Cancel", command=on_cancel,
                                  font=('Segoe UI', 9), bg='#f5f5f5', fg='#616161',
                                  relief='flat', padx=20, pady=8, cursor='hand2',
                                  borderwidth=0, highlightthickness=0)
            cancel_btn.pack(side='right', padx=(10, 0))
            
            def on_cancel_enter(e):
                cancel_btn.config(bg='#e0e0e0')
            def on_cancel_leave(e):
                cancel_btn.config(bg='#f5f5f5')
            cancel_btn.bind('<Enter>', on_cancel_enter)
            cancel_btn.bind('<Leave>', on_cancel_leave)
        
        ok_btn = tk.Button(button_frame, text="OK", command=on_ok,
                          font=('Segoe UI', 9, 'bold'), bg=color_scheme['accent'], 
                          fg='white', relief='flat', padx=30, pady=8, cursor='hand2',
                          borderwidth=0, highlightthickness=0)
        ok_btn.pack(side='right')
        
        def on_ok_enter(e):
            ok_btn.config(bg=self._darken_color(color_scheme['accent'], 0.85))
        def on_ok_leave(e):
            ok_btn.config(bg=color_scheme['accent'])
        ok_btn.bind('<Enter>', on_ok_enter)
        ok_btn.bind('<Leave>', on_ok_leave)
        
        # Update and set proper size AFTER all widgets are packed
        dialog.update_idletasks()
        req_width = 420
        req_height = inner_frame.winfo_reqheight() + 50  # Dynamic height based on content
        dialog.geometry(f"{req_width}x{req_height}")
        
        # Center the dialog AFTER setting size
        x = (dialog.winfo_screenwidth() // 2) - (req_width // 2)
        y = (dialog.winfo_screenheight() // 2) - (req_height // 2)
        dialog.geometry(f'{req_width}x{req_height}+{x}+{y}')
        
        # Make it modal
        dialog.transient(self.master if hasattr(self, 'master') else None)
        dialog.grab_set()
        
        # Allow dragging
        def start_move(event):
            dialog.x = event.x
            dialog.y = event.y
        
        def on_move(event):
            deltax = event.x - dialog.x
            deltay = event.y - dialog.y
            x = dialog.winfo_x() + deltax
            y = dialog.winfo_y() + deltay
            dialog.geometry(f"+{x}+{y}")
        
        header_frame.bind('<Button-1>', start_move)
        header_frame.bind('<B1-Motion>', on_move)
        title_label.bind('<Button-1>', start_move)
        title_label.bind('<B1-Motion>', on_move)
        
        dialog.protocol("WM_DELETE_WINDOW", on_ok)
        dialog.wait_window()
        return result['value']

    def _darken_color(self, hex_color, factor=0.8):
        """Helper to darken a hex color"""
        hex_color = hex_color.lstrip('#')
        r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        r, g, b = int(r * factor), int(g * factor), int(b * factor)
        return f'#{r:02x}{g:02x}{b:02x}'
        
    def _check_license_and_payment(self):
        """Enhanced validation that shows payment popup with correct button state"""
        
        # ‚úÖ Prevent duplicate validation FIRST (before any try blocks)
        if getattr(self, '_validation_in_progress', False):
            print("[VALIDATION] Already in progress - skipping duplicate call")
            return
        
        if getattr(self, '_validation_completed', False):
            print("[VALIDATION] Already completed - skipping")
            return
        
        self._validation_in_progress = True
        
        try:
            print("[VALIDATION] Starting validation...")
            user_profile = _load_profile()
            
            # ‚úÖ STEP 0: Check if already marked as tampered
            if user_profile.get('trial_tampered'):
                print("[VALIDATION] User was previously flagged for tampering")
                
                license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
                
                if not license_valid:
                    print("[VALIDATION] Still tampered and not paid - blocking access")
                    
                    from tkinter import messagebox
                    messagebox.showerror("Access Blocked", 
                        f"Trial tampering was detected: {user_profile.get('tamper_reason', 'Unknown')}\n\n"
                        "You must purchase to continue using this app.")
                    
                    self.hide_title_bar_for_non_premium()
                    self.disable_communication_features_for_non_premium()
                    self.hide_live_tab_elements_for_non_premium()
                    
                    self._show_payment_wizard_no_skip()
                    return
                else:
                    print("[VALIDATION] User paid after tampering - clearing flag")
                    user_profile['trial_tampered'] = False
                    _save_profile(user_profile)
                    self._validation_completed = True
                    self._start_periodic_validation()
                    return
            
            # Check referral prompt
            if not user_profile.get('referral_prompt_shown') and not user_profile.get('referral_code'):
                print("[VALIDATION] Showing referral prompt first...")
                if hasattr(self, 'referral_validator') and self.referral_validator:
                    auto_filled_id = user_profile.get('auto_referral_id')
                    self.referral_validator.show_referral_prompt(auto_filled_id)
                    print("[VALIDATION] Waiting for referral prompt to complete...")
                    return
                else:
                    print("[VALIDATION] No referral manager found, continuing without referral prompt")
                    user_profile['referral_prompt_shown'] = True
                    _save_profile(user_profile)
            
            # Check license
            license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
            
            if license_message == "first_time_user":
                print("[VALIDATION] First-time user - showing trial choice")
                license_valid = False
            
            if license_valid:
                print(f"[VALIDATION] Valid license found: {license_message}")
                if hasattr(self, 'trial_manager') and self.trial_manager:
                    self.trial_manager.cleanup_trial_on_payment(user_profile)
                self._validation_completed = True
                self._start_periodic_validation()
                return
            
            # Check payment
            payment_completed_online = False
            if license_message != "first_time_user" and self.license_manager._check_internet():
                try:
                    online_status = self.license_manager.check_online_status(user_profile)
                    payment_completed_online = online_status.get("payment", False)
                    if payment_completed_online:
                        print("[VALIDATION] Payment found in Google Sheets")
                except Exception as e:
                    print(f"[VALIDATION] Online check error: {e}")
            
            offline_status = self.license_manager.check_offline_status(user_profile)
            payment_completed_locally = offline_status.get("payment", False)
            payment_completed = payment_completed_online or payment_completed_locally
            
            if payment_completed:
                print("[VALIDATION] Payment completed - showing popup with license activation enabled")
                self._show_payment_wizard_with_license_ready()
                return
            
            # Check trial
            if hasattr(self, 'trial_manager') and self.trial_manager:
                trial_status, trial_message, days_remaining = self.trial_manager.validate_trial(user_profile)
                
                if trial_status == 'valid':
                    print(f"[VALIDATION] Trial active: {trial_message}")
                    
                    referral_applied = user_profile.get('referral_code') is not None
                    price_info = "‚Çπ199 (Referral applied!)" if referral_applied else "‚Çπ349"
                    
                    if not getattr(self, '_trial_info_shown', False):
                        from tkinter import messagebox
                        self._show_custom_dialog("Trial Active", 
                            f"Trial Version\n\n{trial_message}\n\nEnjoy all features!", 
                            dialog_type='success')
                        self._trial_info_shown = True
                    self._validation_completed = True
                    self._start_trial_validation()
                    return
                    
                elif trial_status == 'expired':
                    print("[VALIDATION] Trial expired - showing payment popup")
                    self.hide_title_bar_for_non_premium()
                    self.disable_communication_features_for_non_premium() 
                    self.hide_live_tab_elements_for_non_premium()
                    self._show_payment_wizard()
                    return
                    
                elif trial_status == 'tampered':
                    print(f"[VALIDATION] Trial tampering detected: {trial_message}")
                    
                    user_profile['trial_tampered'] = True
                    user_profile['tamper_reason'] = trial_message
                    _save_profile(user_profile)
                    
                    from tkinter import messagebox
                    self._show_custom_dialog("Trial Tampered", 
                        f"Trial tampering detected: {trial_message}\n\nYou must purchase to continue.", 
                        dialog_type='error')
                    
                    self.hide_title_bar_for_non_premium()
                    self.disable_communication_features_for_non_premium()
                    self.hide_live_tab_elements_for_non_premium()
                    
                    self._show_payment_wizard_no_skip()
                    return
                    
                elif trial_status == 'no_trial':
                    is_first_time = license_message == "first_time_user"
                    
                    if not user_profile.get('trial_tampered') or is_first_time:
                        # ‚úÖ SHOW TRIAL CHOICE POPUP
                        import tkinter as tk
                        from tkinter import font
                        
                        popup = tk.Toplevel(self)
                        popup.title("Choose Your Plan")
                        popup.geometry("750x700")
                        popup.resizable(False, False)
                        
                        response_var = tk.BooleanVar(value=False)
                        
                        popup.transient(self)
                        popup.grab_set()
                        
                        popup.update_idletasks()
                        x = (popup.winfo_screenwidth() // 2) - 375
                        y = (popup.winfo_screenheight() // 2) - 350
                        popup.geometry(f"750x700+{x}+{y}")
                        
                        popup.lift()
                        popup.attributes('-topmost', True)
                        popup.after(100, lambda: popup.attributes('-topmost', False))
                        
                        # Styles
                        bg_color = "#f8f9fa"
                        header_color = "#2c3e50"
                        free_color = "#95a5a6"
                        premium_color = "#27ae60"
                        
                        popup.configure(bg=bg_color)
                        
                        # Fonts
                        title_font = font.Font(family="Arial", size=20, weight="bold")
                        subtitle_font = font.Font(family="Arial", size=10)
                        plan_title_font = font.Font(family="Arial", size=14, weight="bold")
                        feature_font = font.Font(family="Arial", size=9)
                        button_font = font.Font(family="Arial", size=11, weight="bold")
                        
                        # Check referral for pricing
                        referral_applied = user_profile.get('referral_code') is not None
                        price_text = "‚Çπ199" if referral_applied else "‚Çπ349"
                        
                        # Header
                        header_frame = tk.Frame(popup, bg=header_color, height=80)
                        header_frame.pack(fill=tk.X)
                        header_frame.pack_propagate(False)
                        
                        tk.Label(header_frame, text="Choose Your Plan", font=title_font, 
                                fg="white", bg=header_color).pack(pady=15)
                        
                        if referral_applied:
                            subtitle_text = f"Start with a 7-day free trial or get Premium for {price_text} (Referral applied!)"
                        else:
                            subtitle_text = f"Start with a 7-day free trial or upgrade to Premium for {price_text}"
                        
                        tk.Label(header_frame, text=subtitle_text, 
                                font=subtitle_font, fg="#ecf0f1", bg=header_color).pack()
                        
                        # Content frame
                        content_frame = tk.Frame(popup, bg=bg_color)
                        content_frame.pack(fill=tk.BOTH, expand=True, padx=30, pady=20)
                        
                        # Two columns
                        left_frame = tk.Frame(content_frame, bg="white", relief=tk.RAISED, borderwidth=2)
                        left_frame.grid(row=0, column=0, sticky="nsew", padx=10)
                        
                        right_frame = tk.Frame(content_frame, bg="white", relief=tk.RAISED, borderwidth=2)
                        right_frame.grid(row=0, column=1, sticky="nsew", padx=10)
                        
                        content_frame.grid_columnconfigure(0, weight=1)
                        content_frame.grid_columnconfigure(1, weight=1)
                        
                        # FREE PLAN
                        free_header = tk.Frame(left_frame, bg=free_color, height=60)
                        free_header.pack(fill=tk.X)
                        free_header.pack_propagate(False)
                        
                        tk.Label(free_header, text="FREE PLAN", font=plan_title_font, 
                                fg="white", bg=free_color).pack(pady=8)
                        tk.Label(free_header, text="Basic Features", font=subtitle_font, 
                                fg="#ecf0f1", bg=free_color).pack()
                        
                        free_features_frame = tk.Frame(left_frame, bg="white")
                        free_features_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
                        
                        all_features = [
                            ("Custom session schedule edit", True),
                            ("Wastage track per day", True),
                            ("Motivational quotes", True),
                            ("Access help and support", True),
                            ("Leaderboard sync", False),
                            ("Daily auto reports", False),
                            ("Analytics charts", False),
                            ("Wastage tracking log by date", False),
                            ("Telegram alerts", False),
                            ("PDF reports", False),
                            ("Goal monitoring", False),
                            ("Multi-platform sync", False),
                            ("Realtime analytics graph", False),
                            ("Referral system access", False),
                            ("Daily Email reports (multi-recipient)", False),
                            ("Regular updates", False)
                        ]
                        
                        for feature, included in all_features:
                            feature_frame = tk.Frame(free_features_frame, bg="white")
                            feature_frame.pack(fill=tk.X, pady=2)
                            
                            symbol = "‚úì" if included else "‚úó"
                            symbol_color = "#27ae60" if included else "#e74c3c"
                            
                            tk.Label(feature_frame, text=symbol, font=("Arial", 10, "bold"),
                                    fg=symbol_color, bg="white", width=3).pack(side=tk.LEFT)
                            tk.Label(feature_frame, text=feature, font=feature_font, 
                                    fg="#2c3e50" if included else "#95a5a6", bg="white", 
                                    anchor="w").pack(side=tk.LEFT, fill=tk.X)
                        
                        # PREMIUM PLAN
                        premium_header = tk.Frame(right_frame, bg=premium_color, height=60)
                        premium_header.pack(fill=tk.X)
                        premium_header.pack_propagate(False)
                        
                        badge_frame = tk.Frame(premium_header, bg="#f39c12", padx=8, pady=1)
                        badge_frame.pack(pady=3)
                        tk.Label(badge_frame, text="RECOMMENDED", font=("Arial", 9, "bold"), 
                                fg="white", bg="#f39c12").pack()
                        
                        tk.Label(premium_header, text="PREMIUM", font=plan_title_font, 
                                fg="white", bg=premium_color).pack()
                        tk.Label(premium_header, text=f"Lifetime Access - {price_text}", font=subtitle_font, 
                                fg="#ecf0f1", bg=premium_color).pack()
                        
                        premium_features_frame = tk.Frame(right_frame, bg="white")
                        premium_features_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
                        
                        for feature, _ in all_features:
                            feature_frame = tk.Frame(premium_features_frame, bg="white")
                            feature_frame.pack(fill=tk.X, pady=2)
                            
                            tk.Label(feature_frame, text="‚úì", font=("Arial", 10, "bold"),
                                    fg="#27ae60", bg="white", width=3).pack(side=tk.LEFT)
                            tk.Label(feature_frame, text=feature, font=feature_font, 
                                    fg="#2c3e50", bg="white", anchor="w").pack(side=tk.LEFT, fill=tk.X)
                        
                        # Buttons
                        button_frame = tk.Frame(popup, bg=bg_color)
                        button_frame.pack(fill=tk.X, padx=30, pady=15)
                        
                        def on_trial_click():
                            response_var.set(True)
                            popup.destroy()
                        
                        def on_premium_click():
                            response_var.set(False)
                            popup.destroy()
                        
                        trial_button = tk.Button(button_frame, 
                                                text="Start 7-Day Free Trial", 
                                                font=button_font,
                                                bg=free_color, 
                                                fg="white",
                                                activebackground="#7f8c8d",
                                                activeforeground="white",
                                                relief=tk.RAISED,
                                                bd=2,
                                                padx=20,
                                                pady=10,
                                                cursor="hand2",
                                                command=on_trial_click)
                        trial_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=10)
                        
                        premium_button = tk.Button(button_frame, 
                                                  text=f"Get Premium ({price_text})", 
                                                  font=button_font,
                                                  bg=premium_color, 
                                                  fg="white",
                                                  activebackground="#229954",
                                                  activeforeground="white",
                                                  relief=tk.RAISED,
                                                  bd=2,
                                                  padx=20,
                                                  pady=10,
                                                  cursor="hand2",
                                                  command=on_premium_click)
                        premium_button.pack(side=tk.RIGHT, expand=True, fill=tk.X, padx=10)
                        
                        # Note
                        if referral_applied:
                            note_text = "Note: Your referral code is applied! You'll save ‚Çπ150 on Premium!"
                        else:
                            note_text = "Note: During the 7-day trial, you'll have access to ALL Premium features!"
                        
                        note_label = tk.Label(popup, 
                                            text=note_text, 
                                            font=("Arial", 9, "italic"),
                                            fg="#7f8c8d",
                                            bg=bg_color)
                        note_label.pack(pady=3)
                        
                        popup.protocol("WM_DELETE_WINDOW", lambda: None)
                        
                        popup.wait_window()
                        
                        response = response_var.get()
                        
                        if response:
                            # User chose trial
                            if not user_profile.get('uid'):
                                user_profile = _create_default_profile()
                            
                            print("[TRIAL] Starting trial - please wait...")
                            success, message = self.trial_manager.start_trial(user_profile)
                            
                            if success:
                                print("[TRIAL] Trial started successfully")
                                import time
                                time.sleep(1)
                                
                                from tkinter import messagebox
                                messagebox.showinfo("Trial Started", message)
                                
                                self._validation_completed = True
                                self._start_trial_validation()
                                return
                            else:
                                # ‚úÖ Trial start failed - check if it was due to tampering
                                from tkinter import messagebox
                                
                                if user_profile.get('trial_tampered'):
                                    # Tampered - show payment without skip
                                    messagebox.showerror("Trial Not Available", message)
                                    
                                    self.hide_title_bar_for_non_premium()
                                    self.disable_communication_features_for_non_premium()
                                    self.hide_live_tab_elements_for_non_premium()
                                    
                                    self._show_payment_wizard_no_skip()
                                else:
                                    # Other error - show payment with skip
                                    messagebox.showerror("Trial Error", message)
                                    self._show_payment_wizard()
                                return
                        else:
                            # User chose premium
                            self._show_payment_wizard()
                            return
            
            # Default: show payment
            print("[VALIDATION] No valid license or trial - showing payment popup")
            self._show_payment_wizard()
            self._validation_completed = True
            
        except Exception as e:
            print(f"[VALIDATION] Critical error: {e}")
            import traceback
            traceback.print_exc()
            from tkinter import messagebox
            messagebox.showerror("Critical Error", f"Validation failed: {e}")
            self._show_payment_wizard()
        
        finally:
            self._validation_in_progress = False
    
    def _show_payment_wizard_with_license_ready(self):
        """Show payment wizard with license activation button already enabled"""
        try:
            wizard = PaymentWizardWithLicenseReady(self, self.license_manager)
            self.wait_window(wizard)
            
            # After wizard closes, check if activation was successful
            user_profile = _load_profile()
            valid, message = self.license_manager.comprehensive_validation(user_profile)
            
            if valid:
                print("[VALIDATION] License activation successful!")
                self._start_periodic_validation()
            else:
                print("[VALIDATION] License activation failed - showing popup again")
                # Don't exit - show the wizard again
                self.after(1000, self._show_payment_wizard_with_license_ready)
                
        except Exception as e:
            print(f"[VALIDATION] Wizard error: {e}")
            # Don't exit - retry showing wizard
            self.after(2000, self._show_payment_wizard_with_license_ready)

    def _start_trial_validation(self):
        """Periodic trial validation during trial"""
        
        def check_trial():
            try:
                user_profile = _load_profile()
                status, message, days = self.trial_manager.validate_trial(user_profile)
                
                if status == 'tampered':
                    messagebox.showerror("Trial Tampered", 
                        f"Tampering detected: {message}\n\nProceeding to payment.")
                    print("[DEBUG] Trial tampered - hiding features")
                    self.hide_title_bar_for_non_premium()
                    self.disable_communication_features_for_non_premium() 
                    self.hide_live_tab_elements_for_non_premium()
                    self._show_payment_wizard()
                    return  # Stop checking
                
                elif status == 'expired':
                    messagebox.showinfo("Trial Expired", 
                        "Your 7-day trial has expired.\n\nPlease purchase a license to continue.")
                    print("[DEBUG] Trial expired - hiding features")
                    self.hide_title_bar_for_non_premium()
                    self.disable_communication_features_for_non_premium() 
                    self.hide_live_tab_elements_for_non_premium()
                    self._show_payment_wizard()
                    return  # Stop checking
                
                elif status == 'valid':
                    print(f"[TRIAL] Trial valid - {days} days remaining")
                    # Continue checking every hour
                    self.after(3600000, check_trial)
                    
            except Exception as e:
                print(f"[TRIAL] Validation error: {e}")
                import traceback
                traceback.print_exc()
                # Continue checking even on error
                self.after(3600000, check_trial)
        
        # ‚úÖ FIX: Run first check immediately, not after 1 hour
        print("[TRIAL] Starting periodic validation (first check in 10 seconds)")
        self.after(10000, check_trial)  # First check in 10 seconds
    
    
    def _show_payment_wizard(self):
        """Show the clean payment wizard"""
        try:
            wizard = PaymentWizard(self, self.license_manager)
            self.wait_window(wizard)
            
            # After wizard closes, check if activation was successful
            user_profile = _load_profile()
            valid, message = self.license_manager.comprehensive_validation(user_profile)
            
            if valid:
                print("[VALIDATION] Activation successful!")
                self._start_periodic_validation()
            else:
                print("[VALIDATION] Activation failed or cancelled")
                
        except Exception as e:
            print(f"[VALIDATION] Wizard error: {e}")
           
    
    def _start_periodic_validation(self):
        """Start periodic validation with recovery (every 30 minutes)"""
        def periodic_check():
            try:
                user_profile = _load_profile()
                
                # First attempt recovery if online
                if self.license_manager._check_internet():
                    online_status = self.license_manager.check_online_status(user_profile)
                    
                    # If online shows active but local files are incomplete, recover
                    if online_status.get("payment") and online_status.get("license"):
                        offline_status = self.license_manager.check_offline_status(user_profile)
                        
                        if offline_status["payment_count"] < len(self.license_manager.storage_locations) or \
                           offline_status["license_count"] < len(self.license_manager.storage_locations):
                            
                            print("[PERIODIC] Recovering missing local files from online status")
                            self.license_manager.recover_offline_files_from_online(user_profile)
                
                # Then perform regular validation
                valid, message = self.license_manager.comprehensive_validation(user_profile)
                
                if not valid:
                    print(f"[PERIODIC] Validation failed: {message}")
                    messagebox.showerror("Validation Failed", 
                        "License validation failed. Application will close.")
                    self._force_exit()
                else:
                    print(f"[PERIODIC] Validation passed: {message}")
                    # Schedule next check
                    self.after(1800000, periodic_check)  # 30 minutes
                    
            except Exception as e:
                print(f"[PERIODIC] Check error: {e}")
                # Retry in 5 minutes on error
                self.after(300000, periodic_check)
        
        # Start first check in 30 minutes
        self.after(1800000, periodic_check)
    
    def _force_exit(self):
        """Clean application exit"""
        try:
            print("[APP] Exiting application...")
            self.destroy()
        except:
            pass
        import sys
        sys.exit(0)
    
    
            
    def update_data_usage(self):
        self.data_usage_label.config(text=f"Data Usage: {NetworkTracker.get_usage()}")
        self.data_usage_label.after(1000, self.update_data_usage)
        
    def save_runrate_graph_snapshot(self, filename=app_paths.get_data_file("last_runrate.png")):
        """Save graph using matplotlib (NOT screenshot)"""
        try:
            if hasattr(self, "runrate_graph") and self.runrate_graph:
                # Use the programmatic matplotlib method instead of screenshot
                success = self.runrate_graph.save_snapshot_programmatic()
                if success:
                    print(f"[RUNRATE] Graph snapshot saved via matplotlib to {filename}")
                else:
                    print(f"[RUNRATE] Failed to save matplotlib snapshot")
            else:
                print("[RUNRATE] No runrate_graph widget available")
        except Exception as e:
            print(f"[RUNRATE] Snapshot save error: {e}")
        
    def generate_runrate_graph_image(self, width=680, height=300):
        """Generate RunRate graph image for PDF (works regardless of active tab)"""
        from PIL import Image, ImageDraw
        
        try:
            # Check for recent snapshot first
            snapshot_path = app_paths.get_data_file("last_runrate.png")
            if os.path.exists(snapshot_path):
                from datetime import datetime, timedelta
                file_time = datetime.fromtimestamp(os.path.getmtime(snapshot_path))
                if datetime.now() - file_time < timedelta(minutes=5):
                    print("[RUNRATE] Using recent snapshot")
                    return Image.open(snapshot_path)

            print("[RUNRATE] Regenerating graph from data")
            
            # Import matplotlib here with error handling
            try:
                import matplotlib
                matplotlib.use('Agg')
                import matplotlib.pyplot as plt
            except ImportError as e:
                print(f"[RUNRATE] Matplotlib import failed: {e}")
                raise
            
            import io
            
            # Get zoom setting safely
            try:
                zoom_setting = self.zoom_var.get()
            except:
                zoom_setting = "overall"
            
            # Filter samples manually
            if not self.samples:
                print("[RUNRATE] No samples available")
                img = Image.new("RGB", (width, height), "white")
                draw = ImageDraw.Draw(img)
                draw.text((width // 2, height // 2),
                          "No data available", fill="gray", anchor="mm")
                return img
                
            if zoom_setting == "1h":
                one_hour_ago = time.time() - (1 * 60 * 60)
                filtered_samples = [(ts, short, long) for ts, short, long in self.samples 
                                   if ts > one_hour_ago]
            else:
                filtered_samples = list(self.samples)
            
            if len(filtered_samples) <= 1:
                print(f"[RUNRATE] Not enough samples: {len(filtered_samples)}")
                img = Image.new("RGB", (width, height), "white")
                draw = ImageDraw.Draw(img)
                draw.text((width // 2, height // 2),
                          "Insufficient data", fill="gray", anchor="mm")
                return img

            print(f"[RUNRATE] Creating graph with {len(filtered_samples)} samples")

            # Extract data
            timestamps = [ts for ts, _, _ in filtered_samples]
            short_vals = [short/60 for _, short, _ in filtered_samples]  # minutes to hours
            long_vals = [long/60 for _, _, long in filtered_samples]
            
            # Create time labels (hours ago from now)
            current_time = time.time()
            time_labels = [(current_time - ts) / 3600 for ts in timestamps]
            
            # Create figure
            fig, ax = plt.subplots(figsize=(width/100, height/100), dpi=100)
            
            # Plot lines
            ax.plot(time_labels, short_vals, color='#e53935', linewidth=2, label='Short-term')
            ax.plot(time_labels, long_vals, color='#1e88e5', linewidth=2, label='Long-term')
            
            # Required rate baseline
            if self.required_min > 0:
                req_hours = self.required_min / 60
                ax.axhline(y=req_hours, color='#888888', linestyle='--', 
                          linewidth=2, label=f'Required: {req_hours:.1f}h')
            
            # Styling
            ax.set_xlabel('Hours Ago', fontsize=10)
            ax.set_ylabel('Hours/Day Required', fontsize=10)
            ax.set_title('Study Run-Rate Analysis', fontsize=12, pad=10)
            ax.legend(loc='best', fontsize=9, frameon=False)
            ax.grid(True, alpha=0.3, linestyle='--')
            ax.invert_xaxis()
            
            plt.tight_layout()
            
            # Save to buffer
            buf = io.BytesIO()
            plt.savefig(buf, format='PNG', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close(fig)
            buf.seek(0)
            
            # Convert to PIL
            img = Image.open(buf)
            
            # Save snapshot
            img.save(snapshot_path)
            print(f"[RUNRATE] Successfully generated graph")
            
            return img

        except Exception as e:
            print(f"[RUNRATE] Graph generation error: {e}")
            import traceback
            traceback.print_exc()
            
            # Return error placeholder
            img = Image.new("RGB", (width, height), "white")
            draw = ImageDraw.Draw(img)
            error_msg = f"Graph Error:\n{str(e)[:50]}"
            draw.text((width // 2, height // 2), error_msg, 
                     fill="red", anchor="mm", align="center")
            return img
        
    def _recompute_tick(self):
        try:
            self.recompute_required_rates()
        finally:
            self.after(30_000, self._recompute_tick)  # every 30 s

    def _start_runrate_scheduler(self):
        if getattr(self, "_runrate_sched_on", False):
            return
        self._runrate_sched_on = True
        self.after(0, self._recompute_tick)
        
    # --- Blink controller for rate labels ---------------------------------
    def _set_blink(self, enabled: bool):
        """Enable/disable blinking on short/long labels when behind schedule."""
        if not hasattr(self, "_blink_enabled"):
            self._blink_enabled = False
        if not hasattr(self, "_blink_state"):
            self._blink_state = False
        if not hasattr(self, "_blink_job"):
            self._blink_job = None

        # nothing changes
        if self._blink_enabled == enabled:
            return

        self._blink_enabled = enabled
        # stop existing job
        if self._blink_job:
            try:
                self.after_cancel(self._blink_job)
            except Exception:
                pass
            self._blink_job = None

        # when disabling, restore steady color
        if not enabled:
            try:
                if hasattr(self, "short_term_label"):
                    self.short_term_label.config(fg="#0a73b8")
                if hasattr(self, "long_term_label"):
                    self.long_term_label.config(fg="#0a73b8")
            except Exception:
                pass
            return

        # start a 500ms toggle
        def _tick():
            if not self._blink_enabled:
                return
            self._blink_state = not self._blink_state
            try:
                col = "red" if self._blink_state else "#0a73b8"
                if hasattr(self, "short_term_label"):
                    self.short_term_label.config(fg=col)
                if hasattr(self, "long_term_label"):
                    self.long_term_label.config(fg=col)
            finally:
                self._blink_job = self.after(500, _tick)

        _tick()
    # ----------------------------------------------------------------------    
        
    # ---------- HH:MM helpers (minutes-based; no rounding drift) ----------

    def _fmt_hhmm(self, minutes: int) -> str:
        """Int minutes -> 'HH:MM'."""
        if minutes < 0:
            minutes = 0
        h = minutes // 60
        m = minutes % 60
        return f"{h:02d}:{m:02d}"

    from datetime import datetime as _dt, timedelta as _td

    def _overlap_minutes(self, a_start, a_end, b_start, b_end) -> int:
        """Return overlapped minutes between [a_start, a_end] and [b_start, b_end]."""
        lo = max(a_start, b_start)
        hi = min(a_end, b_end)
        if hi <= lo:
            return 0
        return int((hi - lo).total_seconds() // 60)

    def _session_minutes_with_break(self, s24: str, e24: str, brk: str) -> int:
        """
        Minutes for one session:
        (end - start) minus overlap with the break window if provided.
        Handles cross-midnight for both session and break.
        """
        # session start/end (24h, e.g. '23:15')
        try:
            st_t = _dt.strptime(s24, "%H:%M").time()
            en_t = _dt.strptime(e24, "%H:%M").time()
        except Exception:
            return 0

        today = _dt.now().date()
        st_dt = _dt.combine(today, st_t)
        en_dt = _dt.combine(today, en_t)
        if en_dt <= st_dt:
            en_dt += _td(days=1)  # cross-midnight session

        total_min = int((en_dt - st_dt).total_seconds() // 60)

        # no break -> done
        if not brk or brk.strip().lower() in ("no break", "none", "-"):
            return max(total_min, 0)

        # parse break like "11:30 PM - 12:15 AM"
        try:
            left, right = [x.strip() for x in brk.split("-", 1)]
            b_st = _dt.strptime(left,  "%I:%M %p").time()
            b_en = _dt.strptime(right, "%I:%M %p").time()
        except Exception:
            return max(total_min, 0)

        # anchor break so it overlaps the session window
        b_st_dt = _dt.combine(st_dt.date(), b_st)
        b_en_dt = _dt.combine(st_dt.date(), b_en)
        if b_en_dt <= b_st_dt:
            b_en_dt += _td(days=1)  # cross-midnight break

        # If still completely before or after, shift by a day to try to overlap
        if b_en_dt <= st_dt:
            b_st_dt += _td(days=1)
            b_en_dt += _td(days=1)
        elif b_st_dt >= en_dt:
            b_st_dt -= _td(days=1)
            b_en_dt -= _td(days=1)

        overlap = self._overlap_minutes(st_dt, en_dt, b_st_dt, b_en_dt)
        return max(total_min - overlap, 0)

    def _daily_planned_minutes(self) -> int:
        from datetime import datetime as _dt, timedelta as _td
        mins = 0
        today = _dt.now().date()
        for (nm, s24, e24, brk) in getattr(self, "schedule", []):
            try:
                st = _dt.strptime(s24, "%H:%M").time()
                en = _dt.strptime(e24, "%H:%M").time()
            except Exception:
                continue
            st_dt = _dt.combine(today, st)
            en_dt = _dt.combine(today, en)
            if en_dt <= st_dt:            # crosses midnight
                en_dt += _td(days=1)
            mins += int((en_dt - st_dt).total_seconds() // 60)
        return mins

    def _today_window_minutes_remaining(self) -> int:
        """How many minutes are left in today's schedule window from 'now'."""
        from datetime import datetime as _dt, timedelta as _td
        now = _dt.now()
        today = now.date()
        rem = 0
        for (nm, s24, e24, brk) in getattr(self, "schedule", []):
            try:
                st = _dt.strptime(s24, "%H:%M").time()
                en = _dt.strptime(e24, "%H:%M").time()
            except Exception:
                continue
            st_dt = _dt.combine(today, st)
            en_dt = _dt.combine(today, en)
            if en_dt <= st_dt:
                en_dt += _td(days=1)
            if en_dt <= now:
                continue
            st_dt = max(st_dt, now)
            rem += int(max(0, (en_dt - st_dt).total_seconds()) // 60)
        return max(rem, 0)

    def _studied_today_minutes(self) -> int:
        """Saved + live seconds today -> minutes (int)."""
        import json, os
        from datetime import datetime as _dt
        now = _dt.now()
        saved = 0
        try:
            if os.path.exists(app_paths.study_today_file):
                with open(app_paths.study_today_file,"r",encoding="utf-8") as f:
                    d = json.load(f) or {}
                saved = int(d.get(now.strftime("%Y-%m-%d"), 0) or 0)  # seconds
        except Exception:
            pass
        live = 0
        if getattr(self, "study_active_from", None) and not getattr(self, "paused", True):
            live += int(max(0, (now - self.study_active_from).total_seconds()))
        if getattr(self, "extra_study_running", False) and getattr(self, "extra_study_started_at", None):
            live += int(max(0, (now - self.extra_study_started_at).total_seconds()))
        return (saved + live) // 60  # minutes

    def _actual_ratio_now(self) -> float:
        """
        Remaining target / remaining window (ratio).
        We still compute as a number, but we will DISPLAY it as HH:MM
        by mapping 'ratio hours per hour' -> HH:MM for the label.
        """
        target_min = self._daily_planned_minutes()
        studied_min = self._studied_today_minutes()
        rem_target = max(0, target_min - studied_min)
        rem_window = max(self._today_window_minutes_remaining(), 1)  # avoid div/0
        return rem_target / rem_window

    def _required_ratio_fixed(self) -> float:
        """
        Baseline ratio to compare for blinking.
        With steady schedule, required ratio is planned/window ‚âà 1.0.
        We use daily planned minutes for both so it is exactly 1.0.
        """
        m = max(self._daily_planned_minutes(), 1)
        return m / m  # 1.0

    

    # Helper near your other helpers
    def _hours_to_hhmm(self, hours: float) -> str:
        mins = int(round(max(0.0, hours) * 60))
        return self._fmt_hhmm(mins)


    def _get_extra_credit_seconds(self) -> int:
        """
        Extra-study credit that cancels wastage:
        - pause credit saved earlier
        - live extra-study stopwatch (if running)
        """
        import time
        from datetime import datetime as _dt
        credit = 0

        # preferred explicit helpers if you have them
        try:
            if hasattr(self, "get_pause_credit_seconds") and callable(self.get_pause_credit_seconds):
                credit += int(self.get_pause_credit_seconds() or 0)
        except Exception:
            pass

        try:
            if hasattr(self, "get_extra_study_credit_seconds") and callable(self.get_extra_study_credit_seconds):
                credit += int(self.get_extra_study_credit_seconds() or 0)
        except Exception:
            pass

        # gentle fallbacks (attributes)
        try:
            credit += int(getattr(self, "pause_credit_seconds", 0) or 0)
        except Exception:
            pass

        # live extra study running now?
        try:
            if getattr(self, "extra_study_running", False) and getattr(self, "extra_study_started_at", None):
                credit += int(max(0, (_dt.now() - self.extra_study_started_at).total_seconds()))
        except Exception:
            pass

        return max(0, int(credit))


    def recompute_required_rates(self):
        """
        Per-day hours needed (HH:MM):
          Short-term: <needed/day to next marker> / <planned/day>
          Long-term : <needed/day to exam>        / <planned/day>

        remaining = goal ‚àí studied + (waste ‚àí extra_credit)   # in 'combined' mode
        """
        try:
            from datetime import date as _date

            # --- fixed daily plan (right side) ---
            # NOTE: uses your _daily_planned_minutes() which does not subtract breaks
            planned_min = int(max(0, self._daily_planned_minutes()))
            planned_hhmm = self._fmt_hhmm(planned_min)

            # --- horizon / days left ---
            today = _date.today()
            exam_day = getattr(self, "progress_exam_date", today)
            days_left = max(1, (exam_day - today).days)  # exclude exam day

            # --- progress (studied so far) ---
            studied_seconds_total = int(max(0, self._live_total_studied()))

            # --- wastage minus extra credit ---
            waste_total = 0
            try:
                if hasattr(self, "get_total_wastage_seconds") and callable(self.get_total_wastage_seconds):
                    waste_total = int(self.get_total_wastage_seconds() or 0)
                elif hasattr(self, "get_total_session_wastage") and callable(self.get_total_session_wastage):
                    # if you prefer session-only wastage
                    waste_total = int(self.get_total_session_wastage() or 0)
            except Exception:
                waste_total = 0

            extra_credit = self._get_extra_credit_seconds()
            effective_waste = max(0, waste_total - extra_credit)

            # --- total goal (across remaining period) ---
            goal_seconds_total = int(planned_min * 60 * days_left)

            # --- choose remaining based on mode ---
            mode = globals().get("RUNRATE_MODE", "combined")
            if mode == "studied":
                remaining_seconds_total = max(0, goal_seconds_total - studied_seconds_total)
            elif mode == "waste":
                remaining_seconds_total = max(0, goal_seconds_total - studied_seconds_total + effective_waste)
            else:  # "combined"
                remaining_seconds_total = max(0, goal_seconds_total - studied_seconds_total + effective_waste)

            # --- LONG-TERM needed/day ---
            long_minutes_per_day = int(round(remaining_seconds_total / 60 / days_left))

            # --- SHORT-TERM needed/day (to next marker) ---
            short_minutes_per_day = long_minutes_per_day
            try:
                if hasattr(self, "_next_marker_after"):
                    nm = self._next_marker_after(today)
                else:
                    nm = None
            except Exception:
                nm = None

            if nm:
                days_to_marker = max(1, (nm - today).days)
                # linear share of goal up to marker
                marker_goal_seconds = int(goal_seconds_total * (days_to_marker / days_left))
                marker_remaining = max(0, marker_goal_seconds - studied_seconds_total + (effective_waste if mode != "studied" else 0))
                short_minutes_per_day = int(round(marker_remaining / 60 / days_to_marker))

            # --- format as HH:MM and show ---
            short_hhmm = self._fmt_hhmm(short_minutes_per_day)
            long_hhmm  = self._fmt_hhmm(long_minutes_per_day)

            if hasattr(self, "short_term_label"):
                self.short_term_label.config(text=f"Short-term: {short_hhmm} / {planned_hhmm}")
            if hasattr(self, "long_term_label"):
                self.long_term_label.config(text=f"Long-term: {long_hhmm} / {planned_hhmm}")
            if hasattr(self, "runrate_graph"):
                self.runrate_graph.update_required(planned_min)
                self.runrate_graph.add_sample(short_minutes_per_day, long_minutes_per_day)

            # --- blinking when behind schedule (either exceeds planned) ---
            need_blink = (short_minutes_per_day > planned_min) or (long_minutes_per_day > planned_min)
            if hasattr(self, "_set_blink"):
                self._set_blink(bool(need_blink))
            elif hasattr(self, "red_light"):
                # older badge API, if you still have it
                try:
                    self.red_light.blink(bool(need_blink))
                except Exception:
                    pass

        except Exception as e:
            print("[RATE] recompute_required_rates:", e)


    def schedule_runrate_updates(self):
        """Call once in _init_: self.after(0, self.schedule_runrate_updates)"""
        try:
            self.recompute_required_rates()
        finally:
            # refresh every 30 seconds (you said 30s is enough)
            try:
                self.after(30000, self.schedule_runrate_updates)
            except Exception:
                pass

    # (Optional) Back-compat if other places still call the old name
    def _actual_rate_now(self):
        return self._actual_ratio_now()
        
    def _actual_rate_now(self):
        # Backward-compat alias for older call sites
        return self._actual_ratio_now()
        
    def _days_until_exam(self):
        try:
            d = _load_exam_date_only()  # you already have this helper
        except Exception:
            d = None
        from datetime import date
        if not d: return 0
        return max((d - date.today()).days, 0)

    def _goal_hours_total(self):
        return round(self._daily_planned_hours() * self._days_until_exam(), 2)

    def refresh_goal_and_markers(self):
        """Update the goal duration label & red markers using the new math."""
        try:
            goal_h = self._goal_hours_total()
            # update whatever StringVar/Label you use for 'Goal duration'
            if hasattr(self, "goal_duration_var"):
                self.goal_duration_var.set(f"{goal_h:.1f} h")
            # recompute required labels too (safe)
            self.recompute_required_rates()
            # (keep your existing red-marker drawing here)
        except Exception as e:
            print("[GOAL] refresh_goal_and_markers:", e)

        
    def _gsync_write_tick(self):
        """
        Periodic sync to both Google Sheets and Firebase.
        Runs every 5 minutes to keep leaderboards updated.
        """
        try:
            print(f"[TRACE-TICK] === SYNC CYCLE START ===")
            
            # Get current stats (with reset detection)
            print(f"[TRACE-TICK] About to call _sheet_get_stats()")
            t, w, online, tgt = self._sheet_get_stats()
            print(f"[TRACE-TICK] _sheet_get_stats() returned: t={t}, w={w}, online={online}, tgt={tgt}")
            
            # Get user name
            name = (self.user_name or _load_profile().get("user_name") or "")
            print(f"[TRACE-TICK] User name: '{name}'")
            
            # ‚úÖ SYNC TO FIREBASE (PRIMARY - leaderboard source of truth)
            if hasattr(self, '_firebase_sync') and self._firebase_sync and self._firebase_sync.enabled:
                try:
                    print(f"[TRACE-TICK] Syncing to Firebase...")
                    self._firebase_sync.update(
                        name=name, 
                        today_hours=t, 
                        week_hours=w, 
                        online=online, 
                        today_target=tgt
                    )
                    print(f"[TRACE-TICK] ‚úÖ Firebase sync complete")
                except Exception as e:
                    print(f"[TRACE-TICK] ‚ùå Firebase sync failed: {e}")
                    import traceback
                    traceback.print_exc()
            else:
                print(f"[TRACE-TICK] ‚ö†Ô∏è Firebase sync not available")
            
            # ‚úÖ SYNC TO GOOGLE SHEETS (SECONDARY - backup/legacy)
            if hasattr(self, '_sheet_sync') and self._sheet_sync and self._sheet_sync.enabled:
                try:
                    print(f"[TRACE-TICK] Syncing to Google Sheets...")
                    self._sheet_sync.update(
                        name=name, 
                        today_hours=t, 
                        week_hours=w, 
                        online=online, 
                        today_target=tgt
                    )
                    print(f"[TRACE-TICK] ‚úÖ Google Sheets sync complete")
                except Exception as e:
                    print(f"[TRACE-TICK] ‚ùå Google Sheets sync failed: {e}")
                    import traceback
                    traceback.print_exc()
            else:
                print(f"[TRACE-TICK] ‚ö†Ô∏è Google Sheets sync not available")
            
            print(f"[TRACE-TICK] === SYNC CYCLE END ===\n")
            
        except Exception as e:
            print(f"[GSYNC] write tick error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # Schedule next sync in 5 minutes (300,000 ms)
            self.after(300_000, self._gsync_write_tick)
        
    def _gsync_read_tick(self):
        try:
            if getattr(self, "_sheet_sync", None):
                if hasattr(self._sheet_sync, "pull"):
                    self._sheet_sync.pull()
                elif hasattr(self._sheet_sync, "refresh"):
                    self._sheet_sync.refresh()
        except Exception as e:
            print("[GSYNC] read tick error:", e)
        self.after(60_000, self._gsync_read_tick)  # ‚úÖ CHANGED: 5 minutes (optional - this is just reading)
    
        
    def _is_online_now(self):
        return bool(
            getattr(self, 'stopwatch_running', False) or
            getattr(self, 'extra_study_running', False) or
            (
                getattr(self, 'registered', False)
                and getattr(self, 'elapsed_timer_enabled', False)
                and not getattr(self, 'paused', True)
                and getattr(self, 'study_active_from', None) is not None
            )
        )

    def push_gsheet_status(self):
        """Push name + online + today/week hours + target to Google Sheet."""
        try:
            ss = getattr(self, "_sheet_sync", None)
            if not ss:
                return

            # name
            try:
                name = (self.user_name or _load_profile().get("user_name") or "")
            except Exception:
                name = (self.user_name or "")

            # get canonical values from _sheet_get_stats()
            try:
                today_h, week_h, online, tgt = self._sheet_get_stats()
            except Exception as e:
                print("[GSYNC] fallback in push_gsheet_status:", e)
                today_h, week_h, online, tgt = 0.0, 0.0, False, None

            # target hours (if available)
            target_h = tgt if tgt is not None else None

            # push
            ss.update(
                name=name,
                today_hours=today_h,
                week_hours=week_h,
                online=online,
                today_target=target_h
            )

            # debug
            print(f"[GSYNC] pushed hours via stats ‚Üí today={today_h}h, week={week_h}h")
        except Exception as e:
            print("[GSYNC] push_gsheet_status failed:", e)

    def _gsync_pulse(self):
        """DISABLED - using _gsync_write_tick instead."""
        pass
        # """Background pulse every 60s to keep sheet live."""
        # try:
        #     self.push_gsheet_status()
        # except Exception:
        #     pass
        # # pulse again in 60s
        # try:
        #     self.after(60_000, self._gsync_pulse)
        # except Exception:
        #     pass
        
    def gsync_push_profile(self):
        """Push current profile (name + online flag) to Google Sheets."""
        try:
            if not getattr(self, "_sheet_sync", None):
                return
            prof = _load_profile()
            name = prof.get("user_name", "")

            online_now = bool(
                getattr(self, 'stopwatch_running', False) or
                getattr(self, 'extra_study_running', False) or
                (getattr(self, 'registered', False)
                 and getattr(self, 'elapsed_timer_enabled', False)
                 and not getattr(self, 'paused', True)
                 and getattr(self, 'study_active_from', None) is not None)
            )
            self._sheet_sync.update(name=name, online=online_now)
        except Exception as e:
            print("[GSYNC] profile push failed:", e)
        
    def refresh_goal_and_markers(self):
        """Recalculate goal hours & markers, then refresh UI + progress denominator."""
        try:
            from datetime import datetime, timedelta, date

            # Prefer a live recomputation so we never get stuck on a stale per-day value
            # saved in goal_config.json. We compute the daily hours from the current
            # schedule, then multiply by the active exam window.
            daily_hours = 0.0
            try:
                total_minutes = 0
                for sess in getattr(self, "schedule", []) or []:
                    if not sess or len(sess) < 3:
                        continue
                    start = parse_time(sess[1])
                    end = parse_time(sess[2])
                    if start and end:
                        st_dt = datetime.combine(date.today(), start)
                        en_dt = datetime.combine(date.today(), end)
                        if en_dt <= st_dt:
                            en_dt += timedelta(days=1)
                        total_minutes += (en_dt - st_dt).total_seconds() / 60
                if total_minutes > 0:
                    daily_hours = total_minutes / 60
            except Exception:
                pass

            # Fallbacks if schedule is empty
            if daily_hours <= 0:
                try:
                    import json, os
                    if os.path.exists(app_paths.goal_config_file):
                        with open(app_paths.goal_config_file, "r") as f:
                            content = f.read().strip()
                            if content:
                                cfg = json.loads(content)
                                daily_hours = float(cfg.get("daily_hours", 0.0) or 0.0)
                except Exception:
                    pass
            if daily_hours <= 0:
                daily_hours = _get_daily_hours_fallback()

            exam_date = getattr(self, "progress_exam_date", None) or _load_exam_date_only()
            if exam_date:
                self.progress_exam_date = exam_date
            days_left = max((exam_date - date.today()).days, 0) if exam_date else 0

            computed_total = round(daily_hours * days_left, 2) if daily_hours > 0 and days_left > 0 else 0.0

            base_hours = float(getattr(self, "progress_goal_hours", 0.0) or 0.0)

            if computed_total > 0:
                hours = computed_total
            elif hasattr(self, "_calculate_goal_from_schedule"):
                hours = float(self._calculate_goal_from_schedule() or 0.0)
            elif base_hours > 0:
                hours = base_hours
            else:
                hours = float(calculate_goal_duration_hours())
        except Exception as e:
            print(f"[GOAL] refresh_goal_and_markers failed: {e}")
            hours = 0.0

        # keep both names in sync (UI uses target_hours_var / progress_goal_hours)
        self.goal_hours = hours
        self.progress_goal_hours = hours
        self.progress_goal_seconds = int(hours * 3600)

        # Update the hidden StringVar that update_progress_bar reads
        if hasattr(self, "target_hours_var"):
            try:
                self.target_hours_var.set(str(round(hours, 2)))
            except Exception:
                pass

        # Update any visible label if present
        if hasattr(self, "goal_label"):
            self.goal_label.config(text=f"{hours:.1f}h")

        # Redraw progress bar
        if hasattr(self, "update_progress_bar"):
            self.update_progress_bar()
        
    def debug_email_connection(self):
        """Debug email connection step by step"""
        print("\n" + "="*50)
        print("üîç EMAIL CONNECTION DEBUG")
        print("="*50)
        
        # Check 1: Configuration
        sender_email = self.config.get("sender_email")
        sender_password = self.config.get("sender_password") 
        recipients = self.config.get("recipient_emails", [])
        enabled = self.config.get("email_enabled", False)
        
        print(f"üìß Sender Email: {sender_email}")
        print(f"üîê Password Length: {len(sender_password) if sender_password else 0} chars")
        print(f"üì¨ Recipients: {recipients}")
        print(f"‚úÖ Enabled: {enabled}")
        print(f"üåê Internet: {self.is_internet_available()}")
        
        # Check 2: Validate credentials format
        if not sender_email or "@gmail.com" not in sender_email:
            print("‚ùå ERROR: Invalid sender email format")
            return False
            
        if not sender_password or len(sender_password.replace(" ", "")) != 16:
            print("‚ùå ERROR: App password should be 16 characters")
            return False
            
        if not recipients:
            print("‚ùå ERROR: No recipient emails configured")
            return False
        
        print("\nüì° Testing SMTP Connection...")
        
        # Check 3: Test basic SMTP connection
        try:
            import smtplib
            
            print("   ‚Üí Connecting to smtp.gmail.com:587...")
            server = smtplib.SMTP('smtp.gmail.com', 587, timeout=60)
            print("   ‚úÖ Connected to Gmail SMTP server")
            
            print("   ‚Üí Starting TLS encryption...")
            server.starttls()
            print("   ‚úÖ TLS encryption enabled")
            
            print("   ‚Üí Logging in with credentials...")
            server.login(sender_email, sender_password)
            print("   ‚úÖ Login successful!")
            
            server.quit()
            print("   ‚úÖ Connection closed properly")
            
            print("\n‚úÖ SMTP CONNECTION TEST PASSED!")
            return True
            
        except smtplib.SMTPAuthenticationError as e:
            print(f"   ‚ùå Authentication failed: {e}")
            print("\nüîß AUTHENTICATION TROUBLESHOOTING:")
            print("   1. Check if email address is exactly correct")
            print("   2. Verify app password is copied correctly")
            print("   3. Ensure 2-Step Verification is ON in Google Account")
            print("   4. Generate a fresh app password")
            return False
            
        except smtplib.SMTPConnectError as e:
            print(f"   ‚ùå Connection failed: {e}")
            print("\nüîß CONNECTION TROUBLESHOOTING:")
            print("   1. Check internet connection")
            print("   2. Check if firewall/antivirus blocks port 587")
            print("   3. Try different network (mobile hotspot)")
            return False
            
        except Exception as e:
            print(f"   ‚ùå Unexpected error: {e}")
            print(f"   üìù Error type: {type(e)._name_}")
            return False

    def send_debug_test_email(self):
        """Send a simple test email with detailed logging"""
        print("\n" + "="*50)
        print("üìß SENDING DEBUG TEST EMAIL")
        print("="*50)
        
        # First check connection
        if not self.debug_email_connection():
            return False
        
        sender_email = self.config.get("sender_email")
        sender_password = self.config.get("sender_password")
        recipients = self.config.get("recipient_emails", [])
        
        try:
            print("\nüìù Creating test email message...")
            
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            import smtplib
            from datetime import datetime
            
            # Create simple test message
            msg = MIMEMultipart()
            msg['From'] = sender_email
            msg['Subject'] = f"üß™ Study Timer Test - {datetime.now().strftime('%H:%M')}"
            
            body = f"""
    üß™ EMAIL TEST SUCCESSFUL!

    This is a test email from Study Timer Pro.

    Test Details:
    ‚Ä¢ Sent from: {sender_email}
    ‚Ä¢ Date/Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    ‚Ä¢ Recipients: {len(recipients)}

    If you received this email, your email configuration is working perfectly!

    ---
    Study Timer Pro - Email System Test
    """
            
            msg.attach(MIMEText(body, 'plain'))
            print("   ‚úÖ Email message created")
            
            # Send to each recipient
            print("\nüì§ Sending emails...")
            server = smtplib.SMTP('smtp.gmail.com', 587, timeout=60)
            server.starttls()
            server.login(sender_email, sender_password)
            
            sent_count = 0
            for recipient in recipients:
                try:
                    msg['To'] = recipient
                    server.sendmail(sender_email, recipient, msg.as_string())
                    msg._delitem_('To')  # Remove for next iteration
                    print(f"   ‚úÖ Sent to: {recipient}")
                    sent_count += 1
                except Exception as e:
                    print(f"   ‚ùå Failed to send to {recipient}: {e}")
            
            server.quit()
            
            if sent_count > 0:
                print(f"\nüéâ SUCCESS! Test emails sent to {sent_count}/{len(recipients)} recipients")
                print("üì¨ Check recipient inboxes (may take 1-2 minutes)")
                return True
            else:
                print("\n‚ùå FAILED to send to any recipients")
                return False
                
        except Exception as e:
            print(f"\n‚ùå EMAIL SENDING ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        
    def setup_simple_email_recipients(self):
        """Compact email setup popup"""
        popup = tk.Toplevel(self)
        popup.title("Email Reports")
        popup.geometry("400x350")
        popup.resizable(False, False)

        # Header
        tk.Label(popup, text="üìß Daily Email Reports", 
                 font=("Arial", 12, "bold")).pack(pady=(10, 5))
        
        tk.Label(popup, text="Auto-sent at 11:59 PM", 
                 font=("Arial", 9), fg="gray").pack()

        # Current recipients
        current_emails = self.config.get("recipient_emails", [])
        if isinstance(current_emails, str):
            current_emails = [current_emails] if current_emails else []

        # Email list with compact layout
        list_frame = tk.Frame(popup)
        list_frame.pack(fill="both", expand=True, padx=15, pady=10)

        tk.Label(list_frame, text="Recipients:", font=("Arial", 10, "bold")).pack(anchor="w")

        # Listbox container
        listbox_container = tk.Frame(list_frame)
        listbox_container.pack(fill="both", expand=True, pady=(5, 0))

        email_listbox = tk.Listbox(listbox_container, height=5, font=("Arial", 9))
        scrollbar = tk.Scrollbar(listbox_container, orient="vertical", command=email_listbox.yview)
        email_listbox.configure(yscrollcommand=scrollbar.set)

        email_listbox.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        def refresh_listbox():
            email_listbox.delete(0, tk.END)
            for email in current_emails:
                email_listbox.insert(tk.END, email)

        refresh_listbox()

        # Add email - inline layout
        add_frame = tk.Frame(list_frame)
        add_frame.pack(fill="x", pady=(10, 5))

        email_entry = tk.Entry(add_frame, font=("Arial", 9))
        email_entry.pack(side="left", fill="x", expand=True)

        def add_email():
            email = email_entry.get().strip()
            
            if not email:
                return
                
            if "@" not in email:
                messagebox.showerror("Invalid", "Invalid email format")
                return
                
            if email in current_emails:
                messagebox.showwarning("Duplicate", "Email already added")
                return

            current_emails.append(email)
            refresh_listbox()
            email_entry.delete(0, tk.END)

        tk.Button(add_frame, text="Add", command=add_email,
                  font=("Arial", 8), bg="#4CAF50", fg="white", width=6).pack(side="right", padx=(5, 0))

        email_entry.bind('<Return>', lambda e: add_email())

        # Remove button - compact
        def remove_selected():
            selection = email_listbox.curselection()
            if not selection:
                messagebox.showinfo("Select", "Select an email to remove")
                return
            
            index = selection[0]
            email = current_emails[index]
            if messagebox.askyesno("Remove", f"Remove {email}?"):
                current_emails.pop(index)
                refresh_listbox()

        tk.Button(list_frame, text="Remove Selected", command=remove_selected,
                  font=("Arial", 8), bg="#f44336", fg="white").pack(pady=(0, 10))

        # Enable checkbox
        email_enabled = tk.BooleanVar(value=self.config.get("email_enabled", False))
        
        tk.Checkbutton(popup, text="Enable daily email reports", 
                       variable=email_enabled, font=("Arial", 10)).pack(pady=5)

        # Action buttons - horizontal
        button_frame = tk.Frame(popup)
        button_frame.pack(pady=15)

        def save_settings():
            if email_enabled.get() and not current_emails:
                messagebox.showwarning("No Recipients", "Add at least one email address")
                return

            self.config["recipient_emails"] = current_emails.copy()
            self.config["email_enabled"] = email_enabled.get()
            save_config(self.config)

            status = "enabled" if email_enabled.get() else "saved (disabled)"
            messagebox.showinfo("Success", f"Settings {status}")
            popup.destroy()

        def test_email():
            if not current_emails:
                messagebox.showwarning("No Recipients", "Add email addresses first")
                return

            try:
                success = self.send_simple_email_report(sent_via="test")
                msg = "Test email sent!" if success else "Test failed - check connection"
                messagebox.showinfo("Test Result", msg)
            except Exception as e:
                messagebox.showerror("Error", f"Test failed: {str(e)}")

        # Buttons
        tk.Button(button_frame, text="Test", command=test_email,
                  font=("Arial", 9), bg="#2196F3", fg="white", width=8).pack(side="left", padx=2)
        
        tk.Button(button_frame, text="Save", command=save_settings,
                  font=("Arial", 9, "bold"), bg="#4CAF50", fg="white", width=8).pack(side="left", padx=2)
        
        tk.Button(button_frame, text="Cancel", command=popup.destroy,
                  font=("Arial", 9), bg="#666", fg="white", width=8).pack(side="left", padx=2)

        # Setup
        email_entry.focus_set()
        popup.transient(self)
        popup.grab_set()

    # STEP 3: Simplified email sending (uses your pre-configured sender)
    def send_simple_email_report(self, report_date=None, sent_via="auto"):
        """Send email using pre-configured sender credentials"""
        
        
        
        if not self.config.get("email_enabled", False):
            return False
        
        recipient_emails = self.config.get("recipient_emails", [])
        if not recipient_emails:
            return False
        
        if report_date is None:
            report_date = date.today()
        
        try:
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            from email.mime.base import MIMEBase
            from email import encoders
            import smtplib
            
            sender_email = self.config.get("sender_email")
            sender_password = self.config.get("sender_password")
            
            if not sender_email or not sender_password:
                print("[EMAIL] Sender not configured")
                return False
            
            # Generate PDF report
            # Save RunRate snapshot before generating PDF
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                self.runrate_graph.save_snapshot_programmatic()  # Changed method name
            pdf_buffer = self.generate_daily_pdf_auto(report_date)
            
            # Send to each recipient separately
            success_count = 0
            for recipient in recipient_emails:
                try:
                    # Create a NEW message for EACH recipient
                    msg = MIMEMultipart()
                    msg['From'] = sender_email
                    msg['To'] = recipient  # Set directly, don't delete later
                    msg['Subject'] = f"Daily Study Report - {report_date}"
                    
                    # Email body
                    body = f"""
    Daily Study Timer Report
    Date: {report_date}

    Please find your detailed study report attached.

    This report includes:
    ‚Ä¢ Today's study time and wastage
    ‚Ä¢ Last 30 days summary  
    ‚Ä¢ Visual charts and progress tracking
    ‚Ä¢ Study session breakdown

    Keep up the great work!

    ---
    Generated automatically by Study Timer Pro
    """
                    
                    msg.attach(MIMEText(body, 'plain'))
                    
                    # Attach PDF
                    pdf_buffer.seek(0)
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(pdf_buffer.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', f'attachment; filename=Study_Report_{report_date}.pdf')
                    msg.attach(part)
                    
                    # Send email
                    server = smtplib.SMTP('smtp.gmail.com', 587, timeout=60)
                    server.starttls()
                    server.login(sender_email, sender_password)
                    server.send_message(msg)  # Use send_message instead of sendmail
                    server.quit()
                    
                    success_count += 1
                    print(f"[EMAIL] Sent to {recipient}")
                    
                except Exception as e:
                    print(f"[EMAIL] Failed to send to {recipient}: {e}")
            
            if success_count > 0:
                print(f"[EMAIL] Successfully sent to {success_count}/{len(recipient_emails)} recipients")
                return True
            else:
                return False
                
        except Exception as e:
            print(f"[EMAIL] Failed to send report: {e}")
            return False
        
    def load_daily_report_status(self):
        """Load daily report status to track what's been sent"""
        try:
            if os.path.exists(DAILY_REPORT_STATUS_FILE):
                with open(DAILY_REPORT_STATUS_FILE, "r") as f:
                    return json.load(f)
        except Exception:
            pass
        return {}

    def save_daily_report_status(self, status_data):
        """Save daily report status"""
        try:
            with open(DAILY_REPORT_STATUS_FILE, "w") as f:
                json.dump(status_data, f, indent=2)
        except Exception as e:
            print(f"Failed to save daily report status: {e}")

    def is_report_sent(self, report_date: date | None = None):
        """Check if a specific day's report has already been sent.

        Defaults to today's date when ``report_date`` is not provided.
        """
        if report_date is None:
            report_date = date.today()

        status = self.load_daily_report_status()
        date_key = report_date.isoformat()
        return status.get(date_key, {}).get("sent", False)

    def is_report_sent_today(self):
        """Compatibility wrapper for existing call sites."""
        return self.is_report_sent(date.today())

    def mark_report_sent(self, report_date: date | None = None, sent_via: str = "auto"):
        """Mark a specific day's report as sent."""
        if report_date is None:
            report_date = date.today()

        status = self.load_daily_report_status()
        date_key = report_date.isoformat()
        status[date_key] = {
            "sent": True,
            "sent_at": datetime.now().isoformat(),
            "sent_via": sent_via  # "auto" | "startup" | "manual"
        }
        self.save_daily_report_status(status)

    def mark_report_sent_today(self):
        """Compatibility wrapper for existing call sites."""
        self.mark_report_sent(date.today())

    def send_daily_report_once(self, snapshot=None, report_date=None, sent_via="auto"):
        """Send daily report only if not already sent today (via backend Telegram + Email)"""
        from api_client import api  # ‚úÖ ensure imported at top of file once
        if report_date is None:
            report_date = date.today()

        # Check if already sent today
        if self.is_report_sent(report_date):
            print(f"[REPORT] Report already sent for {report_date}, skipping")
            return False

        # Check internet
        if not self.is_internet_available():
            print(f"[REPORT] No internet, cannot send report for {report_date}")
            return False

        try:
            # ‚úÖ Generate PDF
            if snapshot:
                if hasattr(self, 'runrate_graph') and self.runrate_graph:
                    self.runrate_graph.save_snapshot_programmatic()
                pdf_buffer = self.generate_daily_pdf_auto(
                    report_date=report_date,
                    data_snapshot=snapshot
                )
            else:
                if hasattr(self, 'runrate_graph') and self.runrate_graph:
                    self.runrate_graph.save_snapshot_programmatic()
                pdf_buffer = self.generate_daily_pdf_auto(report_date)

            # ‚úÖ Send via Telegram using backend API
            prof = _load_profile()
            telegram_chat_id = prof.get("telegram_chat_id")

            if telegram_chat_id:
                try:
                    # Implement this in backend: /send_telegram_file
                    result = api.send_telegram_file(pdf_buffer, telegram_chat_id, f"Study_Report_{report_date}.pdf")
                    if result.get('success'):
                        print("[REPORT] Telegram sent successfully")
                    else:
                        print(f"[REPORT] Telegram failed: {result.get('error')}")
                except Exception as e:
                    print(f"[REPORT] Telegram failed: {e}")

            # ‚úÖ Send via Email - unchanged
            if self.config.get("email_enabled", False):
                if self.is_premium_user():
                    try:
                        self.send_simple_email_report(report_date, sent_via)
                        print("[REPORT] Email sent successfully")
                    except Exception as e:
                        print(f"[REPORT] Email failed: {e}")
                else:
                    print("[REPORT] Email blocked - Premium feature")

            # ‚úÖ Mark as sent
                self.mark_report_sent(report_date, sent_via)
                print(f"[REPORT] Successfully sent daily report for {report_date}")
                return True

        except Exception as e:
            print(f"[REPORT] Failed to send daily report: {e}")
            import traceback
            traceback.print_exc()
            return False

    def upload_daily_report_to_firebase(self, report_date: date | None = None):
        """Generate and upload the latest study report to Firebase for cloud delivery."""

        if report_date is None:
            report_date = date.today()

        firebase_sync = getattr(self, "_firebase_sync", None)
        if not firebase_sync or not getattr(firebase_sync, "enabled", False):
            print("[REPORT-UPLOAD] Firebase sync is disabled; skipping upload")
            return False

        try:
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                self.runrate_graph.save_snapshot_programmatic()

            pdf_buffer = self.generate_daily_pdf_auto(report_date)
            pdf_buffer.seek(0)
            pdf_base64 = base64.b64encode(pdf_buffer.read()).decode("utf-8")

            prof = _load_profile()
            chat_id = prof.get("telegram_chat_id")
            config = getattr(self, "config", {}) or {}

            payload = {
                "reportDate": report_date.isoformat(),
                "createdAt": datetime.utcnow().isoformat() + "Z",
                "telegramChatId": chat_id,
                "pdfBase64": pdf_base64,
                "appVersion": config.get("version", ""),
            }

            ref = firebase_sync.db.reference(
                f"studyReports/{firebase_sync.uid}/{report_date.isoformat()}"
            )
            ref.set(payload)

            print(
                f"[REPORT-UPLOAD] Uploaded report for {report_date} to Firebase (chat configured: {bool(chat_id)})"
            )
            return True
        except Exception as e:
            print(f"[REPORT-UPLOAD] Failed to upload report: {e}")
            return False


    def _remove_legacy_profile_widgets(self):
        """Remove the old header profile widgets so only the new ProfileBadge shows."""
        # kill legacy children
        for attr in ("_profile_avatar", "_profile_name_lbl", "_profile_edit_btn"):
            w = getattr(self, attr, None)
            if w is not None:
                try:
                    w.destroy()
                except Exception:
                    pass
                setattr(self, attr, None)
        # kill the legacy container frame
        frm = getattr(self, "_profile_badge", None)
        if frm is not None:
            try:
                frm.pack_forget()
                frm.destroy()
            except Exception:
                pass
            self._profile_badge = None
        
    def update_profile_badge(self):
        if getattr(self, "profile_badge", None):
            try:
                self.profile_badge.refresh()
            except Exception as e:
                print("[PROFILE] refresh err:", e)
            
# ---- Sheet stats getter (replace with your app's real counters if available) ----
    
   
    def _sheet_get_stats(self):
        """Return (today_hours, week_hours, online, today_target_or_None).
        
        FIXED VERSION: Uses Firebase for all reset data - no local files!
        """
        try:
            import json, os
            from datetime import datetime, timedelta
            
            now = datetime.now()
            today_key = now.strftime("%Y-%m-%d")
            
            # ‚úÖ STEP 1: Initialize week start date from Firebase
            if not hasattr(self, '_week_start_date'):
                self._week_start_date = None
                
                if hasattr(self, '_firebase_sync') and self._firebase_sync.enabled:
                    try:
                        firebase_data = self._firebase_sync.pull()
                        if firebase_data:
                            saved_week_start = firebase_data.get('weekStartDate')
                            if saved_week_start:
                                self._week_start_date = saved_week_start
                                print(f"[WEEK-INIT] Loaded from Firebase: {saved_week_start}")
                    except Exception as e:
                        print(f"[WEEK-INIT] Error loading from Firebase: {e}")
                
                # Fallback: Default to last Monday if no Firebase data
                if not self._week_start_date:
                    days_since_monday = now.weekday()  # 0=Monday, 6=Sunday
                    monday = now - timedelta(days=days_since_monday)
                    self._week_start_date = monday.strftime("%Y-%m-%d")
                    print(f"[WEEK-INIT] No Firebase data, defaulting to last Monday: {self._week_start_date}")
            
            # ‚úÖ STEP 1.5: Load baseline from Firebase (secure, user can't edit!)
            if not hasattr(self, '_new_week_start_seconds'):
                self._new_week_start_seconds = 0  # Default
                
                if hasattr(self, '_firebase_sync') and self._firebase_sync.enabled:
                    try:
                        firebase_data = self._firebase_sync.pull()
                        if firebase_data:
                            saved_baseline = firebase_data.get('weekBaseline', 0)
                            baseline_date = firebase_data.get('weekBaselineDate', '')
                            
                            # Only use if it matches current week
                            if baseline_date == self._week_start_date:
                                self._new_week_start_seconds = saved_baseline
                                print(f"[BASELINE-INIT] ‚úÖ Loaded from Firebase: {saved_baseline}s")
                            else:
                                print(f"[BASELINE-INIT] Week changed, baseline reset to 0")
                    except Exception as e:
                        print(f"[BASELINE-INIT] Error loading from Firebase: {e}")
            
            # ‚úÖ STEP 2: Check Firebase for reset signal
            firebase_was_reset = False
            
            if not hasattr(self, '_last_processed_reset'):
                self._last_processed_reset = None
                
                if hasattr(self, '_firebase_sync') and self._firebase_sync.enabled:
                    try:
                        firebase_data = self._firebase_sync.pull()
                        if firebase_data:
                            self._last_processed_reset = firebase_data.get('lastProcessedReset')
                            if self._last_processed_reset:
                                print(f"[RESET-INIT] Loaded from Firebase: {self._last_processed_reset}")
                    except Exception as e:
                        print(f"[RESET-INIT] Error loading from Firebase: {e}")
            
            if hasattr(self, '_firebase_sync') and self._firebase_sync.enabled:
                try:
                    firebase_data = self._firebase_sync.pull()
                    if firebase_data:
                        weekly_reset_at = firebase_data.get('weeklyResetAt')
                        
                        if weekly_reset_at and self._last_processed_reset != weekly_reset_at:
                            # ‚úÖ NEW RESET DETECTED!
                            print(f"[RESET-DETECTED] ‚úÖ NEW weekly reset: {weekly_reset_at}")
                            firebase_was_reset = True
                            
                            # Remember this reset
                            self._last_processed_reset = weekly_reset_at
                            
                            # ‚úÖ CRITICAL: Mark today as the start of the NEW week
                            self._week_start_date = today_key
                            
                            print(f"[RESET-DETECTED] ‚úÖ New week starts TODAY: {today_key}")
                        else:
                            if weekly_reset_at:
                                print(f"[RESET-SKIP] Already processed reset: {weekly_reset_at}")
                            
                except Exception as e:
                    print(f"[DEBUG-RESET] Could not check Firebase: {e}")
            
            # ‚úÖ STEP 3: Load local data (NEVER clear - it's permanent history)
            data = {}
            if os.path.exists(app_paths.study_today_file):
                with open(app_paths.study_today_file, "r", encoding="utf-8") as f:
                    content = f.read()
                    data = json.loads(content) if content else {}

            print(f"[DEBUG-DATA] Local file has keys: {list(data.keys())}")

            # ‚úÖ STEP 3.5: Handle reset detection (DON'T clear local data!)
            if firebase_was_reset:
                print(f"[RESET-DETECTED] Week reset - local data preserved, leaderboard will show new week only")
                
                # Reset timer start times so they begin fresh
                if hasattr(self, 'study_active_from'):
                    self.study_active_from = now
                    print(f"[RESET-FIX] Reset study timer start time")
                
                if hasattr(self, 'stopwatch_start'):
                    self.stopwatch_start = now
                    print(f"[RESET-FIX] Reset stopwatch start time")
                
                if hasattr(self, 'extra_study_start'):
                    self.extra_study_start = now
                    print(f"[RESET-FIX] Reset extra study start time")
                
                # ‚úÖ IMPORTANT: Mark when new week's accumulation should start
                self._new_week_start_seconds = int(data.get(today_key, 0) or 0)
                print(f"[RESET-FIX] Week baseline: {self._new_week_start_seconds}s (will subtract from future readings)")

                # ‚úÖ SAVE BASELINE TO FIREBASE (secure, user can't edit!)
                if hasattr(self, '_firebase_sync') and self._firebase_sync.enabled:
                    try:
                        ref = self._firebase_sync.db.reference(f'leaderboard/{self._firebase_sync.uid}')
                        ref.update({
                            'weekBaseline': self._new_week_start_seconds,
                            'weekBaselineDate': today_key,
                            'weekStartDate': today_key,
                            'lastProcessedReset': self._last_processed_reset
                        })
                        print(f"[RESET-FIX] ‚úÖ Saved to Firebase: baseline={self._new_week_start_seconds}s, week_start={today_key}")
                    except Exception as e:
                        print(f"[RESET-FIX] ‚ùå Failed to save to Firebase: {e}")

            # ‚úÖ STEP 4: Calculate today_hours (always from local data)
            sec_today = int(data.get(today_key, 0) or 0)
            today_hours = round(sec_today / 3600.0, 2)
            
            # ‚úÖ STEP 5: Calculate week_hours for leaderboard (subtract baseline)
            try:
                week_start_dt = datetime.strptime(self._week_start_date, "%Y-%m-%d")
            except:
                week_start_dt = now
                print(f"[DEBUG-WEEK] ‚ö†Ô∏è Invalid week start date, using today")

            # Calculate number of days from week start to today (inclusive)
            days_since_start = (now.date() - week_start_dt.date()).days

            print(f"[DEBUG-WEEK] Week started: {self._week_start_date}")
            print(f"[DEBUG-WEEK] Days since start: {days_since_start}")
            print(f"[DEBUG-WEEK] Today: {today_key}")

            # ‚úÖ Sum all seconds from week_start to today
            week_secs = 0
            days_counted = []

            for d in range(days_since_start + 1):  # +1 to include today
                date_to_check = week_start_dt + timedelta(days=d)
                key = date_to_check.strftime("%Y-%m-%d")
                day_seconds = int(data.get(key, 0) or 0)
                
                if day_seconds > 0:
                    days_counted.append(f"{key}={day_seconds}s")
                
                week_secs += day_seconds
                print(f"[DEBUG-WEEK] Day {d}: {key} = {day_seconds}s")

            # ‚úÖ CRITICAL: Subtract baseline (seconds before reset) for leaderboard
            baseline = getattr(self, '_new_week_start_seconds', 0)
            week_secs_for_leaderboard = max(0, week_secs - baseline)
            week_hours = round(week_secs_for_leaderboard / 3600.0, 2)

            print(f"[DEBUG-CALC] ‚úÖ Week calculation:")
            print(f"  - Start: {self._week_start_date}")
            print(f"  - End: {today_key}")
            print(f"  - Days with data: {days_counted if days_counted else 'none'}")
            print(f"  - Total seconds: {week_secs}s")
            print(f"  - Baseline (pre-reset): {baseline}s")
            print(f"  - New week seconds: {week_secs_for_leaderboard}s")
            print(f"  - Leaderboard hours: {week_hours}h")
            
            # Online flag
            online = bool(
                getattr(self, "stopwatch_running", False)
                or getattr(self, "extra_study_running", False)
                or (
                    getattr(self, "registered", False)
                    and getattr(self, "elapsed_timer_enabled", False)
                    and not getattr(self, "paused", True)
                    and getattr(self, "study_active_from", None) is not None
                )
            )
            
            # Today target
            tgt = None
            if hasattr(self, "progress_goal_hours"):
                try:
                    tgt = float(self.progress_goal_hours)
                except:
                    tgt = None
            
            status = "RESET" if firebase_was_reset else "normal"
            print(f"[STATS-FINAL] ({status}) today={today_hours}h, week={week_hours}h, online={online}")
            
            return (today_hours, week_hours, online, tgt)
            
        except Exception as e:
            print(f"[STATS-ERROR] {e}")
            import traceback
            traceback.print_exc()
            return (0.0, 0.0, bool(getattr(self, "stopwatch_running", False)), None)
            
    def _calculate_week_hours_for_leaderboard(self, data, today_key, week_start_date):
        """Calculate week hours for leaderboard - only counts NEW week data"""
        try:
            from datetime import datetime, timedelta
            
            week_start_dt = datetime.strptime(week_start_date, "%Y-%m-%d")
            now = datetime.now()
            days_since_start = (now.date() - week_start_dt.date()).days
            
            # Get baseline (seconds accumulated BEFORE reset)
            baseline = getattr(self, '_new_week_start_seconds', 0)
            
            # Calculate total seconds from week start to now
            week_secs = 0
            for d in range(days_since_start + 1):
                date_to_check = week_start_dt + timedelta(days=d)
                key = date_to_check.strftime("%Y-%m-%d")
                day_seconds = int(data.get(key, 0) or 0)
                week_secs += day_seconds
            
            # Subtract baseline to get only NEW week hours
            new_week_secs = max(0, week_secs - baseline)
            
            print(f"[WEEK-CALC] Total: {week_secs}s, Baseline: {baseline}s, New week: {new_week_secs}s")
            
            return round(new_week_secs / 3600.0, 2)
            
        except Exception as e:
            print(f"[WEEK-CALC] Error: {e}")
            return 0.0
        
    def refresh_quote(self):
        try:
            # Get all .txt files from the quotes folder
            quote_files = [f for f in os.listdir(app_paths.quotes_dir) if f.endswith('.txt')]
            
            if not quote_files:
                raise FileNotFoundError("No quote files found")
                
            # Select a random quote file
            selected_file = random.choice(quote_files)
            file_path = os.path.join(app_paths.quotes_dir, selected_file)
            
            # Read the quote from the file
            with open(file_path, 'r', encoding='utf-8') as f:
                quote = f.read().strip()
                
        except Exception as e:
            print(f"Error loading quote: {e}")
            quote = "Keep going, you're doing great!"  # Fallback quote
        
        self.quote_label.config(text=quote)
        self.live_tab.after(3600000, self.refresh_quote)  # Refresh every hour (3600000 ms)

    def generate_daily_pdf_auto(self, report_date=None, data_snapshot=None, snapshot_timestamp=None):
        import os
        import json
        from datetime import datetime, date, timedelta
        import io
        import random
        from PIL import Image
        from reportlab.lib.utils import ImageReader as _ImageReader
        
        """Generate daily PDF, optionally from a snapshot."""
        
        # === LOAD RUNRATE SNAPSHOT ===
        runrate_img_pil = None
        try:
            snapshot_path = app_paths.get_data_file("last_runrate.png")
            
            # FORCE regeneration using matplotlib (never use cached screenshots)
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                print("[PDF] Regenerating RunRate graph via matplotlib...")
                self.runrate_graph.save_snapshot_programmatic()
            
            # Now load the matplotlib-generated image
            if os.path.exists(snapshot_path):
                from PIL import Image
                runrate_img_pil = Image.open(snapshot_path)
                print("[PDF] Loaded matplotlib-generated RunRate graph")
            else:
                print("[PDF] No RunRate snapshot found after generation")
                runrate_img_pil = None
        except Exception as e:
            print(f"[PDF] Error loading RunRate snapshot: {e}")
            runrate_img_pil = None
        
        # If snapshot_timestamp is not provided, fallback to current time
        if snapshot_timestamp is None:
            snapshot_timestamp = datetime.now()
        # If snapshot_timestamp is not provided, fallback to current time
        if snapshot_timestamp is None:
            snapshot_timestamp = datetime.now()

        # If we have a snapshot, use its timestamp
        if data_snapshot and "snapshot_timestamp" in data_snapshot:
            snapshot_timestamp = datetime.fromisoformat(data_snapshot["snapshot_timestamp"])
        if report_date is None:
            report_date = date.today()

        date_str = report_date.strftime("%Y-%m-%d")
        cutoff_date = report_date - timedelta(days=30)
        resolved_plan = _resolve_plan_name(getattr(self, "current_plan_name", None), self)

        # Always load freshest wastage data for the active plan
        try:
            load_wastage_log()
            backfill_gap_days(self.schedule, app=self, plan_name=resolved_plan)
        except Exception as e:
            print(f"[PDF] Unable to refresh wastage log: {e}")
        
        

        # ===== 1) Get Today's Studied Time =====
        today_studied_sec = 0
        try:
            # First try to get from live stopwatch if available
            today_studied_sec = int(getattr(self, "today_study_stopwatch_seconds", 0))

            # If zero, check the studied_today_time.json file scoped to the active plan
            if today_studied_sec == 0:
                data = load_today_studied_data()
                if resolved_plan in data and isinstance(data[resolved_plan], dict):
                    today_studied_sec = int(data[resolved_plan].get(date_str, 0))
                elif date_str in data:
                    # Legacy single-plan format
                    today_studied_sec = int(data.get(date_str, 0))
        except Exception as e:
            print(f"Error getting today's studied time: {e}")
            today_studied_sec = 0
        
        today_studied = hhmmss_from_seconds(today_studied_sec)

        # ===== 2) Get Total Studied (last 30 days) =====
        total_studied_sec = 0
        try:
            plan_data = {}
            raw_data = load_today_studied_data()
            if isinstance(raw_data, dict):
                if resolved_plan in raw_data and isinstance(raw_data[resolved_plan], dict):
                    plan_data = raw_data[resolved_plan]
                elif all(k.startswith("20") for k in raw_data.keys()):
                    # Legacy single-plan structure
                    plan_data = raw_data

            for day_str, sec in plan_data.items():
                try:
                    day = datetime.strptime(day_str, "%Y-%m-%d").date()
                    if day >= cutoff_date:
                        total_studied_sec += int(sec)
                except ValueError:
                    continue

            # Also include today's live seconds if not already saved for this plan
            if date_str not in plan_data:
                total_studied_sec += today_studied_sec
        except Exception as e:
            print(f"Error calculating 30-day studied time: {e}")
            total_studied_sec = 0
        
        total_studied = hhmmss_from_seconds(total_studied_sec)

        # ===== 3) Get Today's Wastage Time =====
        today_wastage_sec = 0
        wastage_summary = {}
        try:
            wastage_summary = load_wastage_day_summary(resolved_plan) or {}
        except Exception as e:
            print(f"[PDF] Unable to load wastage summary: {e}")

        if data_snapshot and "today_rows" in data_snapshot:
            for row in data_snapshot["today_rows"]:
                if len(row) > 3:  # Ensure wastage column exists
                    today_wastage_sec += parse_hhmmss(row[3])
        elif wastage_summary:
            todays_row = wastage_summary.get(date_str, {})
            for key, val in todays_row.items():
                if key == "Missed Sessions":
                    continue
                today_wastage_sec += int(val or 0)
        else:
            for entry in wastage_log:
                if (
                    entry.get("Date") == date_str
                    and entry.get("Plan", "Default") == resolved_plan
                ):
                    today_wastage_sec += parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))

        today_wastage = hhmmss_from_seconds(today_wastage_sec)

        # ===== 4) Get Total Wastage (last 30 days) =====
        total_wastage_sec = 0
        if data_snapshot and "month_rows" in data_snapshot:
            for row in data_snapshot["month_rows"]:
                try:
                    row_date = datetime.strptime(row[0], "%Y-%m-%d").date()
                    if row_date >= cutoff_date and len(row) > 0:  # just check row has at least 1 column
                        total_wastage_sec += parse_hhmmss(row[-1])  # last column is total
                except (ValueError, IndexError):
                    continue
        elif wastage_summary:
            for day_str, totals in wastage_summary.items():
                try:
                    entry_date = datetime.strptime(day_str, "%Y-%m-%d").date()
                except ValueError:
                    continue
                if entry_date < cutoff_date:
                    continue
                for key, val in totals.items():
                    if key == "Missed Sessions":
                        continue
                    total_wastage_sec += int(val or 0)
        else:
            for entry in wastage_log:
                try:
                    entry_date = datetime.strptime(entry["Date"], "%Y-%m-%d").date()
                    if entry.get("Plan", "Default") != resolved_plan:
                        continue
                    if entry_date >= cutoff_date:
                        total_wastage_sec += parse_hhmmss(entry["Wastage (hh:mm:ss)"])
                except (KeyError, ValueError):
                    continue

        total_wastage = hhmmss_from_seconds(total_wastage_sec)

        # Rest of your PDF generation code...
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        width, height = A4
        y = height - 50
        left_margin = 50
           
       
        # === Helper: draw table with wrapping and partial page split ===
        def draw_wrapped_table(table_data, col_widths, y_pos):
            max_width = (width - 2 * left_margin) / len(col_widths)
            wrapped_headers = []

            # Wrap headers if too long
            for h in table_data[0]:
                h_str = str(h)
                font_size = 9
                if c.stringWidth(h_str, "Helvetica-Bold", font_size) > max_width:
                    parts = h_str.split(" ")
                    lines, line = [], ""
                    for word in parts:
                        test_line = (line + " " + word).strip()
                        if c.stringWidth(test_line, "Helvetica-Bold", font_size) > max_width:
                            lines.append(line)
                            line = word
                        else:
                            line = test_line
                    if line:
                        lines.append(line)
                    wrapped_headers.append("\n".join(lines))
                else:
                    wrapped_headers.append(h_str)

            table_data[0] = wrapped_headers

            # Create table
            table = Table(table_data, colWidths=col_widths, repeatRows=1)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
                ('GRID', (0, 0), (-1, -1), 0.25, colors.black),
            ]))

            # Auto font shrink if still too wide
            for col_idx, header in enumerate(wrapped_headers):
                font_size = 9
                while c.stringWidth(header.replace("\n", " "), "Helvetica-Bold", font_size) > max_width and font_size > 6:
                    font_size -= 0.5
                    table.setStyle([('FONTSIZE', (col_idx, 0), (col_idx, 0), font_size)])

            # Draw table in parts if needed
            avail_height = y_pos - 50
            parts = table.split(width - 2 * left_margin, avail_height)
            for idx, part in enumerate(parts):
                part.wrapOn(c, width - 2 * left_margin, height)
                part_height = part._height
                part.drawOn(c, left_margin, y_pos - part_height)
                y_pos -= part_height
                if idx < len(parts) - 1:
                    c.showPage()
                    y_pos = height - 50
            return y_pos

        # ===== 1) Title =====
        c.setFont("Helvetica-Bold", 16)
        c.drawString(left_margin, y, f"Study Timer Report - {date_str}")
        y -= 20
        c.setFont("Helvetica-Bold", 12)
        c.drawString(left_margin, y, f"Plan: {resolved_plan}")

        exam_name = (getattr(self, "current_exam_name", "") or "").strip()
        if not exam_name:
            try:
                prof = _load_profile() or {}
                exam_name = (prof.get("exam_name") or "").strip()
                self.current_exam_name = exam_name
            except Exception as e:
                print(f"[PDF] Unable to resolve exam name: {e}")
                exam_name = ""
        if not exam_name:
            exam_name = "No Exam"

        c.drawCentredString(width / 2, y, f"Exam: {exam_name}")
        y -= 28

        # ===== 2) Generated at + Days left =====
        exam_date = (
            self._get_exam_date_for_current_exam()
            or getattr(self, "progress_exam_date", None)
            or _load_exam_date_only()
        )
        exam_days_left = max((exam_date - report_date).days, 0) if exam_date else 0
        c.setFont("Helvetica", 10)
        c.drawString(left_margin, y, f"Generated at: {snapshot_timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
        c.drawRightString(width - left_margin, y, f"Days left for exam: {exam_days_left}")
        y -= 20

        # ===== 3) Random Quote =====
        try:
            quote_files = [f for f in os.listdir(app_paths.quotes_dir) if f.endswith('.txt')]
            if quote_files:
                selected_file = random.choice(quote_files)
                with open(os.path.join(app_paths.quotes_dir, selected_file), 'r', encoding='utf-8') as f:
                    quote = f.read().strip()
            else:
                quote = "Keep going, you're doing great!"
        except Exception as e:
            print(f"Error loading quote: {e}")
            quote = "Keep going, you're doing great!"
        
        c.setFont("Helvetica-Oblique", 11)
        c.drawCentredString(width / 2, y, quote)
        y -= 30

        # ===== 4) Summary =====
        
        c.setFont("Helvetica", 11)
        c.drawString(left_margin, y, f"Today studied: {today_studied}")
        c.drawRightString(width - left_margin, y, f"Today wastage: {today_wastage}")
        y -= 16
        c.drawString(left_margin, y, f"Total studied (30d): {total_studied}")
        c.drawRightString(width - left_margin, y, f"Total wastage (30d): {total_wastage}")
        y -= 30

        # ===== 5) Today Wastage by Session =====
        c.setFont("Helvetica-Bold", 14)
        c.drawCentredString(width / 2, y, "Today Wastage by Session")
        y -= 20
        today_rows = data_snapshot["today_rows"] if data_snapshot else [
            self.wastage_tree.item(i, "values") for i in self.wastage_tree.get_children()
        ]
        if today_rows:
            headers = [self.wastage_tree.heading(col)["text"] for col in self.wastage_tree["columns"]]
            y = draw_wrapped_table([headers] + today_rows, [(width - 2 * left_margin) / len(headers)] * len(headers), y)
            y -= 40
        else:
            c.setFont("Helvetica", 11)
            c.drawString(left_margin, y, "No wastage data for this date")
            y -= 40

        # ===== 6) Monthly Wastage =====
        c.setFont("Helvetica-Bold", 14)
        c.drawCentredString(width / 2, y, "All-Time Wastage By Date (last 30 days)")
        y -= 20

        month_rows = data_snapshot["month_rows"] if data_snapshot else [
            self.wastage_by_day_tree.item(i, "values") for i in self.wastage_by_day_tree.get_children()
        ]

        cutoff_date = report_date - timedelta(days=30)
        filtered_rows = []
        for row in month_rows:
            try:
                # Ensure the first column looks like a date
                if isinstance(row[0], str) and len(row[0]) >= 10:
                    row_date = datetime.strptime(row[0], "%Y-%m-%d").date()
                    if row_date >= cutoff_date:
                        filtered_rows.append(row)
            except ValueError:
                # Skip rows where first column is not a valid date
                continue

        filtered_rows.sort(key=lambda r: datetime.strptime(r[0], "%Y-%m-%d"), reverse=True)
        filtered_rows = filtered_rows[:30]

        if filtered_rows:
            headers = [self.wastage_by_day_tree.heading(col)["text"] for col in self.wastage_by_day_tree["columns"]]
            if "Missed Sessions" in headers:
                missed_idx = headers.index("Missed Sessions")
                headers.pop(missed_idx)
                filtered_rows = [list(r[:missed_idx]) + list(r[missed_idx+1:]) for r in filtered_rows]
            y = draw_wrapped_table([headers] + filtered_rows, [(width - 2 * left_margin) / len(headers)] * len(headers), y)
            y -= 40
        else:
            c.setFont("Helvetica", 11)
            c.drawString(left_margin, y, "No wastage data in the last 1 month")
            y -= 18       
        
        # === Charts after 'ALL time wastage by Date' table (inline, side-by-side) ===
        try:
            import json, os, io as _io, csv as _csv, re as _re
            from datetime import datetime as _dt, timedelta as _td
            from reportlab.lib.utils import ImageReader as _ImageReader

            # ------------------- Build datasets (STUDIED REPORT) -------------------
            # studied time = scheduled duration ‚àí wastage, aggregated appropriately
            _now = _dt.now()
            _dates7 = [(_now - _td(days=d)).strftime("%Y-%m-%d") for d in range(6,-1,-1)]  # oldest -> newest

            def _label_for(dstr):
                _d = _dt.strptime(dstr, "%Y-%m-%d")
                return _d.strftime("%a\n%d-%m")

            _day_labels = [_label_for(d) for d in _dates7]

            # Normalize session names: e.g., "Tech 1" -> "Tech"
            def _norm(name):
                nm = (name or "").strip()
                nm = _re.sub(r"[_\-]*\d+\s*$", "", nm, flags=_re.IGNORECASE)  # drop trailing numbers
                return nm.strip().title() or "Session"

            # Wastage (seconds) per day ‚Äî scoped to active plan
            _waste_by_date = {d:0 for d in _dates7}
            _waste_by_session_day = {d:{} for d in _dates7}
            _wastage_summary = {}
            try:
                _wastage_summary = load_wastage_day_summary(resolved_plan) or {}
            except Exception:
                _wastage_summary = {}

            def _coerce_sec(val):
                if isinstance(val, (int, float)):
                    return int(val)
                if isinstance(val, str):
                    if ":" in val:
                        try:
                            return int(parse_hhmmss(val))
                        except Exception:
                            return 0
                    try:
                        return int(float(val))
                    except Exception:
                        return 0
                return 0

            if _wastage_summary:
                for d in _dates7:
                    for _sess_name, _sec in (_wastage_summary.get(d, {}) or {}).items():
                        if _sess_name == "Missed Sessions":
                            continue
                        _sec_int = _coerce_sec(_sec)
                        _waste_by_date[d] += _sec_int
                        _norm_name = _norm(_sess_name)
                        _waste_by_session_day[d][_norm_name] = _waste_by_session_day[d].get(_norm_name, 0) + _sec_int
            else:
                try:
                    load_wastage_log()
                except Exception:
                    pass
                for _entry in get_current_plan_wastage_log(resolved_plan):
                    _d = _entry.get("Date", "")
                    if _d in _waste_by_date:
                        _sec = parse_hhmmss(_entry.get("Wastage (hh:mm:ss)", "00:00:00"))
                        _waste_by_date[_d] += _sec
                        _norm_name = _norm(_entry.get("Session", ""))
                        _waste_by_session_day[_d][_norm_name] = _waste_by_session_day[_d].get(_norm_name, 0) + _sec

            # Scheduled seconds per (normalized) session per day
            _sched_by_sess_day = {d:{} for d in _dates7}  # {date:{sess:secs}}
            _sched_total_by_day = {d:0 for d in _dates7}
            try:
                for (_name, _st_str, _en_str, _brk) in self.schedule:
                    _st_base, _en_base = get_session_datetimes(_st_str, _en_str)
                    _dur = max(0, int((_en_base - _st_base).total_seconds()))
                    _base = _norm(_name)
                    for d in _dates7:
                        _sched_by_sess_day[d][_base] = _sched_by_sess_day[d].get(_base, 0) + _dur
                        _sched_total_by_day[d] += _dur
            except Exception:
                pass

            # Actual studied seconds per day (plan scoped) ‚Äî include live seconds for today
            _actual_by_day = {d: 0 for d in _dates7}
            try:
                _studied_data = load_today_studied_data()
                if isinstance(_studied_data, dict):
                    if resolved_plan in _studied_data and isinstance(_studied_data[resolved_plan], dict):
                        for _d, _sec in _studied_data[resolved_plan].items():
                            if _d in _actual_by_day:
                                _actual_by_day[_d] = max(_actual_by_day[_d], int(_sec or 0))
                    else:
                        for _d, _sec in _studied_data.items():
                            if _d in _actual_by_day and isinstance(_sec, (int, float)):
                                _actual_by_day[_d] = max(_actual_by_day[_d], int(_sec))
                _today_str = date.today().strftime("%Y-%m-%d")
                if _today_str in _actual_by_day:
                    _actual_by_day[_today_str] = max(
                        _actual_by_day[_today_str],
                        int(getattr(self, "today_study_stopwatch_seconds", 0)),
                    )
            except Exception:
                pass

            # Per-day studied seconds: prefer actual tracked study time; fallback to scheduled minus wastage
            _studied_by_date_secs = []
            _studied_by_session = {}
            _total_by_session   = {}
            for d in _dates7:
                _day_sched_total = _sched_total_by_day.get(d, 0)
                _day_actual = int(_actual_by_day.get(d, 0))
                _has_actual = _day_actual > 0

                _day_waste = _waste_by_date.get(d, 0)
                _day_waste_by_session = _waste_by_session_day.get(d, {})
                _has_waste = (_day_waste > 0) or bool(_day_waste_by_session)

                if not _has_actual:
                    if _has_waste:
                        _day_actual = max(0, _day_sched_total - _day_waste)
                    else:
                        _day_actual = 0
                if _day_sched_total > 0:
                    _day_actual = min(_day_actual, _day_sched_total)

                _studied_by_date_secs.append(_day_actual)
                for _sess, _sec in _sched_by_sess_day[d].items():
                    _total_by_session[_sess] = _total_by_session.get(_sess, 0) + _sec

                    if _has_actual and _day_sched_total > 0:
                        _share = _sec / _day_sched_total
                        _sess_stud = min(_sec, int(round(_day_actual * _share)))
                    elif _has_waste and _sess in _day_waste_by_session:
                        _sess_stud = max(0, _sec - _day_waste_by_session.get(_sess, 0))
                    elif _has_waste and _day_sched_total > 0:
                        _share = _sec / _day_sched_total
                        _sess_stud = max(0, int(_sec - _share * _day_waste))
                    else:
                        _sess_stud = 0

                    _studied_by_session[_sess] = _studied_by_session.get(_sess, 0) + _sess_stud

            # --- Prepare series ---
            # (A) For BAR (sessions): studied vs not studied stacked
            _sess_names = sorted(_total_by_session.keys())
            _bar_sess_stud = [round(_studied_by_session.get(n,0)/3600.0, 2) for n in _sess_names]
            _bar_sess_not  = [round(max(0, _total_by_session.get(n,0) - _studied_by_session.get(n,0))/3600.0, 2) for n in _sess_names]

            # (B) For DONUT (days): studied hours by day
            _donut_labels = _day_labels
            _donut_vals   = [round(x/3600.0, 2) for x in _studied_by_date_secs]

            # ------------------- Render charts to buffers -------------------
            _bar_buf = None
            _donut_buf = None
            _cmp_buf = None
            try:
                import matplotlib
                matplotlib.use("Agg")
                import matplotlib.pyplot as _plt

                # --- BAR: sessions stacked (studied vs not studied, same hue family) ---
                if _sess_names:
                    _bar_buf = _io.BytesIO()
                    import numpy as _np
                    _x = _np.arange(len(_sess_names))
                    # colors: base & lighter
                    base = _plt.get_cmap('tab20').colors
                    def _lighten(rgb, amt=0.65):
                        r,g,b = rgb[:3]
                        return (1 - (1-r)*amt, 1 - (1-g)*amt, 1 - (1-b)*amt)
                    _dark_cols = [base[i % len(base)] for i in range(len(_sess_names))]
                    _light_cols = [_lighten(c, 0.78) for c in _dark_cols]

                    _fig, _ax = _plt.subplots(figsize=(9.8, 4.2))
                    b1 = _ax.bar(_x, _bar_sess_stud, label="Studied", color=_dark_cols)
                    b2 = _ax.bar(_x, _bar_sess_not, bottom=_bar_sess_stud, label="Not studied", color=_light_cols)

                    _ax.set_title("Session Breakdown ‚Äî Last 7 Days (STUDIED vs NOT STUDIED)", fontsize=18, pad=12)
                    _ax.set_xlabel("Sessions")
                    _ax.set_ylabel("Hours")
                    _ax.set_xticks(_x, [n[:16] for n in _sess_names], rotation=0)
                    _ax.legend(ncols=2, loc="upper center", bbox_to_anchor=(0.5, 1.22), fontsize=9, frameon=False)
                    _fig.tight_layout()
                    _fig.savefig(_bar_buf, format="PNG", dpi=170)
                    _plt.close(_fig)
                    _bar_buf.seek(0)

                
                # --- VERTICAL BAR: days (studied hours per day) ---
                if _donut_vals:
                    _donut_buf = _io.BytesIO()
                    _fig2, _ax2 = _plt.subplots(figsize=(9.8, 4.2))

                    # Create color list for bars
                    _bar_colors = [_plt.get_cmap('tab20').colors[i % 20] for i in range(len(_day_labels))]

                    # Create vertical bars with reduced width
                    _x_pos = range(len(_day_labels))
                    bars = _ax2.bar(_x_pos, _donut_vals, width=0.5, color=_bar_colors,
                                    edgecolor='black', linewidth=0.5)

                    # Add value labels on top of bars (only for non-zero values)
                    for i, (bar, val) in enumerate(zip(bars, _donut_vals)):
                        if val > 0:
                            _ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
                                     f'{val:.1f}h', ha='center', va='bottom', fontsize=9)

                    # Styling
                    _ax2.set_title("Studied Hours per Day ‚Äî Last 7 Days", fontsize=18, pad=12)
                    _ax2.set_xlabel("Days", fontsize=11)
                    _ax2.set_ylabel("Hours", fontsize=11)
                    _ax2.set_xticks(_x_pos)
                    _ax2.set_xticklabels(_day_labels, fontsize=10)
                    _ax2.grid(axis='y', alpha=0.3, linestyle='--')
                    _max_val = max(_donut_vals) if _donut_vals else 0
                    _ax2.set_ylim(0, _max_val * 1.15 if _max_val > 0 else 1)

                    _fig2.tight_layout()
                    _fig2.savefig(_donut_buf, format="PNG", dpi=170)
                    _plt.close(_fig2)
                    _donut_buf.seek(0)

                # --- HORIZONTAL COMPARISON: You vs Your Target (last 7 days planned) ---
                try:
                    _cmp_buf = _io.BytesIO()

                    # Compute 'You' = total studied for active plan; 'Your goal' = remaining target hours
                    try:
                        _you_hours = round(get_total_stopwatch_studied(resolved_plan) / 3600.0, 1)
                    except Exception:
                        _you_hours = 0.0

                    try:
                        _daily_hours = max(self._daily_planned_minutes(), 0) / 60.0
                        _goal_hours = round(float(_daily_hours * exam_days_left), 1)
                    except Exception:
                        _goal_hours = 0.0
                    _vals = [_you_hours, _goal_hours]
                    _labels = ["You", "Your goal"]
                    _fig3, _ax3 = _plt.subplots(figsize=(11.0, 2.7))  # wide
                    _ax3.barh(_labels, _vals)
                    _ax3.set_xlabel("Hours")
                    _ax3.set_title("Current progress vs your goal")
                    for i, v in enumerate(_vals):
                        _ax3.text(v + (max(_vals)*0.01 if max(_vals)>0 else 0.1), i, f"{v:.1f}h", va="center", fontsize=9)
                    _fig3.tight_layout()
                    _fig3.savefig(_cmp_buf, format="PNG", dpi=170)
                    _plt.close(_fig3)
                    _cmp_buf.seek(0)
                except Exception as _e:
                    _cmp_buf = None


            except Exception as _e:
                _bar_buf = None
                _donut_buf = None
                _cmp_buf = None
            # ------------------- Place charts inline -------------------
            # Render charts on their own page (stacked vertically). Keep fonts as-is.
            try:
                if (_bar_buf is not None) or (_donut_buf is not None) or (_cmp_buf is not None):
                    c.showPage()
                    y = height - 50
                    # Section title for the charts page
                    c.setFont("Helvetica-Bold", 14)
                    c.drawCentredString(width/2, y, "studied report for last 7 days")
                    y -= 16
                    _inner_w = width - 2*left_margin
                    _h1, _h2, _h3 = height*0.30, height*0.34, height*0.22

                    # 1) Bar (sessions ‚Äî studied vs not studied)
                    if _bar_buf is not None:
                        _bar_img = _ImageReader(_bar_buf)
                        _iw, _ih = _bar_img.getSize()
                        _scale = min(_inner_w/_iw, _h1/_ih)
                        _dw, _dh = _iw*_scale, _ih*_scale
                        _cx = left_margin + (_inner_w - _dw)/2.0
                        _cy = y - _h1 + (_h1 - _dh)/2.0
                        c.drawImage(_bar_img, _cx, _cy, width=_dw, height=_dh)
                        y = _cy - 12

                    # 2) Donut (studied per day) ‚Äî nudged down to avoid title overlap
                    if _donut_buf is not None:
                        _donut_img = _ImageReader(_donut_buf)
                        _iw2, _ih2 = _donut_img.getSize()
                        _scale2 = min(_inner_w/_iw2, _h2/_ih2)
                        _dw2, _dh2 = _iw2*_scale2, _ih2*_scale2
                        _cx2 = left_margin + (_inner_w - _dw2)/2.0
                        _cy2 = y - _h2 + (_h2 - _dh2)/2.0 - 6
                        c.drawImage(_donut_img, _cx2, _cy2, width=_dw2, height=_dh2)
                        y = _cy2 - 12

                    # 3) Comparison (You vs Goal)
                    if '_cmp_buf' in locals() and _cmp_buf is not None:
                        _cmp_img = _ImageReader(_cmp_buf)
                        _iw3, _ih3 = _cmp_img.getSize()
                        _scale3 = min(_inner_w/_iw3, _h3/_ih3)
                        _dw3, _dh3 = _iw3*_scale3, _ih3*_scale3
                        _cx3 = left_margin + (_inner_w - _dw3)/2.0
                        _cy3 = y - _h3 + (_h3 - _dh3)/2.0
                        c.drawImage(_cmp_img, _cx3, _cy3, width=_dw3, height=_dh3)
                        y = _cy3 - 18
            except Exception as _e:
                pass                
        except Exception as _e:
            pass
        try:
            # Use saved RunRate snapshot instead of generating
            snapshot_path = app_paths.get_data_file("last_runrate.png")
            if os.path.exists(snapshot_path):
                from PIL import Image
                runrate_img_pil = Image.open(snapshot_path)
                print("[PDF] Using RunRate snapshot")
            else:
                print("[PDF] No RunRate snapshot found")
                runrate_img_pil = None
            
            if runrate_img_pil:
                # Convert PIL to ImageReader for ReportLab
                runrate_buffer = io.BytesIO()
                runrate_img_pil.save(runrate_buffer, format='PNG')
                runrate_buffer.seek(0)
                runrate_img = _ImageReader(runrate_buffer)
                
                # Add to PDF - either on existing charts page or new page
                if ('_cmp_buf' in locals() and _cmp_buf is not None) or \
                   (_bar_buf is not None) or (_donut_buf is not None):
                    # Add to existing charts page if there's space
                    try:
                        remaining_height = y - 100  # Check remaining space
                        if remaining_height < 200:  # Not enough space
                            c.showPage()
                            y = height - 50
                            c.setFont("Helvetica-Bold", 14)
                            c.drawCentredString(width/2, y, "Short/Long Term Graph Analysis")
                            y -= 60
                        
                        # Draw Long/Short graph
                        _inner_w = width - 2*left_margin
                        _rr_h = 350  # Increased height for bigger graph

                        _iw_rr, _ih_rr = runrate_img.getSize()
                        _scale_rr = min(_inner_w/_iw_rr, _rr_h/_ih_rr) * 1.2  # scale ~20% larger
                        _dw_rr, _dh_rr = _iw_rr*_scale_rr, _ih_rr*_scale_rr
                        _cx_rr = left_margin + (_inner_w - _dw_rr)/2.0
                        _cy_rr = y - _rr_h + (_rr_h - _dh_rr)/2.0

                        c.drawImage(runrate_img, _cx_rr, _cy_rr, width=_dw_rr, height=_dh_rr)
                        y = _cy_rr - 20
                        
                    except Exception as e:
                        print(f"[PDF] RunRate chart placement error: {e}")
                else:
                    # Create new page for RunRate graph
                    c.showPage()
                    y = height - 50
                    
                    c.setFont("Helvetica-Bold", 16)
                    c.drawCentredString(width/2, y, "Study Run-Rate Analysis")
                    y -= 40
                    
                    # Add explanation text
                    c.setFont("Helvetica", 11)
                    explanation = (
                        "This graph shows your required study rate over time:\n"
                        "‚Ä¢ Short-term (red): Rate needed to reach next milestone\n" 
                        "‚Ä¢ Long-term (blue): Rate needed to reach exam date\n"
                        "‚Ä¢ Gray dashed line: Your original daily target\n"
                        "‚Ä¢ When lines go above the target, you need to catch up!"
                    )
                    
                    lines = explanation.split('\n')
                    for line in lines:
                        c.drawString(left_margin, y, line)
                        y -= 16
                    
                    y -= 20
                    
                    # Draw the graph
                    _inner_w = width - 2*left_margin
                    _rr_h = 250
                    
                    _iw_rr, _ih_rr = runrate_img.getSize()
                    _scale_rr = min(_inner_w/_iw_rr, _rr_h/_ih_rr)
                    _dw_rr, _dh_rr = _iw_rr*_scale_rr, _ih_rr*_scale_rr
                    _cx_rr = left_margin + (_inner_w - _dw_rr)/2.0
                    _cy_rr = y - _rr_h + (_rr_h - _dh_rr)/2.0
                    
                    c.drawImage(runrate_img, _cx_rr, _cy_rr, width=_dw_rr, height=_dh_rr)
                    
        except Exception as e:
            print(f"[PDF] RunRate chart generation error: {e}")
# Save
        c.save()
        buffer.seek(0)
        return buffer

    def send_telegram_file_from_buffer(self, buffer, filename):
        """Send PDF file to Telegram securely via backend API."""

        from api_client import api  # ‚úÖ ensure imported at top of file once

        # Get chat_id from profile.json (where it's actually stored)
        prof = _load_profile()
        chat_id = prof.get("telegram_chat_id")

        if not chat_id:
            print("[TELEGRAM] Missing chat_id in profile.json")
            return False

        try:
            # Reset buffer to beginning before sending
            buffer.seek(0)

            print(f"[TELEGRAM] Sending {filename} to chat_id: {chat_id}")

            # ‚úÖ Backend API handles token and file upload
            result = api.send_telegram_file(buffer, chat_id, filename)

            if result.get('success'):
                print(f"[TELEGRAM] Successfully sent {filename}")
                return True
            else:
                print(f"[TELEGRAM] Failed: {result.get('error')}")
                return False

        except Exception as e:
            print(f"[TELEGRAM] Error sending file: {e}")
            return False


    # ------------------------------
    # Snapshot helpers as class methods
    # ------------------------------
    def save_snapshot_to_file(self, snapshot):
        with open(SNAPSHOT_FILE, "w") as f:
            json.dump(snapshot, f)

    def load_snapshot_from_file(self):
        if os.path.exists(SNAPSHOT_FILE):
            with open(SNAPSHOT_FILE, "r") as f:
                return json.load(f)
        return None

    def clear_snapshot_file(self):
        if os.path.exists(SNAPSHOT_FILE):
            os.remove(SNAPSHOT_FILE)

   
    from datetime import datetime, date, time as dtime, timedelta
    REPORT_TIME = dtime(23, 59)
    def check_and_send_daily_report(self):
        now = datetime.now()
        today = date.today()
        status = getattr(self, "_daily_report_status", {})
        last_sent_str = status.get("last_sent")
        last_sent_date = date.fromisoformat(last_sent_str) if last_sent_str else None

        # Case 1: It's exactly 11:59 PM today ‚Üí send today's report
        if now.time().hour == REPORT_TIME.hour and now.time().minute == REPORT_TIME.minute:
            if last_sent_date != today and self.is_internet_available():
                threading.Thread(
                    target=self._send_daily_report_thread,
                    args=(today,),
                    daemon=True
                ).start()

        # Case 2: Missed yesterday's report ‚Üí send yesterday (only once)
        elif last_sent_date is not None and last_sent_date < today - timedelta(days=0):
            # Only send yesterday, even if multiple days missed
            target_date = today - timedelta(days=1)
            if last_sent_date != target_date and self.is_internet_available():
                threading.Thread(
                    target=self._send_daily_report_thread,
                    args=(target_date,),
                    daemon=True
                ).start()

        self.after(60 * 1000, self.check_and_send_daily_report)  # check every minute

    def _send_daily_report_thread(self, report_date):
        with getattr(self, "_daily_report_lock", threading.Lock()):
            status = getattr(self, "_daily_report_status", {})
            report_date_str = report_date.isoformat()

            if status.get("last_sent") == report_date_str:
                return  # already sent

            sent = False
            while not sent:
                if self.is_internet_available():
                    try:
                        # Save RunRate snapshot before generating PDF
                        if hasattr(self, 'runrate_graph') and self.runrate_graph:
                            self.runrate_graph.save_snapshot_programmatic()  # Changed method name
                        pdf_path = self.generate_daily_pdf_auto(report_date)
                        self.send_telegram_file(pdf_path)

                        # ‚úÖ mark this specific date as sent
                        status["last_sent"] = report_date_str
                        save_daily_report_status(status)
                        self._daily_report_status = status
                        sent = True
                    except Exception as e:
                        print("Daily report send failed:", e)
                        time.sleep(5 * 60)
                else:
                    time.sleep(5 * 60)   

    # ----------------------------
    # 6. Internet check
    # ----------------------------
    def is_internet_available(self):
        import socket
        try:
            # try connecting to a common host (Google DNS)
            socket.create_connection(("8.8.8.8", 53), timeout=5)
            return True
        except OSError:
            return False

    # ----------------------------
    # 7. Manual export (optional)
    # ----------------------------
    def export_wastage_to_pdf(self):
        """Manual PDF export with save-as dialog - saves locally only, no auto-send"""
        try:
            today_date = date.today()
            default_filename = f"Study_Report_{today_date.strftime('%Y-%m-%d')}.pdf"

            file_path = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf")],
                initialfile=default_filename,
                title="Save PDF as"
            )
            if not file_path:
                return

            # Create the PDF
            # Save RunRate snapshot before generating PDF
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                self.runrate_graph.save_snapshot_programmatic()  # Changed method name
            pdf_buffer = self.generate_daily_pdf_auto(today_date)

            # Write to file
            with open(file_path, "wb") as f:
                f.write(pdf_buffer.read())

            # Show success message
            if self.is_report_sent_today():
                messagebox.showinfo("Exported", f"PDF saved to:\n{file_path}\n\n(Today's auto-report already sent)")
            else:
                messagebox.showinfo("Exported", f"PDF saved to:\n{file_path}\n\n(Auto-report will be sent automatically by the server around 11:59 PM IST)")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export PDF:\n{e}")
        
    def rename_session_everywhere(self, old_name: str, new_name: str):
        """
        Renames a session in wastage_log and updates UI.
        """
        try:
            load_wastage_log()
            backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
            changed = 0
            for entry in wastage_log:
                if entry.get("Session") == old_name:
                    entry["Session"] = new_name
                    changed += 1
            if changed:
                save_wastage_log()
                print(f"[Rename] Updated {changed} wastage log entries: '{old_name}' -> '{new_name}'")
                self.update_wastage_day_summary()
                self.refresh_wastage()
        except Exception as e:
            print(f"‚ö† rename_session_everywhere failed: {e}")
        
    def _backfill_wastage_offline(self, max_hours=36):
        """
        Add wastage to wastage_log for the time the app was closed:
        count only minutes that were inside a scheduled session and not on a break.
        """
        try:
            last_seen = self._load_last_seen()
        except Exception:
            last_seen = None

        now = datetime.now()
        if not last_seen:
            # first run: just stamp now and return
            try: 
                self._save_last_seen(now)
            except Exception: 
                pass
            return

        # clamp to avoid huge jumps if system clock changed wildly
        gap_hours = (now - last_seen).total_seconds() / 3600.0
        print(f"[BACKFILL] App was closed for {gap_hours:.2f} hours")
        
        if gap_hours <= 0.016:  # Less than 1 minute, no backfill needed
            try: 
                self._save_last_seen(now)
            except Exception: 
                pass
            return
            
        if gap_hours > max_hours:
            # start from 'max_hours' ago to be safe
            last_seen = now - timedelta(hours=max_hours)
            print(f"[BACKFILL] Clamping to max {max_hours} hours")

        step = timedelta(seconds=60)  # 1-minute increments
        t = last_seen
        total_backfilled = 0

        while t < now:
            # Get active session at time t
            idx, st_dt, en_dt = self.get_active_session_idx_at(t)
            
            if idx is not None and not is_on_break(t, idx, self.schedule):
                session_name = self.schedule[idx][0]
                
                # ‚úÖ CRITICAL FIX: Use the date that t falls on for the scheduled time
                # This handles midnight-spanning sessions correctly
                t_date = t.date()
                scheduled = datetime.combine(t_date, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")
                
                # Add exactly 60 seconds per minute of offline time as wastage
                add_or_update_wastage(session_name, scheduled, "OFFLINE", 60, missed="No", app=self)
                total_backfilled += 60
                
            t += step

        print(f"[BACKFILL] Added {total_backfilled//60} minutes of offline wastage")
        
        # persist stamp and refresh labels once
        try: 
            self._save_last_seen(now)
        except Exception: 
            pass
            
        # Force refresh the wastage display to show updated values
        if hasattr(self, "refresh_wastage"):
            self.refresh_wastage()
        if hasattr(self, "update_wastage_labels"):
            self.update_wastage_labels()


    def get_active_session_idx_at(self, dt):
        """Like get_active_session_idx(), but for an arbitrary datetime."""
        for idx, sess in enumerate(self.schedule):
            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], dt)
            if st_dt <= dt <= en_dt:
                return idx, st_dt, en_dt
        return None, None, None


    def _load_last_seen(self):
        """Load the last seen timestamp and remember the plan it was recorded for."""
        try:
            if os.path.exists(LAST_SEEN_FILE):
                with open(LAST_SEEN_FILE, "r", encoding="utf-8") as f:
                    txt = f.read().strip()
                    # Try new JSON structure first
                    try:
                        data = json.loads(txt)
                        if isinstance(data, dict):
                            self._last_seen_plan = data.get("plan")
                            ts_str = data.get("ts") or data.get("timestamp")
                            if ts_str:
                                return datetime.fromisoformat(ts_str)
                    except Exception:
                        # Fallback to legacy plain ISO string
                        self._last_seen_plan = None
                        return datetime.fromisoformat(txt)
        except Exception:
            pass
        return None


    def _save_last_seen(self, ts=None, plan_name=None):
        """Persist the last seen timestamp along with the active plan."""
        try:
            if ts is None:
                ts = datetime.now()
            if plan_name is None:
                plan_name = getattr(self, "current_plan_name", None) or load_last_active_plan() or "Default"

            payload = {"ts": ts.isoformat(), "plan": plan_name}
            with open(LAST_SEEN_FILE, "w", encoding="utf-8") as f:
                json.dump(payload, f)
            self._last_seen_plan = plan_name
        except Exception:
            pass
        
    def edit_telegram_details(self):
        """Edit stored Telegram chat ID (bot token no longer needed)."""
        popup = tk.Toplevel(self)
        popup.geometry("420x180")
        popup.resizable(False, False)

        # ‚úÖ Only show Chat ID field now
        tk.Label(popup, text="Chat ID:", font=("Arial", 11)).pack(pady=(20, 4))
        chat_entry = tk.Entry(popup, font=("Arial", 12), width=46)
        chat_entry.insert(0, getattr(self, "telegram_chat_id", ""))
        chat_entry.pack()

        def save_and_close():
            """Save Telegram chat ID only ‚Äî bot token removed (handled by backend)."""
            self.telegram_chat_id = chat_entry.get().strip()
            self.config["telegram_chat_id"] = self.telegram_chat_id
            save_config(self.config)
            popup.destroy()
            messagebox.showinfo("Saved", "Telegram chat ID saved successfully.")


        tk.Button(
            popup,
            text="Save",
            command=save_and_close,
            font=("Arial", 12),
            width=12
        ).pack(pady=20)

    
    def send_telegram(self, msg, retries=1):
        """Send Telegram message securely via backend API using saved chat_id."""
        from api_client import api  # ‚úÖ ensure imported once at top of file
        print("[DEBUG] ID Token exists:", bool(api.id_token))

        prof = _load_profile()
        chat_id = prof.get("telegram_chat_id")

        if not chat_id:
            print("[Telegram] Not connected yet. Click 'Connect Telegram' first")
            return False

        for attempt in range(retries):
            try:
                result = api.send_telegram(msg, chat_id=chat_id)

                if result.get('success'):
                    print(f"[Telegram] Message sent: {msg[:50]}...")
                    return True
                else:
                    error_msg = result.get('error', 'Unknown error')
                    print(f"[Telegram] Send failed: {error_msg}")

                    # If chat not found, clear the saved chat_id
                    if "chat not found" in error_msg.lower():
                        prof["telegram_chat_id"] = ""
                        _save_profile(prof)
                        print("[Telegram] Chat ID cleared - user needs to reconnect")

            except Exception as e:
                print(f"[Telegram] Attempt {attempt + 1} failed: {e}")
                if attempt < retries - 1:
                    time.sleep(2)

        return False

        
    # >>> PATCH: add inside class SudyTimerApp
    def _restore_offline_drift_dual(self):
        """
        Restore per-day drift ONLY for time since today's midnight, counting
        minutes that were inside a scheduled session and not on a break.
        Prevents huge spikes if system date/time changed or app was closed.
        """
        try:
            last_seen = self._load_last_seen() if hasattr(self, "_load_last_seen") else None
        except Exception:
            last_seen = None

        now = datetime.now()
        today = date.today()

        # start from today's midnight, or last_seen if later (we don't backfill previous days here)
        midnight = datetime.combine(today, datetime.min.time())
        start = max(last_seen or midnight, midnight)

        if start >= now:
            if hasattr(self, "_save_last_seen"): self._save_last_seen(now)
            return

        step = timedelta(seconds=60)  # 1-min steps = light + accurate enough
        t = start
        add_short = 0.0
        add_long  = 0.0

        while t < now:
            if t.date() == today:
                idx, _, _ = self.get_active_session_idx_at(t)
                if idx is not None and not is_on_break(t, idx, self.schedule):
                    # remaining days (exam day excluded)
                    remaining_days_long = max(1, (self.progress_exam_date - today).days)

                    # short-term remaining days to next red mark (marker day excluded)
                    next_marker = self._next_marker_after(today) if hasattr(self, "_next_marker_after") else None
                    if next_marker:
                        remaining_days_short = max(1, (next_marker - today).days)
                    else:
                        remaining_days_short = remaining_days_long

                    # one minute of 'waste' gets distributed over remaining days
                    add_short += 60.0 / float(remaining_days_short)
                    add_long  += 60.0 / float(remaining_days_long)

            t += step

        # apply to today's drift only
        self.per_day_drift_short = float(getattr(self, "per_day_drift_short", 0.0)) + add_short
        self.per_day_drift_long  = float(getattr(self, "per_day_drift_long",  0.0)) + add_long

        if hasattr(self, "_save_target_drift_today"): self._save_target_drift_today()
        if hasattr(self, "_save_last_seen"): self._save_last_seen(now)
    # <<< PATCH
        
    # ---------- FROZEN DAILY TARGETS (persist across restarts) ----------

    def _today_key(self, d=None):
        from datetime import date as _date
        if d is None: d = _date.today()
        return d.strftime("%Y-%m-%d")

    def _load_frozen_thresholds_for_day(self, d=None):
        store = _load_json_safe(TARGET_THRESH_FILE, {})
        return store.get(self._today_key(d))

    def _save_frozen_thresholds_for_day(self, short_secs, long_secs, d=None):
        store = _load_json_safe(TARGET_THRESH_FILE, {})
        store[self._today_key(d)] = {"short": float(short_secs), "long": float(long_secs)}
        _save_json_safe(TARGET_THRESH_FILE, store)

    def _clear_frozen_thresholds_for_day(self, d=None):
        store = _load_json_safe(TARGET_THRESH_FILE, {})
        k = self._today_key(d)
        if k in store:
            del store[k]
            _save_json_safe(TARGET_THRESH_FILE, store)

    def _compute_base_targets_for_day(self, day):
        # Guard: if key fields aren‚Äôt ready, return zeros; it will be recomputed next tick.
        goal_secs = int(getattr(self, "progress_goal_seconds", 0))
        start_date = getattr(self, "progress_start_date", date.today())
        exam_date  = getattr(self, "progress_exam_date", date.today())

        if goal_secs <= 0 or exam_date <= day:
            return 0.0, 0.0

        total_studied_seconds = self._live_total_studied()
        remaining_total = max(0, goal_secs - total_studied_seconds)

        remaining_days_long = max(1, (exam_date - day).days)  # exam day excluded
        base_long = remaining_total / remaining_days_long

        nm = self._next_marker_after(day)
        if nm:
            remaining_days_short = max(1, (nm - day).days)
            total_days_span = max(1, (exam_date - start_date).days)
            days_until_marker_from_start = max(0, (nm - start_date).days)
            target_cum_by_marker = goal_secs * (days_until_marker_from_start / total_days_span)
            remaining_to_marker = max(0, target_cum_by_marker - total_studied_seconds)
            base_short = remaining_to_marker / remaining_days_short
        else:
            base_short = base_long

        return base_short, base_long

    def _ensure_frozen_daily_targets(self, today):
        """Freeze initial per‚Äëday targets ONCE per day; load from disk if already frozen."""
        if not hasattr(self, "short_threshold_seconds"): self.short_threshold_seconds = None
        if not hasattr(self, "long_threshold_seconds"):  self.long_threshold_seconds  = None
        if not hasattr(self, "threshold_day_key"):       self.threshold_day_key       = None
        if not hasattr(self, "_reset_thresholds_flag"):  self._reset_thresholds_flag  = False

        today_key = self._today_key(today)

        # Already set for today and no reset requested ‚Üí keep.
        if (self.threshold_day_key == today_key and
            not self._reset_thresholds_flag and
            self.short_threshold_seconds is not None and
            self.long_threshold_seconds is not None):
            return

        # Try to load today‚Äôs frozen thresholds from disk first.
        persisted = self._load_frozen_thresholds_for_day(today)
        if persisted and not self._reset_thresholds_flag:
            self.short_threshold_seconds = float(persisted.get("short", 0.0))
            self.long_threshold_seconds  = float(persisted.get("long",  0.0))
        else:
            # Compute once (zero drift) and persist for today.
            bs, bl = self._compute_base_targets_for_day(today)
            self.short_threshold_seconds = float(bs)
            self.long_threshold_seconds  = float(bl)
            self._save_frozen_thresholds_for_day(self.short_threshold_seconds, self.long_threshold_seconds, today)

        self.threshold_day_key = today_key
        self._reset_thresholds_flag = False

    def _load_frozen_thresholds_on_startup(self):
        """Call this once in _init_: load today‚Äôs frozen thresholds or compute & save once."""
        from datetime import date as _date
        self._ensure_frozen_daily_targets(_date.today())
    # -------------------------------------------------------------------
        
    def show_goal_info(self):
        """Show detailed explanation of Study Goal System"""
        win = tk.Toplevel(self)
        win.title("Study Goal System")
        win.geometry("490x635")
        win.resizable(False, False)

        # Main container with padding
        container = tk.Frame(win, padx=20, pady=15)
        container.pack(fill="both", expand=True)
        
        # Title
        tk.Label(container, text="üìò Study Goal System", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 15))
        
        # Text widget
        text_widget = tk.Text(container, wrap="word", height=30, width=62,
                              font=("Arial", 10), relief="flat", bg="#f9f9f9")
        text_widget.pack(pady=(0, 15))

        # Define tags
        text_widget.tag_configure("header", font=("Arial", 11, "bold"), justify="center", spacing3=8)
        text_widget.tag_configure("detail", font=("Arial", 10), justify="center", spacing3=5)
        text_widget.tag_configure("detail_bold", font=("Arial", 10, "bold"), justify="center", spacing3=3)
        text_widget.tag_configure("tip", font=("Arial", 10, "italic"), foreground="#333", spacing3=8, justify="center")

        # Symbol colors
        text_widget.tag_configure("blue", foreground="#1E40AF")
        text_widget.tag_configure("green", foreground="#15803D")
        text_widget.tag_configure("red", foreground="#B91C1C")
        text_widget.tag_configure("orange", foreground="#C2410C")

        # Insert text with formatting
        text_widget.insert("end", "üìä FORMAT: Actual / Required\n\n", ("header", "blue"))

        text_widget.insert("end", "Required Value (fixed for current plan)\n", ("detail_bold", "blue"))
        text_widget.insert("end",
            "- Shows your planned study hours per day\n"
            "- Recalculates automatically if exam date or daily study plan changes\n\n", "detail")

        text_widget.insert("end", "Actual Value (varies daily)\n", ("detail_bold", "blue"))
        text_widget.insert("end",
            "- Based on your real study hours + wasted hours\n"
            "- If Actual ‚â§ Required ‚Üí you are on track\n"
            "- If Actual > Required ‚Üí you must adjust\n\n", "detail")

        text_widget.insert("end", "‚è≥ SHORT-TERM (to next red marker)\n", ("header", "orange"))
        text_widget.insert("end",
            "Shows progress needed to reach the nearest milestone day\n"
            "Keeps you aligned with your next checkpoint\n\n", "detail")

        text_widget.insert("end", "üéØ LONG-TERM (to exam date)\n", ("header", "green"))
        text_widget.insert("end",
            "Shows progress needed to reach the final exam target\n"
            "Considers the entire remaining period\n\n", "detail")

        text_widget.insert("end", "üî¥ RED BLINKING WARNING\n", ("header", "red"))
        text_widget.insert("end",
            "Appears when Actual > Required\n"
            "Means you are falling behind schedule\n"
            "Study more or reduce wastage to return within target\n\n", "detail")

        text_widget.insert("end", "üëâ Rule of Thumb:\n", ("header", "blue"))
        text_widget.insert("end",
            "If both Short-term and Long-term stay at Actual ‚â§ Required,\n"
            "your exam preparation will stay fully on track.\n", "tip")

        text_widget.config(state="disabled")

        # OK button
        tk.Button(container, text="OK", font=("Arial", 11, "bold"),
                 bg="#4CAF50", fg="white", width=10,
                 command=win.destroy).pack()
            
    def set_goal(self, goal_hours: float, marker_gap_days: int):
        ...       
        self.update_goal_daywise_targets()
        self._reset_thresholds_flag = True  # <-- add this
        
    def _live_total_studied(self) -> int:
        base = 0
        try:
            base = int(get_total_studied_seconds_upto_yesterday())
        except Exception:
            pass
        return base + int(getattr(self, "today_study_stopwatch_seconds", 0))

    def _update_total_study_label_live(self):
        """Update total study time label - shows ALL plans combined with live data"""
        try:
            # ‚úÖ Load saved data from disk
            total_seconds = get_total_stopwatch_studied(plan_name=None)
            
            # ‚úÖ Add unsaved time for current plan (live update)
            if hasattr(self, 'current_plan_name') and hasattr(self, 'today_study_stopwatch_seconds'):
                # Get what's already saved for current plan today
                saved_today = get_today_studied_elapsed(plan_name=self.current_plan_name)
                # Get what's in memory (live)
                live_today = int(self.today_study_stopwatch_seconds)
                
                # Replace saved with live: total - saved_today + live_today
                total_seconds = total_seconds - saved_today + live_today
            
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            
            time_str = f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}"
            
            if hasattr(self, 'total_study_label'):
                self.total_study_label.config(text=f"Total Studied Time: {time_str}")
            
        except Exception as e:
            print(f"[TOTAL STUDY] Error updating label: {e}")
        
    def _get_today_key(self):
        return datetime.now().strftime("%Y-%m-%d")

    def _load_target_drift_today(self):
        store = _load_json_safe(TARGET_DRIFT_FILE, {})
        return int(store.get(self._get_today_key(), 0))

    def _save_target_drift_today(self):
        store = _load_json_safe(TARGET_DRIFT_FILE, {})
        store[self._get_today_key()] = {
            "short": float(self.per_day_drift_short),
            "long":  float(self.per_day_drift_long),
        }
        _save_json_safe(TARGET_DRIFT_FILE, store)

    def _load_last_seen(self):
        """Load the last seen timestamp and remember the plan it was recorded for."""
        try:
            if os.path.exists(LAST_SEEN_FILE):
                with open(LAST_SEEN_FILE, "r", encoding="utf-8") as f:
                    txt = f.read().strip()
                    # Try new JSON structure first
                    try:
                        data = json.loads(txt)
                        if isinstance(data, dict):
                            self._last_seen_plan = data.get("plan")
                            ts_str = data.get("ts") or data.get("timestamp")
                            if ts_str:
                                return datetime.fromisoformat(ts_str)
                    except Exception:
                        # Fallback to legacy plain ISO string
                        self._last_seen_plan = None
                        return datetime.fromisoformat(txt)
        except Exception:
            pass
        return None

    def _save_last_seen(self, ts=None, plan_name=None):
        """Persist the last seen timestamp along with the active plan."""
        try:
            if ts is None:
                ts = datetime.now()
            if plan_name is None:
                plan_name = getattr(self, "current_plan_name", None) or load_last_active_plan() or "Default"

            payload = {"ts": ts.isoformat(), "plan": plan_name}
            with open(LAST_SEEN_FILE, "w", encoding="utf-8") as f:
                json.dump(payload, f)
            self._last_seen_plan = plan_name
        except Exception:
            pass

    def get_active_session_idx_at(self, dt):
        """Like get_active_session_idx(), but for an arbitrary datetime."""
        for idx, sess in enumerate(self.schedule):
            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], dt)
            if st_dt <= dt <= en_dt:
                return idx, st_dt, en_dt
        return None, None, None

    def _restore_offline_drift_dual(self):
        """
        Credit drift across ALL closed time since last seen.
        Counts only minutes that were inside an ACTIVE session and not on a break.
        For each minute, adds drift using the remaining-day divisors as of that minute's day.
        """
        try:
            last_seen = self._load_last_seen()
        except Exception:
            last_seen = None

        now = datetime.now()
        if not last_seen:
            # First run: just stamp now
            self._save_last_seen(now)
            self._offline_restored_for_today = True
            return

        # Accumulators for drift credits
        credit_short = 0.0
        credit_long  = 0.0

        step = timedelta(seconds=60)
        t = last_seen

        while t < now:
            day = t.date()

            # Only count minutes that were in active session & not in its break
            idx, _, _ = self.get_active_session_idx_at(t)
            if idx is not None and not is_on_break(t, idx, self.schedule):
                # Long-term divisor for that day (exam day excluded)
                rdl_long = max(1, (self.progress_exam_date - day).days)

                # Short-term divisor for that day (to next marker after that day)
                nm = self._next_marker_after(day)
                if nm:
                    rdl_short = max(1, (nm - day).days)
                else:
                    rdl_short = rdl_long  # fallback when no upcoming marker

                credit_short += 60.0 / float(rdl_short)
                credit_long  += 60.0 / float(rdl_long)

            t += step

        # Apply credits to today's drifts
        if not hasattr(self, "per_day_drift_short"): self.per_day_drift_short = 0.0
        if not hasattr(self, "per_day_drift_long"):  self.per_day_drift_long  = 0.0
        self.per_day_drift_short += credit_short
        self.per_day_drift_long  += credit_long

        # Persist and stamp
        self._save_target_drift_today()
        self._save_last_seen(now)
        self._offline_restored_for_today = True
        
    def update_goal_daywise_targets(self):
        # Retired: the new minutes-based computation owns the labels
        self.recompute_required_rates()

    def update_runrate_display(self):
        # Also retired; keep the name so any old calls won‚Äôt crash
        self.recompute_required_rates()

    def update_goal_daywise_targets_loop(self):
        # Use the new single source of truth
        try:
            self.recompute_required_rates()
            self._save_last_seen()  # keep the stamp you had
        finally:
            # update every 30 sec (not 1 sec)
            self.after(30000, self.update_goal_daywise_targets_loop)

    def _next_marker_after(self, d: date):
        """Return the first marker date strictly after day d, else None."""
        for md, _ in self.progress_markers:
            if md > d:
                return md
        return None
        
    

    
            
    def get_today_session_wastage(self):
        """Get today's wastage during session time only (excludes breaks)"""
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        today_str = datetime.now().strftime("%Y-%m-%d")
        total = 0
        
        for entry in wastage_log:
            if entry.get("Date") == today_str:
                # Only count if it's during a session (not break time)
                session_name = entry.get("Session", "")
                if session_name and entry.get("Missed", "No") != "Yes":
                    # This is actual session wastage, not a missed session
                    total += parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))
        
        return total

    def get_total_session_wastage(self):
        """Get total wastage during session time only"""
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        total = 0
        
        for entry in wastage_log:
            session_name = entry.get("Session", "")
            if session_name and entry.get("Missed", "No") != "Yes":
                total += parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))
        
        return total
        
    def _save_target_drift_today(self):
        """Persist today's drift buckets (backward compatible)."""
        store = _load_json_safe(TARGET_DRIFT_FILE, {})
        today_key = self._get_today_key()
        # ensure dict shape
        prev = store.get(today_key, {})
        if not isinstance(prev, dict):
            prev = {"short": 0.0, "long": 0.0}
        prev["short"] = float(getattr(self, "per_day_drift_short", 0.0))
        prev["long"]  = float(getattr(self, "per_day_drift_long",  0.0))
        store[today_key] = prev
        _save_json_safe(TARGET_DRIFT_FILE, store)
        
    def change_exam_date(self):
        from datetime import datetime, timedelta

        config_path = app_paths.exam_date_file

        try:
            # ---------- detect current exam name ----------
            try:
                prof = _load_profile() or {}
                current_exam_name = (prof.get("exam_name") or "").strip()
            except Exception:
                current_exam_name = ""

            # ---------- Load last saved date for prefill ----------
            initial_value = ""

            # 1) If helper get_exam_date_for_exam() exists (per-exam mode), use it
            try:
                if "get_exam_date_for_exam" in globals():
                    dt = get_exam_date_for_exam(current_exam_name)
                    if dt:
                        initial_value = dt.isoformat()
            except Exception as e:
                print(f"[EXAM] get_exam_date_for_exam failed in change_exam_date: {e}")

            # 2) Fallback: read exam_date_file directly
            if not initial_value and os.path.exists(config_path):
                try:
                    with open(config_path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    if isinstance(data, dict):
                        if "exam_date" in data and isinstance(data["exam_date"], str):
                            # legacy { "exam_date": "YYYY-MM-DD" }
                            initial_value = data["exam_date"]
                        elif current_exam_name and current_exam_name in data:
                            val = data[current_exam_name]
                            if isinstance(val, str):
                                initial_value = val
                        elif "__GLOBAL__" in data and isinstance(data["__GLOBAL__"], str):
                            initial_value = data["__GLOBAL__"]
                except Exception as e:
                    print(f"[EXAM] Failed to read exam_date_file in change_exam_date: {e}")

            # 3) Fallback to in-memory value
            if not initial_value and getattr(self, "progress_exam_date", None):
                initial_value = self.progress_exam_date.isoformat()

            # 4) Final fallback: 30 days from today
            if not initial_value:
                initial_value = (datetime.now().date() + timedelta(days=30)).isoformat()

            # ---------- Create custom date input dialog (same UI as before) ----------
            dialog = tk.Toplevel(self)
            dialog.title("Change Exam Date")
            dialog.geometry("420x340")
            dialog.resizable(False, False)
            dialog.configure(bg="#F8F9FA")

            # Make it modal
            dialog.transient(self)
            dialog.grab_set()

            # Center the dialog
            dialog.update_idletasks()
            x = self.winfo_x() + (self.winfo_width() // 2) - 210
            y = self.winfo_y() + (self.winfo_height() // 2) - 140
            dialog.geometry(f"+{x}+{y}")

            # Variable to store result
            result = {"date": None}

            # Main container
            main_container = tk.Frame(dialog, bg="#FFFFFF", relief="flat", bd=1)
            main_container.pack(fill="both", expand=True, padx=2, pady=2)

            # Header
            header_frame = tk.Frame(main_container, bg="#2C3E50", height=50)
            header_frame.pack(fill="x")
            header_frame.pack_propagate(False)

            header_label = tk.Label(
                header_frame,
                text="üìÖ  CHANGE EXAM DATE",
                font=("Segoe UI", 12, "bold"),
                fg="#FFFFFF",
                bg="#2C3E50"
            )
            header_label.pack(expand=True)

            # Content area
            content_frame = tk.Frame(main_container, bg="#FFFFFF", padx=30, pady=20)
            content_frame.pack(fill="both", expand=True)

            # Instruction label
            instruction_label = tk.Label(
                content_frame,
                text="Enter exam date (YYYY-MM-DD):",
                font=("Segoe UI", 10),
                bg="#FFFFFF",
                fg="#2C3E50"
            )
            instruction_label.pack(anchor="w", pady=(0, 10))

            # Date input frame with border
            input_frame = tk.Frame(content_frame, bg="#E8E8E8", relief="flat", bd=1)
            input_frame.pack(fill="x", pady=(0, 5))

            # Date entry field
            date_var = tk.StringVar(value=initial_value)
            date_entry = tk.Entry(
                input_frame,
                textvariable=date_var,
                font=("Segoe UI", 11),
                bg="#FAFAFA",
                fg="#2C3E50",
                bd=0,
                justify="center"
            )
            date_entry.pack(fill="x", padx=1, pady=1, ipady=8)

            # Example format label
            example_label = tk.Label(
                content_frame,
                text="Example: 2025-12-31",
                font=("Segoe UI", 9),
                bg="#FFFFFF",
                fg="#6C757D"
            )
            example_label.pack(anchor="w", pady=(0, 10))

            # Current date info
            if initial_value:
                try:
                    current_date = datetime.strptime(initial_value, "%Y-%m-%d")
                    days_left = (current_date.date() - datetime.now().date()).days
                    info_text = f"Current exam date: {current_date.strftime('%B %d, %Y')} ({days_left} days left)"
                    info_label = tk.Label(
                        content_frame,
                        text=info_text,
                        font=("Segoe UI", 9),
                        bg="#E3F2FD",
                        fg="#1976D2",
                        padx=10,
                        pady=5
                    )
                    info_label.pack(fill="x", pady=(10, 0))
                except Exception:
                    pass

            # Error label (hidden initially)
            error_label = tk.Label(
                content_frame,
                text="",
                font=("Segoe UI", 9),
                bg="#FFFFFF",
                fg="#DC3545"
            )
            error_label.pack(pady=(5, 0))

            # Button frame
            button_frame = tk.Frame(content_frame, bg="#FFFFFF")
            button_frame.pack(fill="x", pady=(20, 0))

            # UPDATE button logic
            def validate_and_update():
                new_date_str = date_var.get().strip()
                if not new_date_str:
                    error_label.config(text="‚ö† Please enter a date")
                    return

                try:
                    new_date = datetime.strptime(new_date_str, "%Y-%m-%d").date()

                    if hasattr(self, "progress_start_date") and new_date <= self.progress_start_date:
                        error_label.config(text="‚ö† Date must be after the start date")
                        return

                    result["date"] = new_date_str
                    dialog.destroy()
                except ValueError:
                    error_label.config(text="‚ö† Invalid format. Use YYYY-MM-DD")

            update_btn = tk.Button(
                button_frame,
                text="UPDATE",
                font=("Arial", 10, "bold"),
                bg="#28A745",
                fg="white",
                relief="raised",
                bd=2,
                padx=25,
                pady=8,
                command=validate_and_update
            )
            update_btn.pack(side="right", padx=5)

            # Cancel button
            cancel_btn = tk.Button(
                button_frame,
                text="CANCEL",
                font=("Arial", 10),
                bg="#6C757D",
                fg="white",
                relief="raised",
                bd=2,
                padx=25,
                pady=8,
                command=dialog.destroy
            )
            cancel_btn.pack(side="right", padx=5)

            # Allow Enter key to submit
            date_entry.bind("<Return>", lambda e: validate_and_update())

            # Focus on entry
            date_entry.focus_set()
            date_entry.select_range(0, tk.END)

            # Wait for dialog to close
            dialog.wait_window()

            # ---------- Process result if date was entered ----------
            if result["date"]:
                new_date_str = result["date"]
                new_date = datetime.strptime(new_date_str, "%Y-%m-%d").date()

                # Update in memory
                self.progress_exam_date = new_date
                print(f"[EXAM] New exam date set via change_exam_date: {new_date}")

                # üî• Reset opened days tracking when exam date changes
                try:
                    if hasattr(self, "reset_opened_days"):
                        self.reset_opened_days()
                except Exception as e:
                    print(f"[EXAM] reset_opened_days failed: {e}")

                # Regenerate red markers using last saved gap
                try:
                    marker_gap_days = self.get_saved_marker_gap_days()
                    self.progress_markers = []
                    current = self.progress_start_date
                    while current <= self.progress_exam_date:
                        label = current.strftime("%b %d")
                        self.progress_markers.append((current, label))
                        current += timedelta(days=marker_gap_days)
                except Exception as e:
                    print(f"[EXAM] marker regeneration failed: {e}")

                # ---------- Save to exam_date.json (per exam if available) ----------
                try:
                    # Preferred: per-exam helper
                    if "set_exam_date_for_exam" in globals():
                        set_exam_date_for_exam(current_exam_name, new_date)
                    else:
                        # Fallback: keep legacy structure or upgrade to mapping
                        data = {}
                        if os.path.exists(config_path):
                            try:
                                with open(config_path, "r", encoding="utf-8") as f:
                                    existing = json.load(f)
                                if isinstance(existing, dict):
                                    data = existing
                            except Exception:
                                data = {}

                        if data and "exam_date" in data and len(data) == 1:
                            # Pure legacy file -> just overwrite legacy key
                            data = {"exam_date": new_date.isoformat()}
                        else:
                            # Multi-exam mapping
                            key = current_exam_name or "__GLOBAL__"
                            data[key] = new_date.isoformat()

                        with open(config_path, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2)

                    print("[EXAM] Saved new exam date to exam_date.json")
                except Exception as e:
                    print(f"[EXAM] Failed to write exam_date_file: {e}")

                # ---------- Refresh UI ----------
                try:
                    if hasattr(self, "_calculate_goal_from_schedule"):
                        self._calculate_goal_from_schedule()
                    if hasattr(self, "update_progress_bar"):
                        self.update_progress_bar()
                    if hasattr(self, "update_goal_daywise_targets"):
                        # your original called update_goal_daywise_targets(0)
                        self.update_goal_daywise_targets(0)
                    if hasattr(self, "refresh_goal_and_markers"):
                        self.refresh_goal_and_markers()
                except Exception as e:
                    print(f"[EXAM] UI refresh after date change failed: {e}")

                # Countdown label uses progress_exam_date / per-exam helper,
                # so it will auto-update on the next tick.

        except Exception as e:
            print(f"Error in change_exam_date: {e}")


    def load_or_ask_exam_date(self):
        """
        Load exam date from exam_date.json, or ask the user if not set.
        Keeps self.progress_exam_date in sync so countdown + goals work.
        """
        from datetime import datetime, date

        config_path = app_paths.exam_date_file

        # ---------- 1. Try to load from file ----------
        try:
            if os.path.exists(config_path):
                with open(config_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict) and data.get("exam_date"):
                        dt = datetime.fromisoformat(data["exam_date"]).date()
                        self.progress_exam_date = dt
                        print(f"[EXAM] Loaded exam date from file: {dt}")
                        return dt
        except Exception as e:
            print(f"[EXAM] Failed to load exam_date.json: {e}")

        # ---------- 2. Ask user via simple popup ----------
        while True:
            popup = tk.Toplevel(self.master)
            popup.title("Set Exam Date")
            popup.geometry("350x180")
            popup.resizable(False, False)
            popup.transient(self.master)
            popup.grab_set()

            tk.Label(
                popup,
                text="Enter your target exam date (YYYY-MM-DD):",
                font=("Segoe UI", 10)
            ).pack(pady=(20, 5))

            default_val = (date.today() + timedelta(days=30)).isoformat()
            entry_var = tk.StringVar(value=default_val)
            entry = tk.Entry(popup, textvariable=entry_var, font=("Segoe UI", 11), width=20)
            entry.pack(pady=(0, 10))
            entry.focus_set()

            result = {"value": None}

            def on_ok():
                raw = entry_var.get().strip()
                try:
                    result["value"] = datetime.fromisoformat(raw).date()
                    popup.destroy()
                except Exception:
                    messagebox.showerror("Invalid Date", "Please enter date as YYYY-MM-DD")

            def on_cancel():
                popup.destroy()

            btn_frame = tk.Frame(popup)
            btn_frame.pack(pady=10)
            tk.Button(btn_frame, text="Save", width=10, command=on_ok).pack(side="left", padx=5)
            tk.Button(btn_frame, text="Cancel", width=10, command=on_cancel).pack(side="left", padx=5)

            popup.wait_window()

            if result["value"] is None:
                # user cancelled; just continue loop until valid date entered
                continue

            new_dt = result["value"]

            # ----- save globally and update state -----
            try:
                os.makedirs(os.path.dirname(config_path), exist_ok=True)
                with open(config_path, "w", encoding="utf-8") as f:
                    json.dump({"exam_date": new_dt.isoformat()}, f, indent=2)
                print(f"[EXAM] Saved new exam date to exam_date.json: {new_dt}")
            except Exception as e:
                print(f"[EXAM] Failed to write exam_date.json: {e}")

            self.progress_exam_date = new_dt

            # Recompute goal / markers if needed
            try:
                if hasattr(self, "_calculate_goal_from_schedule"):
                    self._calculate_goal_from_schedule()
                if hasattr(self, "update_goal_daywise_targets"):
                    self.update_goal_daywise_targets()
                if hasattr(self, "update_progress_bar"):
                    self.update_progress_bar()
            except Exception as e:
                print(f"[EXAM] Error updating after initial exam date set: {e}")

            return new_dt
            
        
    def get_saved_marker_gap_days(self):
        try:
            if os.path.exists(app_paths.goal_config_file):
                with open(app_paths.goal_config_file, "r") as f:
                    content = f.read().strip()
                    if content:
                        data = json.loads(content)
                        return data.get("marker_gap_days", 7)
        except:
            pass
        return 7
        
    def edit_goal_duration(self):
        """Edit only marker gap days (per-day goal comes from schedule)"""
        popup = tk.Toplevel(self)
        popup.title("Edit Progress Markers")
        popup.geometry("320x250")
        popup.resizable(False, False)

        # Info label
        tk.Label(popup, text="Study hours are calculated from\nyour daily schedule automatically",
                font=("Arial", 10), fg="#666").pack(pady=(15, 10))
        
        # Current daily hours display (read-only)
        try:
            total_minutes = 0
            for sess in self.schedule:
                start = parse_time(sess[1])
                end = parse_time(sess[2])
                if start and end:
                    st_dt = datetime.combine(date.today(), start)
                    en_dt = datetime.combine(date.today(), end)
                    if en_dt <= st_dt:
                        en_dt += timedelta(days=1)
                    total_minutes += (en_dt - st_dt).total_seconds() / 60
            
            daily_hours = total_minutes / 60
            tk.Label(popup, text=f"Daily Study Hours: {daily_hours:.1f}h (from schedule)",
                    font=("Arial", 11, "bold")).pack(pady=5)
        except:
            pass
        
        # Marker gap input
        tk.Label(popup, text="Red marker every ___ days:", 
                font=("Arial", 11)).pack(pady=(15, 5))
        
        marker_frame = tk.Frame(popup)
        marker_frame.pack()
        
        current_gap = self.get_saved_marker_gap_days()
        marker_var = tk.StringVar(value=str(current_gap))
        marker_entry = tk.Entry(marker_frame, textvariable=marker_var, 
                               font=("Arial", 12), width=10, justify="center")
        marker_entry.pack(side="left")
        
        tk.Label(marker_frame, text="days", font=("Arial", 11)).pack(side="left", padx=5)
        
        def save_changes():
            try:
                gap_days = int(marker_var.get())
                if gap_days <= 0:
                    raise ValueError

                # ‚úÖ Calculate DAILY hours from schedule (not total)
                total_minutes = 0
                for sess in self.schedule:
                    if not sess or len(sess) < 3:
                        continue
                    
                    start = parse_time(sess[1])
                    end = parse_time(sess[2])
                    if start and end:
                        st_dt = datetime.combine(date.today(), start)
                        en_dt = datetime.combine(date.today(), end)
                        if en_dt <= st_dt:
                            en_dt += timedelta(days=1)
                        total_minutes += (en_dt - st_dt).total_seconds() / 60
                
                daily_hours = total_minutes / 60

                # Save marker gap days to goal_config.json
                config = {}
                if os.path.exists(app_paths.goal_config_file):
                    with open(app_paths.goal_config_file, "r") as f:
                        content = f.read().strip()
                        if content:
                            config = json.loads(content)
                
                config["marker_gap_days"] = gap_days
                config["daily_hours"] = daily_hours  # ‚úÖ Save daily, not total
                
                with open(app_paths.goal_config_file, "w") as f:
                    json.dump(config, f, indent=2)

                # Save to profile
                prof = _load_profile()
                prof["daily_study_hours"] = daily_hours
                prof["red_marker_days"] = gap_days
                _save_profile(prof)

                # Rebuild markers
                self.progress_markers = []
                current = self.progress_start_date
                while current <= self.progress_exam_date:
                    label = current.strftime("%b %d")
                    self.progress_markers.append((current, label))
                    current += timedelta(days=gap_days)

                # ‚úÖ Recalculate TOTAL goal (daily √ó days)
                self._calculate_goal_from_schedule()

                # Refresh UI
                if hasattr(self, "refresh_goal_and_markers"):
                    self.refresh_goal_and_markers()
                elif hasattr(self.master, "refresh_goal_and_markers"):
                    self.master.refresh_goal_and_markers()

                self.update_goal_daywise_targets()
                self.update_progress_bar()

                popup.destroy()

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a positive number")
        
        # Buttons
        btn_frame = tk.Frame(popup)
        btn_frame.pack(pady=15)
        
        tk.Button(btn_frame, text="Save", command=save_changes,
                 bg="#4CAF50", fg="white", font=("Arial", 10), width=8).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Cancel", command=popup.destroy,
                 bg="#f44336", fg="white", font=("Arial", 10), width=8).pack(side="left", padx=5)

    def _calculate_goal_from_schedule(self):
        """Calculate TOTAL study hours goal from current schedule and exam date"""
        try:
            # 1. Calculate daily hours from schedule
            total_minutes = 0
            for sess in self.schedule:
                if not sess or len(sess) < 3:
                    continue
                
                start = parse_time(sess[1])
                end = parse_time(sess[2])
                
                if start and end:
                    st_dt = datetime.combine(date.today(), start)
                    en_dt = datetime.combine(date.today(), end)
                    if en_dt <= st_dt:
                        en_dt += timedelta(days=1)
                    total_minutes += (en_dt - st_dt).total_seconds() / 60
            
            daily_hours = total_minutes / 60
            
            # 2. Calculate total days until exam
            from datetime import date as _date
            today = _date.today()
            exam_day = (
                getattr(self, "progress_exam_date", None)
                or _load_exam_date_only()
                or today
            )
            # Keep the cached exam date in sync
            self.progress_exam_date = exam_day

            # Avoid forcing a 1-day minimum so we never default to a per-day target.
            days_left = max(0, (exam_day - today).days)
            
            # 3. Calculate TOTAL goal = daily √ó days
            total_goal_hours = daily_hours * days_left
            
            # Save to goal_config.json
            config = {}
            if os.path.exists(app_paths.goal_config_file):
                with open(app_paths.goal_config_file, "r") as f:
                    content = f.read().strip()
                    if content:
                        config = json.loads(content)
            
            config["goal_hours"] = total_goal_hours  # ‚úÖ Save TOTAL, not daily
            config["daily_hours"] = daily_hours      # ‚úÖ Also save daily for reference
            
            with open(app_paths.goal_config_file, "w") as f:
                json.dump(config, f, indent=2)
            
            # ‚úÖ Update instance variables
            self.progress_goal_hours = total_goal_hours
            self.progress_goal_seconds = int(total_goal_hours * 3600)
            
            # ‚úÖ UPDATE THE STRINGVAR
            if hasattr(self, 'target_hours_var'):
                self.target_hours_var.set(f"{total_goal_hours:.1f}")
                print(f"[GOAL] Updated target_hours_var to {total_goal_hours:.1f}h")
            
            print(f"[GOAL] Calculated goal: {daily_hours:.1f}h/day √ó {days_left} days = {total_goal_hours:.1f}h total")
            
            return total_goal_hours
            
        except Exception as e:
            print(f"[GOAL] Error calculating from schedule: {e}")
            import traceback
            traceback.print_exc()
            return 0
        
    def generate_progress_markers(self, interval_days):
        self.progress_markers = []
        current = self.progress_start_date
        while current <= self.progress_exam_date:
            label = current.strftime("%b %d")
            self.progress_markers.append((current, label))
            current += timedelta(days=interval_days)
    
    def clean_schedule(self):
        cleaned = []
        for sess in self.schedule:
            if isinstance(sess, (list, tuple)) and len(sess) == 4:
                cleaned.append(sess)
            else:
                print("‚ùå Corrupted session removed:", sess)
        self.schedule = cleaned
        
    def clean_schedule(self):
        """Keep only valid sessions with 4 fields, allow 'No Break'."""
        def is_valid(entry):
            if not isinstance(entry, (list, tuple)) or len(entry) != 4:
                return False
            name, start, end, brk = entry
            # Validate name, start, end (must be non-empty strings)
            if not all(isinstance(x, str) and x.strip() for x in [name, start, end]):
                return False
            # Allow break to be 'No Break' or a valid string
            if not isinstance(brk, str):
                return False
            return True

        self.schedule = [s for s in self.schedule if is_valid(s)]
        
    def auto_refresh_wastage(self):
        # refresh the table
        self.refresh_wastage()
        # refresh the two labels
        self.update_wastage_labels()
        
        # Check if we're in an unregistered active session or paused
        idx, _, _ = get_active_session_idx(self.schedule)
        is_unregistered_active = (idx is not None and 
                                 not getattr(self, "registered", False) and 
                                 not is_on_break(datetime.now(), idx, self.schedule))
        is_paused = getattr(self, "paused", False)
        
        # Use faster refresh during active wastage tracking
        if is_unregistered_active or is_paused:
            # Refresh every 1 second for real-time updates
            self.after(1000, self.auto_refresh_wastage)
        else:
            # Normal refresh every 5 seconds when not actively tracking wastage
            self.after(5000, self.auto_refresh_wastage)
        
    import os
    from datetime import datetime

    def update_opened_days(self):
        today_str = datetime.now().strftime("%Y-%m-%d")
        fname = app_paths.opened_days_file
        opened_days = set()

        if os.path.exists(fname):
            with open(fname, "r") as f:
                for line in f:
                    opened_days.add(line.strip())

        opened_days.add(today_str)

        with open(fname, "w") as f:
            for d in sorted(opened_days):
                f.write(d + "\n")

        self.day_count = len(opened_days)
        
    def reset_opened_days(self):
        """Reset the opened days tracking when exam date changes"""
        fname = app_paths.opened_days_file
        
        # Clear the file and start fresh with today
        with open(fname, "w") as f:
            today_str = datetime.now().strftime("%Y-%m-%d")
            f.write(today_str + "\n")
        
        # Update the count to 1 (starting fresh)
        self.day_count = 1
        
        # Instantly update the UI label
        self.day_label_var.set(f"Day: {self.day_count}")
    
    def check_command_queue(self):
        while not self.command_queue.empty():
            cmd, data = self.command_queue.get()
            if cmd == "pause":
                self.toggle_pause()
            elif cmd == "resume":
                if self.paused:
                    self.toggle_pause()
        self.after(100, self.check_command_queue)
     
    def send_current_session_info(self):
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        if idx is not None:
            session_name = self.schedule[idx][0]
            start_time = st_dt.strftime("%I:%M %p").lstrip("0")
            end_time = en_dt.strftime("%I:%M %p").lstrip("0")
            msg = (
                f"Current Session: {session_name}\n"
                f"Scheduled Time: {start_time} - {end_time}"
            )
        else:
            msg = "No session is currently running."
        self.send_telegram(msg)
    
    def get_current_break_time(self):
        idx = getattr(self, "active_session_idx", None)
        schedule = getattr(self, "schedule", [])
        if idx is not None and isinstance(schedule, list) and idx < len(schedule):
            session = schedule[idx]
            if isinstance(session, (list, tuple)) and len(session) >= 3:
                return session[1], session[2]  # (break_start, break_end)
        return None, None
        
    def start_timer(self):
        # If you already have a toggle_pause/resume logic, call it here
        if getattr(self, 'paused', False):
            self.toggle_pause()   # Resume
        elif not getattr(self, 'registered', False):
            self.toggle_register()  # Start
        # If you use another function to start or resume, call that instead!
        
    @property
    def session_remaining_seconds(self):
        if self.active_session_idx is not None and self.session_end_datetime is not None:
            now = datetime.now()
            remaining = (self.session_end_datetime - now).total_seconds()
            return max(int(remaining), 0)
        return 0
        
    def update_pause_credit_label(self):
        mins = int(self.pause_credit_seconds // 60)
        secs = int(self.pause_credit_seconds % 60)
        text = f"Pause Credit: {mins} min {secs} sec" if mins else f"Pause Credit: {secs} sec"
        self.pause_credit_label.config(text=text)

        # persist to state on each update
        try:
            if not hasattr(self, "state") or not isinstance(self.state, dict):
                self.state = load_state()
            self.state["pause_credit_seconds"] = int(self.pause_credit_seconds)
            save_state(self.state)
        except Exception as e:
            print("pause_credit persist failed:", e)
        
    def update_progress_bar(self, live_today_seconds=None):
        # Use the latest target hours string
        try:
            goal_hours = float(self.target_hours_var.get())
        except:
            goal_hours = 0
        
        self.progress_goal_seconds = int(goal_hours * 3600)
        
        # Get plan-specific studied seconds
        total_studied_seconds = get_total_studied_seconds_upto_yesterday(
            plan_name=self.current_plan_name
        )
        
        if live_today_seconds is not None:
            total_studied_seconds += int(live_today_seconds)
        else:
            # Get today's time for current plan only
            today_seconds = get_today_studied_elapsed(plan_name=self.current_plan_name)
            total_studied_seconds += today_seconds
        
        percent = min(100.0, 100 * total_studied_seconds / self.progress_goal_seconds) if self.progress_goal_seconds > 0 else 0
        
        canvas = self.progress_canvas
        canvas.delete("all")
        w, h = 340, 12
        x0, y0 = 20, 5
        canvas.create_rectangle(x0, y0, x0 + w, y0 + h, outline="#aaaaaa", width=2, fill="#eaf3fa")
        fill_w = int(w * percent / 100)
        canvas.create_rectangle(x0, y0, x0 + fill_w, y0 + h, fill="#4ba1ff", outline="")
        
        # Draw red markers
        if self.progress_exam_date is None:
            self.progress_exam_date = date.today()
        if self.progress_start_date is None:
            self.progress_start_date = date.today()

        n_days = (self.progress_exam_date - self.progress_start_date).days
        if n_days <= 0:
            n_days = 1
        daily_target = self.progress_goal_seconds / n_days
        
        for marker_date, label in self.progress_markers:
            if marker_date < self.progress_start_date or marker_date > self.progress_exam_date:
                continue
            day_num = (marker_date - self.progress_start_date).days
            marker_x = x0 + int(w * day_num / n_days)
            canvas.create_line(marker_x, y0, marker_x, y0 + h, fill="#ff6600", width=2)
            marker_goal = daily_target * day_num
            marker_goal_h = marker_goal / 3600
            label_text = f"{label}\n{int(marker_goal_h)}h"
            canvas.create_text(marker_x + 2, y0 + h + 8, text=label_text, font=("Arial", 8), fill="#ff6600", anchor="n")
        
        # Show final progress text
        studied_h = total_studied_seconds // 3600
        studied_m = (total_studied_seconds % 3600) // 60
        studied_s = total_studied_seconds % 60
        text = f"Progress: {int(studied_h)}h {int(studied_m):02}m {int(studied_s):02}s / {goal_hours:.1f}h ({percent:.1f}%)"
        
        self.progress_text_label.config(text=text)

    def save_session_history(self, action, session_data):
        """Log session history to a CSV file on edit/delete."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(app_paths.session_history_file, "a", newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            # Add a header if file is empty
            if f.tell() == 0:
                writer.writerow(["Session", "Timestamp", "Action", "Scheduled", "Actual", "Wastage", "Date", "Missed"])
            writer.writerow([session_data[0], timestamp, action] + session_data[1:])
            
    def update_wastage_day_summary(self):
        """
        Fixed version that handles current date midnight-crossing sessions correctly.
        Uses actual wastage from top section instead of full duration.
        NOW FILTERS BY CURRENT PLAN.
        """
        import re
        from datetime import datetime, timedelta
        
        load_wastage_log()
        
        # Get current plan name
        current_plan = getattr(self, 'current_plan_name', 'Default')
        
        # Filter wastage_log to only current plan's entries
        plan_wastage_log = get_current_plan_wastage_log(current_plan)

        # --- Skip auto-population if no wastage data exists for this plan ---
        if not plan_wastage_log:
            # Clear this plan's summary
            save_wastage_day_summary({}, current_plan)
            return {}
        
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)

        # Get date range ONLY from log (no 30-day addition)
        all_dates = set(e.get("Date") for e in plan_wastage_log if e.get("Date"))       
        today = datetime.now().date()

        by_day = {}
        missed_count_by_day = {}
        all_groups = set()

        for date_str in sorted(all_dates):
            try:
                date_obj = datetime.strptime(date_str, "%Y-%m-%d")
            except:
                continue
                
            if date_obj.date() > today:
                continue

            by_day[date_str] = {}
            missed_count_by_day[date_str] = 0
            
            is_today = date_obj.date() == today
            
            # Get scheduled sessions for this date (including midnight-crossing ones)
            scheduled_sessions = []
            for sess in getattr(self, "schedule", []):
                try:
                    st_dt, en_dt = get_session_datetimes(sess[1], sess[2], date_obj)
                    
                    # Check if session belongs to this date
                    session_belongs_to_this_date = False
                    session_crosses_midnight = False
                    
                    if st_dt.date() == date_obj.date():
                        # Session starts on this date
                        session_belongs_to_this_date = True
                        if en_dt.date() > st_dt.date():
                            session_crosses_midnight = True
                    elif en_dt.date() == date_obj.date() and st_dt.date() == (date_obj.date() - timedelta(days=1)):
                        # Session crosses midnight FROM previous day TO this date
                        session_belongs_to_this_date = True
                        session_crosses_midnight = True
                    
                    if session_belongs_to_this_date:
                        scheduled_sessions.append({
                            'name': sess[0],
                            'start': st_dt,
                            'end': en_dt,
                            'crosses_midnight': session_crosses_midnight
                        })
                        
                except Exception:
                    continue
            
            # Process each scheduled session
            for scheduled in scheduled_sessions:
                session_name = scheduled['name']
                st_dt = scheduled['start']
                en_dt = scheduled['end']
                crosses_midnight = scheduled['crosses_midnight']
                
                # Map to group
                base = re.sub(r"\s+\d+$", "", session_name or "")
                try:
                    group = SUBJECT_GROUPS.get(session_name, SUBJECT_GROUPS.get(base, base))
                except NameError:
                    group = base
                all_groups.add(group)
                
                if group not in by_day[date_str]:
                    by_day[date_str][group] = 0
                
                # Find matching entry from plan_wastage_log (filtered by plan)
                matching_entry = None
                
                # Create possible scheduled start formats to match against log entries
                scheduled_start_formats = []
                
                # Try the original scheduled time format
                original_scheduled = st_dt.strftime("%d-%b-%Y %I:%M %p")
                scheduled_start_formats.append(original_scheduled)
                
                # For midnight crossing sessions on current day, also try today's date with original time
                if is_today and crosses_midnight and st_dt.date() != today:
                    today_scheduled = datetime.combine(today, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")
                    scheduled_start_formats.append(today_scheduled)
                
                # Look for matching entry in wastage log (ONLY current plan)
                for e in plan_wastage_log:
                    if (e.get("Session", "") == session_name and 
                        e.get("Date") == date_str and
                        e.get("Scheduled Start", "") in scheduled_start_formats):
                        matching_entry = e
                        break
                
                # If no exact match found, try broader search for midnight crossing sessions
                if not matching_entry and crosses_midnight:
                    search_dates = [date_str]
                    if st_dt.date() == date_obj.date():
                        # Session starts on this date, might have entry on next date too
                        next_date = (date_obj + timedelta(days=1)).strftime("%Y-%m-%d")
                        search_dates.append(next_date)
                    else:
                        # Session started on previous date
                        prev_date = (date_obj - timedelta(days=1)).strftime("%Y-%m-%d")
                        search_dates.append(prev_date)
                    
                    for search_date in search_dates:
                        for e in plan_wastage_log:
                            if (e.get("Date") == search_date and 
                                e.get("Session", "") == session_name):
                                if not matching_entry:  # Take first match found
                                    matching_entry = e
                
                if matching_entry:
                    # Use actual recorded wastage from the log entry
                    wastage_seconds = parse_hhmmss(matching_entry.get("Wastage (hh:mm:ss)", "00:00:00"))
                    by_day[date_str][group] += wastage_seconds
                    
                    # Check if marked as missed
                    is_missed = str(matching_entry.get("Missed", "No")).strip().lower() == "yes"
                    if is_missed:
                        missed_count_by_day[date_str] += 1
                else:
                    # No entry found - calculate based on session status
                    if is_today:
                        current_time = datetime.now()
                        
                        # For sessions that should have started
                        if current_time >= st_dt:
                            if current_time >= en_dt:
                                # Session completely finished - use full duration
                                session_duration = int((en_dt - st_dt).total_seconds())
                                by_day[date_str][group] += session_duration
                            else:
                                # Session in progress - use elapsed time
                                elapsed_seconds = int((current_time - st_dt).total_seconds())
                                by_day[date_str][group] += elapsed_seconds
                            missed_count_by_day[date_str] += 1
                        # If session hasn't started yet, don't add anything
                    else:
                        # For past dates, session was completely missed
                        session_duration = int((en_dt - st_dt).total_seconds())
                        by_day[date_str][group] += session_duration
                        missed_count_by_day[date_str] += 1

            # Remove empty dates
            if by_day[date_str] == {} and missed_count_by_day[date_str] == 0:
                del by_day[date_str]
                del missed_count_by_day[date_str]

        # Normalize data
        summary = {}
        for date_str in sorted(by_day.keys()):
            summary[date_str] = {}
            for group in sorted(all_groups):
                summary[date_str][group] = int(by_day[date_str].get(group, 0))
            summary[date_str]["Missed Sessions"] = int(missed_count_by_day.get(date_str, 0))

        save_wastage_day_summary(summary, current_plan)
        return summary
        
    def _calc_waste_live_seconds(self):
        """
        Compute today's and total wastage directly from in-memory wastage_log.
        Avoids stale/summary-file issues so the 'Live' labels are truly live.
        """
        # ensure in-memory log is fresh if another thread/process wrote the CSV
        # (safe + cheap; remove if you never write from outside this process)
        try:
            load_wastage_log()
            backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        except Exception:
            pass

        resolved_plan = _resolve_plan_name(getattr(self, "current_plan_name", None), self)

        today_key = datetime.now().strftime("%Y-%m-%d")
        today_sec = 0
        total_sec = 0
        
        # Make sure wastage_log exists and is a list
        if not hasattr(self, 'wastage_log') and 'wastage_log' not in globals():
            return 0, 0
            
        try:
            for e in wastage_log:
                if not isinstance(e, dict):
                    continue  # Skip malformed entries
                if e.get("Plan", "Default") != resolved_plan:
                    continue
                try:
                    sec = parse_hhmmss(e.get("Wastage (hh:mm:ss)", "00:00:00"))
                    total_sec += sec
                    if e.get("Date") == today_key:
                        today_sec += sec
                except Exception:
                    continue  # Skip entries that can't be parsed
        except Exception as e:
            print(f"Error calculating live wastage: {e}")
            return 0, 0
            
        return today_sec, total_sec

    
        
    def get_today_wastage_seconds(self):
        """Sum hh:mm:ss from wastage_log for today's date."""
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        today_str = datetime.now().strftime("%Y-%m-%d")
        total = 0
        resolved_plan = _resolve_plan_name(getattr(self, "current_plan_name", None), self)
        for entry in wastage_log:
            if entry.get("Date") == today_str and entry.get("Plan", "Default") == resolved_plan:
                total += parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))
        return total

    def get_grand_wastage_seconds(self):
        """Sum hh:mm:ss across all rows in wastage_log."""

        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        total = 0
        resolved_plan = _resolve_plan_name(getattr(self, "current_plan_name", None), self)
        for entry in wastage_log:
            if entry.get("Plan", "Default") != resolved_plan:
                continue
            total += parse_hhmmss(entry.get("Wastage (hh:mm:ss)", "00:00:00"))
        return total

    def update_wastage_labels(self):
        """Update the two labels on the Live tab - always accurate, reflecting current totals."""
        try:
            # Get today's wastage directly from latest calculation
            today_seconds = getattr(self, 'latest_today_total', 0)
            today_text = hhmmss_from_seconds_total(today_seconds) if today_seconds > 0 else "00:00:00"

            # Get grand total directly from latest calculation  
            grand_seconds = getattr(self, 'latest_grand_total', 0)
            grand_text = hhmmss_from_seconds_total(grand_seconds) if grand_seconds > 0 else "00:00:00"

            # Update Live tab labels with current data
            if hasattr(self, "today_waste_label"):
                self.today_waste_label.config(text=f"Today Wastage: {today_text}")
            if hasattr(self, "total_waste_label"):
                self.total_waste_label.config(text=f"Total Wastage Time: {grand_text}")

        except Exception as e:
            print("update_wastage_labels failed:", e)
            # Fallback to parsing from existing labels if direct values fail
            try:
                base_today_text = "00:00:00"
                if hasattr(self, 'today_total_row_var') and self.today_total_row_var:
                    today_raw = self.today_total_row_var.get()
                    base_today_text = today_raw.replace("TOTAL  -  Wastage: ", "").strip() or "00:00:00"

                base_grand_text = "00:00:00"
                if hasattr(self, 'all_day_total_row_var') and self.all_day_total_row_var:
                    grand_parts = self.all_day_total_row_var.get().split(" | ")
                    if grand_parts:
                        base_grand_text = grand_parts[-1].strip()
                        if base_grand_text.lower().startswith(("grand", "total")):
                            base_grand_text = base_grand_text.split(":", 1)[-1].strip()

                if hasattr(self, "today_waste_label"):
                    self.today_waste_label.config(text=f"Today Wastage: {base_today_text}")
                if hasattr(self, "total_waste_label"):
                    self.total_waste_label.config(text=f"Total Wastage Time: {base_grand_text}")
            except:
                pass  # Silent fallback
                
    def _restore_pause_state_on_startup(self):
        """
        Restore pause state when app restarts.
        If app was closed while paused, restore pause state and start live ticking.
        """
        try:
            # Check if we were paused when app closed
            if self.state.get("pause_active", False):
                self.paused = True
                
                # Restore pause start time
                pause_start_str = self.state.get("pause_start")
                if pause_start_str:
                    try:
                        self.pause_start = datetime.fromisoformat(pause_start_str)
                    except Exception:
                        # If pause start time is invalid, set to now
                        self.pause_start = datetime.now()
                else:
                    # No pause start time saved, set to now
                    self.pause_start = datetime.now()
                    
                # Update button state
                if hasattr(self, "pause_btn"):
                    self.pause_btn.config(text="Resume")
                if hasattr(self, "status_label"):
                    self.status_label.config(text="Paused. Press Resume to continue.", foreground="orange")
                    
                print(f"[STARTUP] Restored pause state. Pause started at: {self.pause_start}")
            else:
                self.paused = False
                self.pause_start = None
                
        except Exception as e:
            print(f"[STARTUP] Failed to restore pause state: {e}")
            # Default to not paused
            self.paused = False
            self.pause_start = None
            
    def on_plan_row_select(self, event=None):
        """Handle selection changes in the plan tree safely."""
        # If the tree itself doesn't exist, nothing to do
        if not hasattr(self, "plan_tree") or not self.plan_tree.winfo_exists():
            return

        selected = self.plan_tree.selection()
        has_selection = bool(selected)

        # Remember that user manually selected something
        if has_selection:
            self.manual_plan_row_selected = True

        # Our actual button attributes in the new UI
        edit_btn = getattr(self, "plan_edit_btn", None)
        delete_btn = getattr(self, "delete_btn", None)

        new_state = "normal" if has_selection else "disabled"

        if edit_btn is not None:
            try:
                edit_btn.config(state=new_state)
            except Exception as e:
                print(f"[PLAN] edit button state change failed: {e}")

        if delete_btn is not None:
            try:
                delete_btn.config(state=new_state)
            except Exception as e:
                print(f"[PLAN] delete button state change failed: {e}")

    def refresh_plan_tree(self):
        """Refresh the tree view OR show splash if empty"""
        
        # ‚úÖ If empty schedule, show splash (buttons stay visible)
        if not self.schedule or len(self.schedule) == 0:
            self._show_plan_splash_in_tree_area()
            return
        
        # ‚úÖ If tree doesn't exist, recreate entire tab
        if not hasattr(self, 'plan_tree') or not self.plan_tree.winfo_exists():
            self.setup_plan_tab()
            return
        
        # ‚úÖ Tree exists and has data - just refresh rows
        self.plan_tree.delete(*self.plan_tree.get_children())
        self.plan_rows.clear()
        
        self.schedule = [sess[:4] for sess in self.schedule if isinstance(sess, (list, tuple)) and len(sess) >= 4]
        
        total_minutes = 0
        for sess in self.schedule:
            name, start, end, brk = sess
            start_parsed = parse_time(start)
            end_parsed = parse_time(end)
            
            if start_parsed and end_parsed:
                st_dt = datetime.combine(date.today(), start_parsed)
                en_dt = datetime.combine(date.today(), end_parsed)
                if en_dt <= st_dt:
                    en_dt += timedelta(days=1)
                duration_td = en_dt - st_dt
                duration_str = f"{duration_td.seconds // 3600:02}:{(duration_td.seconds % 3600) // 60:02}"
                duration_minutes = int(duration_td.total_seconds() // 60)
                total_minutes += duration_minutes
            else:
                duration_str = "--"
                duration_minutes = 0
            
            start12 = to_12hour(start_parsed)
            end12 = to_12hour(end_parsed)
            
            if "-" in brk:
                try:
                    brk_start, brk_end = brk.split("-")
                    brk_start12 = to_12hour(parse_time(brk_start.strip()))
                    brk_end12 = to_12hour(parse_time(brk_end.strip()))
                    brk_disp = f"{brk_start12} - {brk_end12}"
                except:
                    brk_disp = brk
            else:
                brk_disp = brk
            
            material_status = self._get_material_status(name, duration_minutes)
            values = (name, material_status, start12, end12, duration_str, brk_disp)
            
            row_id = self.plan_tree.insert("", tk.END, values=values)
            self.plan_rows.append(row_id)
        
        total_hours = int(total_minutes // 60)
        total_rem_min = int(total_minutes % 60)
        total_str = f"{total_hours:02}:{total_rem_min:02}"
        self.plan_tree.heading("#5", text=f"Duration ({total_str})")


    def _get_material_status(self, session_name, duration_minutes):
        """Check if study material exists for this session's current day."""
        from config_paths import app_paths
        
        materials_file = Path(app_paths.appdata_dir) / "session_materials.json"
        
        if not materials_file.exists():
            return "üìÑ Create"
        
        try:
            materials = json.loads(materials_file.read_text(encoding="utf-8"))
            
            # Get current session day
            current_session_day = self._get_session_current_day(session_name)
            days = self._get_days_until_exam()
            
            if days:
                key = f"{self.current_plan_name}_{session_name}_sessionday{current_session_day}_{days}daysRemaining"
                if key in materials:
                    return "‚úÖ View"
            
            return "üìÑ Create"
                
        except Exception as e:
            print(f"‚ö† Error reading materials: {e}")
            return "üìÑ Create"
            
    def _get_topic_completion_status(self, session_name, topic_name, day):
        """Get completion status for a specific topic on a specific day."""
        from config_paths import app_paths
        
        status_file = Path(app_paths.appdata_dir) / "topic_completion.json"
        
        if not status_file.exists():
            return "pending"
        
        try:
            statuses = json.loads(status_file.read_text(encoding="utf-8"))
            key = f"{self.current_plan_name}_{session_name}_{topic_name}_day{day}"
            return statuses.get(key, "pending")
        except:
            return "pending"


    def _toggle_topic_status(self, session_name, topic_name, day, dialog, canvas):
        """Toggle completion status for a topic."""
        from config_paths import app_paths
        
        status_file = Path(app_paths.appdata_dir) / "topic_completion.json"
        
        try:
            if status_file.exists():
                statuses = json.loads(status_file.read_text(encoding="utf-8"))
            else:
                statuses = {}
            
            key = f"{self.current_plan_name}_{session_name}_{topic_name}_day{day}"
            current_status = statuses.get(key, "pending")
            
            # Toggle
            new_status = "complete" if current_status == "pending" else "pending"
            statuses[key] = new_status
            
            status_file.write_text(json.dumps(statuses, indent=2, ensure_ascii=False), encoding="utf-8")
            
            print(f"‚úÖ Toggled {topic_name} Day {day}: {new_status}")
            
            # Refresh the dialog to show updated status
            # You'll need to reload the material display
            messagebox.showinfo("Status Updated", f"{topic_name} marked as {new_status}!")
            
        except Exception as e:
            print(f"‚ö† Error toggling topic status: {e}")
            messagebox.showerror("Error", f"Failed to update status: {e}")


    def _get_days_until_exam(self):
        """Calculate days remaining until exam."""
        from config_paths import app_paths
        
        exam_date_file = Path(app_paths.appdata_dir) / "exam_date.json"
        
        if not exam_date_file.exists():
            return None
        
        try:
            data = json.loads(exam_date_file.read_text(encoding="utf-8"))
            exam_date_str = data.get("exam_date", "")
            if not exam_date_str:
                return None
            
            exam_date = datetime.strptime(exam_date_str, "%Y-%m-%d").date()
            today = date.today()
            days_remaining = (exam_date - today).days
            return max(1, days_remaining)
            
        except Exception as e:
            print(f"‚ö† Error calculating exam days: {e}")
            return None

    def _get_completion_status(self, session_name, plan_name):
        """Get completion status for a session on its current session day."""
        current_session_day = self._get_session_current_day(session_name)
        completed_days = self._get_session_completed_days(session_name)
        
        if current_session_day in completed_days:
            return "‚úÖ Complete"
        else:
            return "‚è≥ Pending"


    def _toggle_completion_status(self, session_name, plan_name, row_id):
        """Toggle completion status for current session day."""
        current_session_day = self._get_session_current_day(session_name)
        
        new_status_text = self._toggle_session_day_completion(session_name, current_session_day)
        
        # Update UI
        item = self.plan_tree.item(row_id)
        values = list(item['values'])
        values[2] = "‚úÖ Complete" if new_status_text == "complete" else "‚è≥ Pending"
        self.plan_tree.item(row_id, values=values)
        
        # Update row color
        if new_status_text == "complete":
            self.plan_tree.item(row_id, tags=('complete',))
        else:
            self.plan_tree.item(row_id, tags=('pending',))
        
        print(f"‚úÖ Toggled {session_name} Session Day {current_session_day}: {new_status_text}")


    def _get_current_study_day(self, session_name, plan_name):
        """Get which day of study this is - handles pending days."""
        from config_paths import app_paths
        
        progress_file = Path(app_paths.appdata_dir) / "study_progress.json"
        
        if not progress_file.exists():
            # First time ever - save Day 1
            self._save_study_progress(session_name, plan_name, 1)
            return 1
        
        try:
            progress = json.loads(progress_file.read_text(encoding="utf-8"))
            key = f"{plan_name}_{session_name}"
            
            session_data = progress.get(key, {})
            last_access = session_data.get("last_access_date", "")
            current_day = session_data.get("current_day", 1)
            completed_days = session_data.get("completed_days", [])
            
            today_str = date.today().isoformat()
            
            if last_access == today_str:
                # Same day - return current day
                return current_day
            elif last_access and last_access < today_str:
                # New day - check if previous day was completed
                if current_day in completed_days:
                    # Previous day completed - move to next day
                    new_day = current_day + 1
                    self._save_study_progress(session_name, plan_name, new_day)
                    return new_day
                else:
                    # Previous day NOT completed - stay on same day
                    # Just update last_access_date
                    session_data["last_access_date"] = today_str
                    progress[key] = session_data
                    progress_file.write_text(json.dumps(progress, indent=2, ensure_ascii=False), encoding="utf-8")
                    return current_day
            else:
                # First time for this session - save Day 1
                self._save_study_progress(session_name, plan_name, 1)
                return 1
                
        except Exception as e:
            print(f"‚ö† Error getting study day: {e}")
            self._save_study_progress(session_name, plan_name, 1)
            return 1


    def _save_study_progress(self, session_name, plan_name, current_day):
        """Save study progress for session."""
        from config_paths import app_paths
        
        progress_file = Path(app_paths.appdata_dir) / "study_progress.json"
        
        try:
            if progress_file.exists():
                progress = json.loads(progress_file.read_text(encoding="utf-8"))
            else:
                progress = {}
            
            key = f"{plan_name}_{session_name}"
            
            # Preserve completed_days if exists
            existing_data = progress.get(key, {})
            completed_days = existing_data.get("completed_days", [])
            
            progress[key] = {
                "current_day": current_day,
                "last_access_date": date.today().isoformat(),
                "completed_days": completed_days
            }
            
            progress_file.write_text(json.dumps(progress, indent=2, ensure_ascii=False), encoding="utf-8")
            
        except Exception as e:
            print(f"‚ö† Error saving progress: {e}")


    def on_status_click(self, event):
        """Handle click on Status column to toggle completion."""
        region = self.plan_tree.identify("region", event.x, event.y)
        if region != "cell":
            return
        
        column = self.plan_tree.identify_column(event.x)
        row_id = self.plan_tree.identify_row(event.y)
        
        # Column #3 is Status (Session, Material, Status, Duration, Action)
        if column == "#3" and row_id:
            item = self.plan_tree.item(row_id)
            session_name = item['values'][0]
            
            self._toggle_completion_status(session_name, self.current_plan_name, row_id)

    def on_study_material_click(self, event):
        """Handle click on Study Material column."""
        region = self.plan_tree.identify("region", event.x, event.y)
        if region != "cell":
            return
        
        column = self.plan_tree.identify_column(event.x)
        row_id = self.plan_tree.identify_row(event.y)
        
        if column == "#2" and row_id:
            item = self.plan_tree.item(row_id)
            session_name = item['values'][0]
            duration_str = item['values'][4]
            
            try:
                hours, mins = map(int, duration_str.split(':'))
                duration_minutes = hours * 60 + mins
            except:
                duration_minutes = 60
            
            self.show_study_material_dialog(session_name, duration_minutes, row_id)


    def _clean_json_response(self, json_str):
        """Clean and validate AI-generated JSON."""
        try:
            # Remove markdown code blocks
            if "json" in json_str:
                json_str = json_str.split("json")[1].split("")[0].strip()
            elif "" in json_str:
                json_str = json_str.split("")[1].split("")[0].strip()
            
            # Remove trailing commas before } or ]
            import re
            json_str = re.sub(r',\s*}', '}', json_str)
            json_str = re.sub(r',\s*]', ']', json_str)
            
            # Try to parse
            parsed = json.loads(json_str)
            return json.dumps(parsed, ensure_ascii=False)
            
        except json.JSONDecodeError as e:
            print(f"‚ö† JSON Error at position {e.pos}: {e.msg}")
            print(f"üìÑ Problem area: {json_str[max(0, e.pos-50):min(len(json_str), e.pos+50)]}")
            
            # Try more aggressive cleanup
            try:
                # Remove all trailing commas
                json_str = re.sub(r',(\s*[}\]])', r'\1', json_str)
                # Remove comments if any
                json_str = re.sub(r'//.*?\n', '\n', json_str)
                json_str = re.sub(r'/\.?\*/', '', json_str, flags=re.DOTALL)
                
                parsed = json.loads(json_str)
                return json.dumps(parsed, ensure_ascii=False)
            except:
                raise Exception(f"Failed to parse JSON: {e.msg} at position {e.pos}")

    
    def show_study_material_dialog(self, session_name, duration_minutes, row_id):
        """Show study material with day-based progressive learning."""
        from config_paths import app_paths
        
        materials_file = Path(app_paths.appdata_dir) / "session_materials.json"
        
        # Calculate days until exam
        days_until_exam = self._get_days_until_exam()
        if not days_until_exam:
            messagebox.showwarning("Exam Date Missing", 
                                  "Please set your exam date first to use smart day-based learning!")
            return
        
        # ‚úÖ Get current day for THIS specific session
        current_day = self._get_session_current_day(session_name)
        
        # Get global day for display
        global_day = self._get_global_study_day()
        
        # ‚úÖ Check if we need to auto-generate skipped days
        self._check_and_generate_skipped_days(session_name, current_day, materials_file, days_until_exam)
        
        # Main dialog
        dialog = tk.Toplevel(self)
        dialog.title(f"üìö {session_name} - Day {current_day}")
        dialog.geometry("950x750")
        dialog.transient(self)
        dialog.grab_set()
        
        # Header
        header_frame = tk.Frame(dialog, bg="#2c3e50", height=100)
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)
        
        header_inner = tk.Frame(header_frame, bg="#2c3e50")
        header_inner.pack(expand=True)
        
        tk.Label(header_inner, 
                 text=f"üìö {session_name}",
                 font=("Segoe UI", 16, "bold"),
                 bg="#2c3e50", fg="white").pack()
        
        tk.Label(header_inner, 
                 text=f"üìÖ Session Day {current_day} | üåç Global Day {global_day} | ‚è± {duration_minutes} min | üéØ {days_until_exam} days until exam",
                 font=("Segoe UI", 10),
                 bg="#2c3e50", fg="#bdc3c7").pack()
        
        # Scrollable content area
        content_outer = tk.Frame(dialog, bg="#f8f9fa")
        content_outer.pack(fill="both", expand=True, padx=15, pady=15)
        
        canvas = tk.Canvas(content_outer, bg="#f8f9fa", highlightthickness=0)
        scrollbar = tk.Scrollbar(content_outer, orient="vertical", command=canvas.yview)
        
        scrollable_frame = tk.Frame(canvas, bg="#f8f9fa")
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=900)
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Mousewheel scrolling
        def on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind_all("<MouseWheel>", on_mousewheel)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Loading
        loading_frame = tk.Frame(scrollable_frame, bg="#f8f9fa")
        loading_frame.pack(fill="both", expand=True, pady=100)
        
        tk.Label(loading_frame, 
                 text=f"‚è≥ Preparing Day {current_day} content...",
                 font=("Segoe UI", 12, "bold"),
                 bg="#f8f9fa", fg="#7f8c8d").pack()
        
        # Buttons
        btn_frame = tk.Frame(dialog, bg="#f8f9fa")
        btn_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        close_btn = tk.Button(btn_frame, text="Close",
                             command=lambda: [canvas.unbind_all("<MouseWheel>"), dialog.destroy()],
                             font=("Segoe UI", 10), bg="#e74c3c", fg="white",
                             relief="flat", bd=0, padx=20, pady=8, cursor="hand2")
        close_btn.pack(side="right")
        
        # ‚úÖ Use session day in the key
        key = f"{self.current_plan_name}_{session_name}_sessionday{current_day}_{days_until_exam}daysRemaining"
        
        # Check existing material
        existing_material = None
        if materials_file.exists():
            try:
                materials = json.loads(materials_file.read_text(encoding="utf-8"))
                existing_material = materials.get(key)
            except:
                pass
        
        if existing_material:
            loading_frame.pack_forget()
            self._display_progressive_material(scrollable_frame, existing_material, 
                                              session_name, duration_minutes, 
                                              days_until_exam, current_day, dialog, canvas)
            return
        
        # Generate new material
        def generate_material():
            try:
                from openai import OpenAI
                from secrets_util import get_secret
                from token_tracker import chat_complete_with_tracking, InsufficientTokensError
                from token_manager import get_token_manager
                
                # Check quota first
                tm = get_token_manager()
                balance_info = tm.get_balance()
                if balance_info.get("balance", 0) <= 0:
                    def show_quota_error():
                        loading_frame.pack_forget()
                        error_frame = tk.Frame(scrollable_frame, bg="#fff3cd", relief="solid", bd=1)
                        error_frame.pack(fill="x", padx=10, pady=50)
                        
                        tk.Label(error_frame, 
                                text="‚ö†Ô∏è Insufficient Tokens",
                                font=("Segoe UI", 13, "bold"),
                                bg="#fff3cd", fg="#856404").pack(pady=(15, 5))
                        
                        tk.Label(error_frame,
                                text="You don't have enough tokens to generate study material.",
                                font=("Segoe UI", 10),
                                bg="#fff3cd", fg="#856404").pack(pady=5)
                        
                        tk.Button(error_frame,
                                 text="üí≥ Buy Tokens",
                                 command=lambda: [dialog.destroy(), 
                                                self.master.show_purchase_dialog() if hasattr(self.master, 'show_purchase_dialog') else None],
                                 font=("Segoe UI", 10, "bold"),
                                 bg="#4CAF50", fg="white",
                                 relief="flat", cursor="hand2",
                                 padx=20, pady=8).pack(pady=(5, 15))
                    
                    dialog.after(0, show_quota_error)
                    return
                
                client = OpenAI(api_key=get_secret("AI_API"))
                
                profile_file = Path(app_paths.appdata_dir) / "profile.json"
                if profile_file.exists():
                    profile = json.loads(profile_file.read_text(encoding="utf-8"))
                    exam_name = profile.get("exam_name", "exam")
                else:
                    exam_name = "exam"
                
                # Calculate content based on duration
                topics_count = max(5, min(12, duration_minutes // 10))
                
                prompt = (
                    f"You are creating a {days_until_exam}-day study plan for '{session_name}' ({exam_name}).\n"
                    f"Session duration: {duration_minutes} minutes per day\n"
                    f"Days until exam: {days_until_exam}\n"
                    f"Current session day: {current_day}\n\n"
                    f"Create {topics_count} topics. For each topic, break it into daily content for Day 1 to Day {min(days_until_exam, 10)}.\n\n"
                    f"IMPORTANT: Make content proportional to {duration_minutes} minutes:\n"
                    f"- More duration = more detailed content\n"
                    f"- Each day's content_brief should be 200-400 words\n"
                    f"- Include examples, formulas, key points\n\n"
                    "Return ONLY this JSON (no extra text, no trailing commas):\n\n"
                    "{\n"
                    '  "strategy": {\n'
                    '    "total_content_scope": "Brief overview",\n'
                    '    "why_these_topics": "Reasoning",\n'
                    '    "previous_year_analysis": "PYP insights",\n'
                    '    "expected_topics": "What to expect",\n'
                    '    "time_allocation": "How time is split"\n'
                    '  },\n'
                    '  "topics": [\n'
                    '    {\n'
                    '      "topic": "Topic name",\n'
                    '      "importance": "High",\n'
                    '      "exam_frequency": "Very High",\n'
                    '      "days_allocated": 3,\n'
                    '      "daily_breakdown": [\n'
                    '        {\n'
                    '          "day": 1,\n'
                    '          "focus": "What to focus on",\n'
                    '          "content_brief": "Detailed explanation with examples"\n'
                    '        }\n'
                    '      ]\n'
                    '    }\n'
                    '  ]\n'
                    "}\n\n"
                    "Remember: NO trailing commas, NO text outside JSON!"
                )
                
                print(f"üîÑ Generating material for {session_name} Session Day {current_day} ({duration_minutes} min)...")
                
                material = chat_complete_with_tracking(
                    client,
                    messages=[
                        {"role": "system", "content": "You create detailed study plans. Return only valid JSON."},
                        {"role": "user", "content": prompt}
                    ],
                    model="gpt-4o-mini",
                    temperature=0.7,
                    session_name=session_name,
                    purpose="material_generation"
                )
                
                print(f"‚úÖ Received response ({len(material)} chars)")
                
                # Clean JSON
                material = material.strip()
                if "```json" in material:
                    material = material.split("```json")[1].split("```")[0].strip()
                elif "```" in material:
                    material = material.split("```")[1].split("```")[0].strip()
                
                # Remove trailing commas (common AI mistake)
                import re
                material = re.sub(r',(\s*[}\]])', r'\1', material)
                
                # Test if valid JSON
                try:
                    json.loads(material)
                    print("‚úÖ Valid JSON")
                except json.JSONDecodeError as e:
                    print(f"‚ùå JSON Error: {e}")
                    # Save for debugging
                    error_file = Path(app_paths.appdata_dir) / "last_ai_response.txt"
                    error_file.write_text(material, encoding="utf-8")
                    raise Exception(f"Invalid JSON from AI. Saved to {error_file.name}")
                
                # Save with correct key
                materials_file.parent.mkdir(parents=True, exist_ok=True)
                if materials_file.exists():
                    materials = json.loads(materials_file.read_text(encoding="utf-8"))
                else:
                    materials = {}
                
                materials[key] = material
                materials_file.write_text(json.dumps(materials, indent=2, ensure_ascii=False), encoding="utf-8")
                
                print(f"üíæ Saved material for {session_name} Session Day {current_day}")
                
                def update_ui():
                    loading_frame.pack_forget()
                    self._display_progressive_material(scrollable_frame, material,
                                                      session_name, duration_minutes,
                                                      days_until_exam, current_day, dialog, canvas)
                    
                    item = self.plan_tree.item(row_id)
                    values = list(item['values'])
                    values[1] = "‚úÖ View"
                    self.plan_tree.item(row_id, values=values)
                    
                    if hasattr(self, 'master') and hasattr(self.master, 'refresh_token_usage_display'):
                        self.master.refresh_token_usage_display()
                
                dialog.after(0, update_ui)
                
            except InsufficientTokensError as e:
                def show_insufficient_error():
                    loading_frame.pack_forget()
                    error_frame = tk.Frame(scrollable_frame, bg="#ffebee", relief="solid", bd=1)
                    error_frame.pack(fill="x", padx=10, pady=50)
                    
                    tk.Label(error_frame, 
                            text="‚ö†Ô∏è Token Limit Reached",
                            font=("Segoe UI", 13, "bold"),
                            bg="#ffebee", fg="#c62828").pack(pady=(15, 5))
                    
                    tk.Label(error_frame,
                            text=str(e),
                            font=("Segoe UI", 10),
                            bg="#ffebee", fg="#c62828",
                            wraplength=800).pack(pady=5)
                    
                    tk.Button(error_frame,
                             text="üí≥ Buy More Tokens",
                             command=lambda: [dialog.destroy(), 
                                            self.master.show_purchase_dialog() if hasattr(self.master, 'show_purchase_dialog') else None],
                             font=("Segoe UI", 10, "bold"),
                             bg="#4CAF50", fg="white",
                             relief="flat", cursor="hand2",
                             padx=20, pady=8).pack(pady=(5, 15))
                
                dialog.after(0, show_insufficient_error)
            except Exception as e:
                def show_error():
                    for w in loading_frame.winfo_children():
                        w.destroy()
                    tk.Label(loading_frame, text=f"‚ùå Error: {str(e)[:100]}",
                            font=("Segoe UI", 11), bg="#f8f9fa", fg="#e74c3c",
                            wraplength=800).pack()
                dialog.after(0, show_error)
                import traceback
                traceback.print_exc()

        import threading
        threading.Thread(target=generate_material, daemon=True).start()

    def _check_and_generate_skipped_days(self, session_name, current_session_day, materials_file, days_until_exam):
        """Check if any session days were skipped and auto-generate their structure."""
        if current_session_day <= 1:
            return  # First day, nothing to check
        
        # Check which days already have generated material
        existing_days = set()
        if materials_file.exists():
            try:
                materials = json.loads(materials_file.read_text(encoding="utf-8"))
                # Find all keys for this session
                for key in materials.keys():
                    if f"{self.current_plan_name}_{session_name}_sessionday" in key:
                        # Extract day number from key
                        import re
                        match = re.search(r'_sessionday(\d+)_', key)
                        if match:
                            existing_days.add(int(match.group(1)))
            except:
                pass
        
        # Find missing days (1 to current_session_day-1)
        missing_days = []
        for day in range(1, current_session_day):
            if day not in existing_days:
                missing_days.append(day)
        
        if not missing_days:
            return  # No missing days
        
        print(f"üîÑ Found {len(missing_days)} skipped session days for {session_name}: {missing_days}")
        
        # Auto-generate structure for missing days
        self._generate_lightweight_structure_for_days(
            session_name, 
            missing_days, 
            materials_file, 
            days_until_exam
        )

    def _generate_lightweight_structure_for_days(self, session_name, missing_days, materials_file, days_until_exam):
        """Generate lightweight structure for skipped days (topics + focus only, no deep content)."""
        from config_paths import app_paths
        
        try:
            from openai import OpenAI
            from secrets_util import get_secret
            from token_tracker import chat_complete_with_tracking
            
            client = OpenAI(api_key=get_secret("AI_API"))
            
            profile_file = Path(app_paths.appdata_dir) / "profile.json"
            if profile_file.exists():
                profile = json.loads(profile_file.read_text(encoding="utf-8"))
                exam_name = profile.get("exam_name", "exam")
            else:
                exam_name = "exam"
            
            # Calculate topics count
            topics_count = max(5, min(12, 60 // 10))  # Assume 60 min default
            
            # Generate structure for ALL missing days in ONE API call
            prompt = (
                f"Create a {days_until_exam}-day study plan structure for '{session_name}' ({exam_name}).\n"
                f"Days until exam: {days_until_exam}\n\n"
                f"Create {topics_count} topics with daily breakdown for Day 1 to Day {min(days_until_exam, 10)}.\n\n"
                f"IMPORTANT: This is LIGHTWEIGHT - just topic names and brief focus points:\n"
                f"- Each topic needs a name, importance level, and exam_frequency\n"
                f"- For daily_breakdown: just day number and a SHORT focus (1 sentence)\n"
                f"- NO detailed content_brief needed (keep it under 50 words)\n\n"
                "Return ONLY this JSON:\n\n"
                "{\n"
                '  "strategy": {\n'
                '    "total_content_scope": "Brief overview",\n'
                '    "why_these_topics": "Reasoning",\n'
                '    "previous_year_analysis": "PYP insights",\n'
                '    "expected_topics": "What to expect",\n'
                '    "time_allocation": "How time is split"\n'
                '  },\n'
                '  "topics": [\n'
                '    {\n'
                '      "topic": "Topic name",\n'
                '      "importance": "High",\n'
                '      "exam_frequency": "Very High",\n'
                '      "days_allocated": 3,\n'
                '      "daily_breakdown": [\n'
                '        {\n'
                '          "day": 1,\n'
                '          "focus": "Brief focus point (1 sentence)",\n'
                '          "content_brief": "Short intro (under 50 words)"\n'
                '        }\n'
                '      ]\n'
                '    }\n'
                '  ]\n'
                "}\n\n"
                "Remember: LIGHTWEIGHT! Short focus points only!"
            )
            
            print(f"üîÑ Generating lightweight structure for days {missing_days}...")
            
            material = chat_complete_with_tracking(
                client,
                messages=[
                    {"role": "system", "content": "You create study plan structures. Keep it lightweight - brief focus points only."},
                    {"role": "user", "content": prompt}
                ],
                model="gpt-4o-mini",
                temperature=0.7,
                session_name=f"{session_name}_structure",
                purpose="structure_generation"
            )
            
            # Clean JSON
            material = material.strip()
            if "```json" in material:
                material = material.split("```json")[1].split("```")[0].strip()
            elif "```" in material:
                material = material.split("```")[1].split("```")[0].strip()
            
            import re
            material = re.sub(r',(\s*[}\]])', r'\1', material)
            
            # Validate
            json.loads(material)
            
            # Save structure for each missing day
            materials_file.parent.mkdir(parents=True, exist_ok=True)
            if materials_file.exists():
                materials = json.loads(materials_file.read_text(encoding="utf-8"))
            else:
                materials = {}
            
            for day in missing_days:
                key = f"{self.current_plan_name}_{session_name}_day{day}_{days_until_exam}daysRemaining"
                materials[key] = material
            
            materials_file.write_text(json.dumps(materials, indent=2, ensure_ascii=False), encoding="utf-8")
            
            print(f"‚úÖ Generated structure for {len(missing_days)} skipped days")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to auto-generate skipped days: {e}")
            # Not critical - user can still use the app


    def _display_progressive_material(self, parent_frame, material_json, session_name, 
                              duration_minutes, days_until_exam, current_day, dialog, canvas):
        """Display day-by-day material with status tabs for previous days."""
        
        try:
            material_data = json.loads(material_json)
        except Exception as e:
            tk.Label(parent_frame, text=f"Error: {e}", bg="#f8f9fa", fg="#e74c3c").pack()
            return
        
        strategy = material_data.get("strategy", {})
        topics = material_data.get("topics", [])
        
        # Strategy section
        strat_frame = tk.Frame(parent_frame, bg="white", relief="solid", bd=1)
        strat_frame.pack(fill="x", padx=10, pady=(10, 15))
        
        tk.Label(strat_frame, text="üéØ Learning Strategy",
                 font=("Segoe UI", 13, "bold"), bg="white", fg="#2c3e50").pack(anchor="w", padx=15, pady=(12, 8))
        
        strat_text = (
            f"üìä Scope: {strategy.get('total_content_scope', 'Full coverage')}\n\n"
            f"üéØ Why These: {strategy.get('why_these_topics', f'{days_until_exam} days optimized')}\n\n"
            f"üìà Previous Year: {strategy.get('previous_year_analysis', 'Based on patterns')}\n\n"
            f"üîÆ Expected: {strategy.get('expected_topics', 'High priority')}\n\n"
            f"‚è∞ Distribution: {strategy.get('time_allocation', f'{duration_minutes} min daily')}"
        )
        
        tk.Label(strat_frame, text=strat_text, font=("Segoe UI", 9),
                bg="#f8f9fa", fg="#2c3e50", justify="left", wraplength=820).pack(fill="x", padx=15, pady=10)
        
        # ========== CURRENT DAY ==========
        curr_frame = tk.Frame(parent_frame, bg="white", relief="solid", bd=2,
                             highlightbackground="#27ae60", highlightthickness=2)
        curr_frame.pack(fill="both", expand=True, padx=10, pady=(0, 15))
        
        tk.Label(curr_frame, text=f"üìÖ TODAY - Day {current_day}",
                font=("Segoe UI", 14, "bold"), bg="#27ae60", fg="white").pack(fill="x", pady=(0, 10))
        
        # Find today's content
        day_content = []
        for topic in topics:
            for day_info in topic.get("daily_breakdown", []):
                if day_info.get("day") == current_day:
                    day_content.append({
                        "topic": topic.get("topic"),
                        "importance": topic.get("importance"),
                        "frequency": topic.get("exam_frequency"),
                        "focus": day_info.get("focus"),
                        "content_brief": day_info.get("content_brief")
                    })
        
        if not day_content:
            tk.Label(curr_frame, text="üéâ Rest day!", font=("Segoe UI", 11),
                    bg="white", fg="#95a5a6").pack(pady=50)
        else:
            table = tk.Frame(curr_frame, bg="white")
            table.pack(fill="both", expand=True, padx=15, pady=(0, 15))
            
            # Header
            hdr = tk.Frame(table, bg="#34495e", height=40)
            hdr.pack(fill="x")
            hdr.pack_propagate(False)
            
            tk.Label(hdr, text="Topic", font=("Segoe UI", 10, "bold"),
                    bg="#34495e", fg="white", width=20, anchor="w").pack(side="left", padx=10)
            tk.Label(hdr, text="Focus", font=("Segoe UI", 10, "bold"),
                    bg="#34495e", fg="white", width=25, anchor="w").pack(side="left", padx=5)
            tk.Label(hdr, text="Priority", font=("Segoe UI", 10, "bold"),
                    bg="#34495e", fg="white", width=10).pack(side="left", padx=5)
            tk.Label(hdr, text="Status", font=("Segoe UI", 10, "bold"),  # üÜï ADD THIS
                    bg="#34495e", fg="white", width=10).pack(side="left", padx=5)  # üÜï ADD THIS
            tk.Label(hdr, text="Action", font=("Segoe UI", 10, "bold"),
                    bg="#34495e", fg="white", width=12).pack(side="left", padx=5)
            
            # Rows
            for i, item in enumerate(day_content):
                row_bg = "#e8f8f5" if i % 2 == 0 else "white"
                row = tk.Frame(table, bg=row_bg, height=60)
                row.pack(fill="x", pady=1)
                row.pack_propagate(False)
                
                tk.Label(row, text=item["topic"], font=("Segoe UI", 9, "bold"),
                        bg=row_bg, fg="#2c3e50", width=20, anchor="w", wraplength=150).pack(side="left", padx=10)
                
                tk.Label(row, text=item["focus"], font=("Segoe UI", 9),
                        bg=row_bg, fg="#7f8c8d", width=25, anchor="w", wraplength=180).pack(side="left", padx=5)
                
                imp_color = {"High": "#27ae60", "Medium": "#f39c12", "Low": "#95a5a6"}.get(item["importance"], "#7f8c8d")
                tk.Label(row, text=item["importance"], font=("Segoe UI", 9, "bold"),
                        bg=row_bg, fg=imp_color, width=10).pack(side="left", padx=5)

                # üÜï ADD STATUS COLUMN WITH TOGGLE
                topic_name = item["topic"]
                status = self._get_topic_completion_status(session_name, topic_name, current_day)
                status_text = "‚úÖ" if status == "complete" else "‚è≥"
                status_color = "#27ae60" if status == "complete" else "#f39c12"

                status_btn = tk.Button(row, text=status_text, font=("Segoe UI", 12, "bold"),
                                      bg=row_bg, fg=status_color, relief="flat", bd=0, cursor="hand2",
                                      command=lambda t=topic_name, d=current_day: self._toggle_topic_status(session_name, t, d, dialog, canvas))
                status_btn.pack(side="left", padx=5, ipadx=8)

                tk.Button(row, text="üîç Deep Dive", font=("Segoe UI", 8, "bold"),
                         bg="#16a085", fg="white", relief="flat", bd=0, cursor="hand2",
                         command=lambda t=item["topic"], c=item["content_brief"]: 
                             self._show_deep_dive_progressive(t, c, duration_minutes, current_day, session_name, dialog, canvas)
                        ).pack(side="left", padx=5)
        
        # ========== PREVIOUS DAYS WITH STATUS TABS ==========
        if current_day > 1:
            from config_paths import app_paths
            
            prev_frame = tk.Frame(parent_frame, bg="white", relief="solid", bd=1)
            prev_frame.pack(fill="x", padx=10, pady=(0, 10))
            
            prev_header = tk.Frame(prev_frame, bg="#ecf0f1", cursor="hand2")
            prev_header.pack(fill="x")
            
            prev_expanded = tk.BooleanVar(value=False)
            arrow = tk.Label(prev_header, text="‚ñ∂", font=("Segoe UI", 12), bg="#ecf0f1", fg="#2c3e50")
            arrow.pack(side="left", padx=10, pady=8)
            
            tk.Label(prev_header, text=f"üìú Previous Days (1-{current_day-1})",
                    font=("Segoe UI", 11, "bold"), bg="#ecf0f1", fg="#2c3e50").pack(side="left", pady=8)
            
            prev_content = tk.Frame(prev_frame, bg="white")
            
            # ‚úÖ GET COMPLETED DAYS DATA HERE (OUTSIDE toggle function)
            progress_file = Path(app_paths.appdata_dir) / "study_progress.json"
            completed_days = []
            if progress_file.exists():
                try:
                    progress_data = json.loads(progress_file.read_text(encoding="utf-8"))
                    session_key = f"{self.current_plan_name}_{session_name}"
                    completed_days = progress_data.get(session_key, {}).get("completed_days", [])
                except:
                    pass
            
            def toggle():
                if prev_expanded.get():
                    prev_content.pack_forget()
                    arrow.config(text="‚ñ∂")
                    prev_expanded.set(False)
                else:
                    prev_content.pack(fill="x", padx=15, pady=10)
                    arrow.config(text="‚ñº")
                    prev_expanded.set(True)
                    
                    # Clear previous content
                    for w in prev_content.winfo_children():
                        w.destroy()
                    
                    # Status tabs
                    tab_frame = tk.Frame(prev_content, bg="white")
                    tab_frame.pack(fill="x", pady=(0, 10))
                    
                    selected_tab = tk.StringVar(value="all")
                    
                    def show_filtered_days(filter_type):
                        selected_tab.set(filter_type)
                        
                        # Update button styles
                        all_btn.config(bg="#3498db" if filter_type == "all" else "#95a5a6")
                        complete_btn.config(bg="#27ae60" if filter_type == "complete" else "#95a5a6")
                        pending_btn.config(bg="#f39c12" if filter_type == "pending" else "#95a5a6")
                        
                        # Clear days content
                        for w in days_container.winfo_children():
                            w.destroy()
                        
                        # Load topic completion status
                        status_file = Path(app_paths.appdata_dir) / "topic_completion.json"
                        topic_statuses = {}
                        if status_file.exists():
                            try:
                                topic_statuses = json.loads(status_file.read_text(encoding="utf-8"))
                            except:
                                pass
                        
                        # Show filtered days
                        for day_num in range(1, current_day):
                            # Calculate day-level summary
                            day_topics = []
                            complete_count = 0
                            pending_count = 0

                            for topic in topics:
                                for day_info in topic.get("daily_breakdown", []):
                                    if day_info.get("day") == day_num:
                                        topic_name = topic.get("topic")
                                        topic_key = f"{self.current_plan_name}_{session_name}_{topic_name}_day{day_num}"
                                        topic_status = topic_statuses.get(topic_key, "pending")
                                        
                                        day_topics.append(topic_name)
                                        if topic_status == "complete":
                                            complete_count += 1
                                        else:
                                            pending_count += 1

                            # ‚úÖ FIX: Only skip if day has NO topics matching the filter
                            if filter_type == "complete":
                                if complete_count == 0:  # Skip if NO complete topics
                                    continue
                            elif filter_type == "pending":
                                if pending_count == 0:  # Skip if NO pending topics
                                    continue
                            # "all" shows everything

                            # Determine day summary status
                            if pending_count == 0:
                                status_emoji = "‚úÖ"
                                status_text = f"Complete ({complete_count}/{len(day_topics)})"
                                status_color = "#27ae60"
                            elif complete_count == 0:
                                status_emoji = "‚è≥"
                                status_text = f"Pending ({pending_count}/{len(day_topics)})"
                                status_color = "#f39c12"
                            else:
                                status_emoji = "üîÑ"
                                status_text = f"In Progress ({complete_count}/{len(day_topics)} done)"
                                status_color = "#3498db"

                            day_frame = tk.Frame(days_container, bg="#f8f9fa", relief="solid", bd=1)
                            day_frame.pack(fill="x", pady=5)

                            # Day header
                            day_hdr = tk.Frame(day_frame, bg="#95a5a6")
                            day_hdr.pack(fill="x")

                            tk.Label(day_hdr, text=f"{status_emoji} Day {day_num}",
                                    font=("Segoe UI", 10, "bold"), bg="#95a5a6", fg="white").pack(side="left", padx=15, pady=8)

                            tk.Label(day_hdr, text=status_text,
                                    font=("Segoe UI", 9, "bold"), bg="#95a5a6", fg=status_color).pack(side="left", padx=5)
                            
                            # Find content for this day - FILTER BY TOPIC STATUS
                            past_day_content = []
                            for topic in topics:
                                for day_info in topic.get("daily_breakdown", []):
                                    if day_info.get("day") == day_num:
                                        topic_name = topic.get("topic")
                                        
                                        # Check individual topic completion status
                                        topic_key = f"{self.current_plan_name}_{session_name}_{topic_name}_day{day_num}"
                                        topic_status = topic_statuses.get(topic_key, "pending")
                                        
                                        # ‚úÖ FIX: Filter by topic status ONLY for filtered tabs
                                        if filter_type == "complete" and topic_status != "complete":
                                            continue  # Skip pending topics when showing complete
                                        if filter_type == "pending" and topic_status == "complete":
                                            continue  # Skip complete topics when showing pending
                                        
                                        past_day_content.append({
                                            "topic": topic_name,
                                            "importance": topic.get("importance"),
                                            "focus": day_info.get("focus"),
                                            "content_brief": day_info.get("content_brief"),
                                            "status": topic_status  # ‚úÖ ADD STATUS
                                        })
                            
                            if past_day_content:
                                day_table = tk.Frame(day_frame, bg="white")
                                day_table.pack(fill="x", padx=10, pady=10)
                                
                                # Mini header
                                mini_hdr = tk.Frame(day_table, bg="#7f8c8d", height=30)
                                mini_hdr.pack(fill="x")
                                mini_hdr.pack_propagate(False)
                                
                                tk.Label(mini_hdr, text="Topic", font=("Segoe UI", 9, "bold"),
                                        bg="#7f8c8d", fg="white", width=18, anchor="w").pack(side="left", padx=8)
                                tk.Label(mini_hdr, text="Focus", font=("Segoe UI", 9, "bold"),
                                        bg="#7f8c8d", fg="white", width=30, anchor="w").pack(side="left", padx=5)
                                tk.Label(mini_hdr, text="Priority", font=("Segoe UI", 9, "bold"),
                                        bg="#7f8c8d", fg="white", width=10).pack(side="left", padx=5)
                                tk.Label(mini_hdr, text="Status", font=("Segoe UI", 9, "bold"),
                                        bg="#7f8c8d", fg="white", width=8).pack(side="left", padx=5)
                                tk.Label(mini_hdr, text="Action", font=("Segoe UI", 9, "bold"),
                                        bg="#7f8c8d", fg="white", width=10).pack(side="left", padx=5)
                                
                                # Content rows
                                for j, item in enumerate(past_day_content):
                                    row_bg = "#f0f0f0" if j % 2 == 0 else "white"
                                    row = tk.Frame(day_table, bg=row_bg, height=50)
                                    row.pack(fill="x", pady=1)
                                    row.pack_propagate(False)
                                    
                                    tk.Label(row, text=item["topic"], font=("Segoe UI", 8, "bold"),
                                            bg=row_bg, fg="#2c3e50", width=18, anchor="w", wraplength=130).pack(side="left", padx=8)
                                    
                                    tk.Label(row, text=item["focus"], font=("Segoe UI", 8),
                                            bg=row_bg, fg="#7f8c8d", width=30, anchor="w", wraplength=200).pack(side="left", padx=5)
                                    
                                    imp_color = {"High": "#27ae60", "Medium": "#f39c12", "Low": "#95a5a6"}.get(item["importance"], "#7f8c8d")
                                    tk.Label(row, text=item["importance"], font=("Segoe UI", 8, "bold"),
                                            bg=row_bg, fg=imp_color, width=10).pack(side="left", padx=5)

                                    # Status display
                                    past_topic = item["topic"]
                                    past_status = item["status"]  # ‚úÖ Use from dict
                                    past_status_text = "‚úÖ" if past_status == "complete" else "‚è≥"
                                    past_status_color = "#27ae60" if past_status == "complete" else "#f39c12"

                                    tk.Label(row, text=past_status_text, font=("Segoe UI", 10, "bold"),
                                            bg=row_bg, fg=past_status_color, width=8).pack(side="left", padx=5)

                                    tk.Button(row, text="üîç View", font=("Segoe UI", 7, "bold"),
                                             bg="#95a5a6", fg="white", relief="flat", bd=0, cursor="hand2",
                                             command=lambda t=item["topic"], c=item["content_brief"], d=day_num: 
                                                 self._show_deep_dive_progressive(t, c, duration_minutes, d, session_name, dialog, canvas)
                                            ).pack(side="left", padx=5)
                            else:
                                tk.Label(day_frame, text="No content matching filter",
                                        font=("Segoe UI", 9), bg="white", fg="#7f8c8d").pack(pady=10)
                        
                        parent_frame.update_idletasks()
                        canvas.configure(scrollregion=canvas.bbox("all"))
                    
                    # Tab buttons
                    all_btn = tk.Button(tab_frame, text="üìä All Days", font=("Segoe UI", 9, "bold"),
                                       bg="#3498db", fg="white", relief="flat", bd=0, padx=15, pady=6, cursor="hand2",
                                       command=lambda: show_filtered_days("all"))
                    all_btn.pack(side="left", padx=5)
                    
                    complete_btn = tk.Button(tab_frame, text="‚úÖ Complete", font=("Segoe UI", 9, "bold"),
                                            bg="#95a5a6", fg="white", relief="flat", bd=0, padx=15, pady=6, cursor="hand2",
                                            command=lambda: show_filtered_days("complete"))
                    complete_btn.pack(side="left", padx=5)
                    
                    pending_btn = tk.Button(tab_frame, text="‚è≥ Pending", font=("Segoe UI", 9, "bold"),
                                           bg="#95a5a6", fg="white", relief="flat", bd=0, padx=15, pady=6, cursor="hand2",
                                           command=lambda: show_filtered_days("pending"))
                    pending_btn.pack(side="left", padx=5)
                    
                    # Days container
                    days_container = tk.Frame(prev_content, bg="white")
                    days_container.pack(fill="x")
                    
                    # Show all days initially
                    show_filtered_days("all")
            
            prev_header.bind("<Button-1>", lambda e: toggle())
            arrow.bind("<Button-1>", lambda e: toggle())
        
        parent_frame.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))

    def _show_deep_dive_progressive(self, topic_name, content_brief, duration_minutes, 
                    current_day, session_name, parent_dialog, parent_canvas):
        """Show deep dive content with capsule-style tabs and independent section loading."""
        from config_paths import app_paths
        import os
        from PIL import Image, ImageDraw, ImageFont, ImageTk
        import tkinter as tk
        from tkinter import messagebox
        from pathlib import Path
        import json
        from datetime import datetime
        
        # ================= Capsule Section Definitions =================
        CAPSULE_SECTIONS = [
            {"id": "objectives", "emoji": "üéØ", "title": "Exam Objectives", "short": "Objectives"},
            {"id": "concepts", "emoji": "üìñ", "title": "Core Concepts", "short": "Concepts"},
            {"id": "formulas", "emoji": "üìù", "title": "Key Formulas", "short": "Formulas"},
            {"id": "practice", "emoji": "üìö", "title": "Practice Problems", "short": "Practice"},
            {"id": "strategy", "emoji": "üí°", "title": "Exam Strategy", "short": "Strategy"},
            {"id": "materials", "emoji": "üìë", "title": "Study Materials", "short": "Materials"},
            {"id": "preview", "emoji": "üîÆ", "title": "Tomorrow's Preview", "short": "Preview"}
        ]
        
        # ================= Emoji helpers =================
        def _pick_emoji_font(size: int):
            font_paths = [
                r"C:\Windows\Fonts\seguiemj.ttf",
                "/System/Library/Fonts/Apple Color Emoji.ttc",
                "/usr/share/fonts/truetype/noto/NotoColorEmoji.ttf",
            ]
            for p in font_paths:
                if os.path.exists(p):
                    try:
                        return ImageFont.truetype(p, size)
                    except Exception:
                        continue
            return None
        
        def render_emoji_photoimage(emoji_text: str, size: int = 20) -> ImageTk.PhotoImage:
            pad_x = int(size * 0.25)
            pad_y = int(size * 0.35)
            img = Image.new("RGBA", (size + pad_x, size + pad_y), (255, 255, 255, 0))
            draw = ImageDraw.Draw(img)
            font = _pick_emoji_font(int(size * 0.95)) or ImageFont.load_default()
            draw.text((pad_x // 2, pad_y // 4), emoji_text, font=font, embedded_color=True)
            return ImageTk.PhotoImage(img)
        
        def _iter_emoji_spans(text: str):
            try:
                import emoji
                try:
                    pattern = emoji.regex().get_emoji_regexp()
                except Exception:
                    pattern = emoji.get_emoji_regexp()
                for m in pattern.finditer(text):
                    yield m.start(), m.end(), m.group(0)
            except Exception:
                for i, ch in enumerate(text):
                    if ord(ch) >= 0x1F300:
                        yield i, i + 1, ch
        
        def insert_with_emojis(text_widget, text: str, image_cache: list, size_override=None):
            """Insert text with emoji support, bold formatting, and clickable links."""
            import re
            
            idx = 0
            emoji_spans = list(_iter_emoji_spans(text))
            
            pos = 0
            while pos < len(text):
                emoji_found = False
                for em_start, em_end, emo in emoji_spans:
                    if pos == em_start:
                        if pos > idx:
                            segment = text[idx:pos]
                            _insert_with_bold(text_widget, segment)
                        
                        img = render_emoji_photoimage(emo, size=size_override or 20)
                        image_cache.append(img)
                        text_widget.image_create("end", image=img)
                        
                        idx = em_end
                        pos = em_end
                        emoji_found = True
                        break
                
                if not emoji_found:
                    pos += 1
            
            if idx < len(text):
                segment = text[idx:]
                _insert_with_bold(text_widget, segment)
        
        def _insert_with_bold(text_widget, text: str):
            """Insert text segment with bold formatting for headings and clickable links."""
            import re
            import webbrowser

            lines = text.split('\n')
            for i, line in enumerate(lines):
                if i > 0:
                    text_widget.insert("end", '\n')

                stripped = line.strip()

                # === HEADLINE DETECTION ===
                if re.match(r'^[\W_]*[\U0001F300-\U0001F9FF].{3,}$', stripped):
                    _insert_line_with_links(text_widget, line, "bold")
                    continue

                if re.match(r'^\s*(#+|[*_]{2}).+', stripped):
                    cleaned = re.sub(r'^\s*#+\s*', '', stripped)
                    cleaned = re.sub(r'\*\*(.+?)\*\*', r'\1', cleaned)
                    cleaned = re.sub(r'__(.+?)__', r'\1', cleaned)
                    _insert_line_with_links(text_widget, cleaned.strip(), "bold")
                    continue

                if len(stripped) < 60 and stripped.endswith(':'):
                    _insert_line_with_links(text_widget, line, "bold")
                    continue

                if stripped.isupper() and len(stripped.split()) > 1:
                    _insert_line_with_links(text_widget, line, "bold")
                    continue

                bold_pattern = re.compile(r'\*\*(.+?)\*\*|__(.+?)__')
                matches = list(bold_pattern.finditer(line))
                if matches:
                    last_end = 0
                    for match in matches:
                        if match.start() > last_end:
                            _insert_line_with_links(text_widget, line[last_end:match.start()])
                        bold_text = match.group(1) or match.group(2)
                        _insert_line_with_links(text_widget, bold_text, "bold")
                        last_end = match.end()
                    if last_end < len(line):
                        _insert_line_with_links(text_widget, line[last_end:])
                else:
                    _insert_line_with_links(text_widget, line)
        
        def _insert_line_with_links(text_widget, text: str, tag=None):
            """Insert text with clickable hyperlinks."""
            import re
            import webbrowser
            
            url_pattern = re.compile(r'https?://[^\s]+')
            
            last_pos = 0
            for match in url_pattern.finditer(text):
                # Insert text before URL
                if match.start() > last_pos:
                    if tag:
                        text_widget.insert("end", text[last_pos:match.start()], tag)
                    else:
                        text_widget.insert("end", text[last_pos:match.start()])
                
                # Insert URL as clickable link
                url = match.group(0)
                link_tag = f"link_{text_widget.index('end')}"
                text_widget.insert("end", url, (link_tag, "link"))
                text_widget.tag_config(link_tag, foreground="#0066cc", underline=True)
                text_widget.tag_bind(link_tag, "<Button-1>", lambda e, u=url: webbrowser.open(u))
                text_widget.tag_bind(link_tag, "<Enter>", lambda e: text_widget.config(cursor="hand2"))
                text_widget.tag_bind(link_tag, "<Leave>", lambda e: text_widget.config(cursor=""))
                
                last_pos = match.end()
            
            # Insert remaining text
            if last_pos < len(text):
                if tag:
                    text_widget.insert("end", text[last_pos:], tag)
                else:
                    text_widget.insert("end", text[last_pos:])
        
        # ================= Storage Setup =================
        deep_dive_file = Path(app_paths.appdata_dir) / "deep_dive_content.json"
        dive_key_prefix = f"{self.current_plan_name}_{session_name}_{topic_name}_day{current_day}"
        
        # ================= Main Window =================
        dive = tk.Toplevel(parent_dialog)
        dive.title(f"üîç Day {current_day}: {topic_name}")
        dive.geometry("1100x750")
        dive.transient(parent_dialog)
        dive.grab_set()
        
        # State management
        active_capsule = {"id": None}
        capsule_contents = {}
        capsule_emoji_images = {}
        capsule_buttons = {}
        
        for section in CAPSULE_SECTIONS:
            capsule_contents[section["id"]] = {
                "text": "",
                "loaded": False,
                "loading_more": False
            }
            capsule_emoji_images[section["id"]] = []
        
        # ========== HEADER WITH TELEGRAM BUTTON ==========
        hdr = tk.Frame(dive, bg="#16a085")
        hdr.pack(fill="x")

        hdr_container = tk.Frame(hdr, bg="#16a085")
        hdr_container.pack(fill="x", padx=20, pady=15)

        title_frame = tk.Frame(hdr_container, bg="#16a085")
        title_frame.pack(side="left", fill="both", expand=True)

        tk.Label(title_frame, text=f"üîç Day {current_day} Deep Dive",
                font=("Segoe UI", 14, "bold"), bg="#16a085", fg="white").pack(anchor="w")
        tk.Label(title_frame, text=topic_name,
                font=("Segoe UI", 11), bg="#16a085", fg="#ecf0f1").pack(anchor="w")
        tk.Label(title_frame, text=f"Focus: {content_brief[:60]}..." if len(content_brief) > 60 else f"Focus: {content_brief}",
                font=("Segoe UI", 9), bg="#16a085", fg="#bdc3c7").pack(anchor="w")
        
        def send_to_telegram():
            """Send all capsule contents to Telegram as single HTML."""
            try:
                from secrets_util import get_secret
                
                bot_token = get_secret("TELEGRAM_BOT_TOKEN")
                if not bot_token:
                    messagebox.showerror("Error", "TELEGRAM_BOT_TOKEN not found in secrets!")
                    return
                
                profile_file = Path(app_paths.appdata_dir) / "profile.json"
                if profile_file.exists():
                    profile = json.loads(profile_file.read_text(encoding="utf-8"))
                    chat_id = profile.get("telegram_chat_id", "")
                else:
                    chat_id = ""
                
                if not chat_id:
                    messagebox.showerror("Error", "telegram_chat_id not found in profile.json!")
                    return
                
                # Collect all loaded capsule contents
                all_content = ""
                for section in CAPSULE_SECTIONS:
                    capsule_id = section["id"]
                    if capsule_contents[capsule_id]["loaded"]:
                        all_content += f"\n\n{'='*80}\n"
                        all_content += f"{section['emoji']} {section['title'].upper()}\n"
                        all_content += f"{'='*80}\n\n"
                        all_content += capsule_contents[capsule_id]["text"]
                
                if not all_content:
                    messagebox.showwarning("Warning", "No content loaded yet. Please wait for sections to load.")
                    return
                
                # Process content for HTML
                def format_for_html(text):
                    import re
                    lines = text.split('\n')
                    formatted_lines = []
                    
                    for line in lines:
                        stripped = line.strip()
                        
                        if stripped.startswith('‚Ä¢'):
                            line = line.replace('‚Ä¢', '&bull;', 1)
                        elif stripped.startswith('*') and not stripped.startswith('**'):
                            line = line.replace('*', '&bull;', 1)
                        elif stripped.startswith('-') and len(stripped) > 1 and stripped[1] == ' ':
                            line = line.replace('-', '&bull;', 1)
                        
                        line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', line)
                        line = re.sub(r'__(.+?)__', r'<strong>\1</strong>', line)
                        
                        if re.match(r'^\s*#{1,6}\s+', stripped):
                            line = re.sub(r'^\s*#{1,6}\s+', '<strong>', line) + '</strong>'
                        
                        if re.match(r'^[\U0001F300-\U0001F9FF]', stripped):
                            if '<strong>' not in line:
                                line = '<strong>' + line + '</strong>'
                        
                        if len(stripped) < 60 and stripped.endswith(':') and '<strong>' not in line:
                            line = '<strong>' + line + '</strong>'
                        
                        formatted_lines.append(line)
                    
                    return '\n'.join(formatted_lines)
                
                formatted_content = format_for_html(all_content)
                
                html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Deep Dive: {topic_name}</title>
        <style>
            body {{
                font-family: 'Segoe UI', Arial, sans-serif;
                max-width: 800px;
                margin: 40px auto;
                padding: 20px;
                background: #f8f9fa;
                color: #333;
                line-height: 1.8;
            }}
            h1 {{
                color: #16a085;
                border-bottom: 3px solid #16a085;
                padding-bottom: 10px;
            }}
            .header-info {{
                background: #e8f8f5;
                padding: 15px;
                border-radius: 8px;
                margin: 20px 0;
                border-left: 4px solid #16a085;
            }}
            .content {{
                background: white;
                padding: 25px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                white-space: pre-wrap;
                word-wrap: break-word;
            }}
            .content strong {{
                color: #2c3e50;
                font-weight: bold;
            }}
            .footer {{
                color: #999;
                font-size: 12px;
                margin-top: 30px;
                text-align: center;
            }}
        </style>
    </head>
    <body>
        <h1>üîç Day {current_day} Deep Dive</h1>
        
        <div class="header-info">
            <strong>üìö Topic:</strong> {topic_name}<br>
            <strong>üìñ Session:</strong> {session_name}<br>
            <strong>üéØ Focus:</strong> {content_brief}<br>
            <strong>‚è± Duration:</strong> {duration_minutes} minutes
        </div>
        
        <div class="content">
    {formatted_content.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('&lt;strong&gt;', '<strong>').replace('&lt;/strong&gt;', '</strong>').replace('&amp;bull;', '&bull;')}
        </div>
        
        <div class="footer">
            üìÖ Exported on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        </div>
    </body>
    </html>
    """
                
                html_file = Path(app_paths.appdata_dir) / f"deep_dive_day{current_day}_{topic_name.replace(' ', '_')[:30]}.html"
                html_file.write_text(html_content, encoding='utf-8')
                
                print(f"üìÑ Generated HTML: {html_file}")
                
                def send_worker():
                    try:
                        import requests
                        
                        url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
                        
                        with open(html_file, 'rb') as f:
                            files = {'document': f}
                            data = {
                                'chat_id': chat_id,
                                'caption': f"üìö Day {current_day} Deep Dive: {topic_name}"
                            }
                            
                            print(f"üì§ Sending to Telegram...")
                            response = requests.post(url, files=files, data=data)
                            
                            if response.status_code == 200:
                                print("‚úÖ Sent successfully!")
                                dive.after(0, lambda: messagebox.showinfo("Success", "Deep dive sent to Telegram! ‚úÖ"))
                            else:
                                print(f"‚ùå Failed: {response.text}")
                                dive.after(0, lambda: messagebox.showerror("Error", f"Failed to send: {response.text}"))
                        
                        if html_file.exists():
                            html_file.unlink()
                            
                    except Exception as e:
                        print(f"‚ùå Telegram error: {e}")
                        dive.after(0, lambda: messagebox.showerror("Error", f"Failed to send: {e}"))
                
                import threading
                threading.Thread(target=send_worker, daemon=True).start()
                
            except Exception as e:
                messagebox.showerror("Error", f"Telegram export failed: {e}")
                import traceback
                traceback.print_exc()
        
        telegram_btn = tk.Button(
            hdr_container,
            text="üì± Telegram",
            font=("Segoe UI", 9, "bold"),
            bg="#0088cc",
            fg="white",
            relief="flat",
            bd=0,
            padx=15,
            pady=8,
            cursor="hand2",
            command=send_to_telegram
        )
        telegram_btn.pack(side="right", padx=(10, 0))
        
        # ========== CAPSULE TAB BAR ==========
        capsule_frame = tk.Frame(dive, bg="#ecf0f1")
        capsule_frame.pack(fill="x", padx=20, pady=(15, 0))
        
        capsule_canvas = tk.Canvas(capsule_frame, bg="#ecf0f1", height=50, highlightthickness=0)
        capsule_canvas.pack(side="left", fill="both", expand=True)
        
        capsule_inner = tk.Frame(capsule_canvas, bg="#ecf0f1")
        capsule_canvas.create_window((0, 0), window=capsule_inner, anchor="nw")
        
        def update_capsule_scroll(event=None):
            capsule_canvas.configure(scrollregion=capsule_canvas.bbox("all"))
        
        capsule_inner.bind("<Configure>", update_capsule_scroll)
        
        def on_capsule_scroll(event):
            capsule_canvas.xview_scroll(int(-1*(event.delta/120)), "units")
        
        capsule_canvas.bind_all("<MouseWheel>", on_capsule_scroll)
        
        # ========== CONTENT AREA ==========
        content_container = tk.Frame(dive, bg="#f8f9fa")
        content_container.pack(fill="both", expand=True, padx=15, pady=15)
        
        from tkinter.scrolledtext import ScrolledText
        
        content_text = ScrolledText(
            content_container,
            wrap=tk.WORD,
            font=("Segoe UI", 10),
            bg="white",
            relief="solid",
            bd=1,
            padx=20,
            pady=20,
            spacing1=5,
            spacing2=3,
            spacing3=5
        )
        content_text.pack(fill="both", expand=True)
        content_text.config(state=tk.DISABLED)
        content_text.tag_configure("bold", font=("Segoe UI", 11, "bold"), foreground="#2c3e50")
        content_text.tag_configure("link", foreground="#0066cc", underline=True)
        
        # ========== LOAD MORE SPLASH ==========
        load_more_splash = tk.Frame(content_container, bg="#e8f4f8", relief="solid", bd=2, 
                                    highlightbackground="#3498db", highlightthickness=1)
        load_more_visible = {"state": False}
        
        splash_inner = tk.Frame(load_more_splash, bg="#e8f4f8")
        splash_inner.pack(pady=15, padx=20)
        
        tk.Label(splash_inner, 
                 text="üéì Want more PYQs for this section?",
                 font=("Segoe UI", 11, "bold"),
                 bg="#e8f4f8", fg="#2c3e50").pack(side="left", padx=(0, 15))
        
        def load_more_for_capsule():
            if not active_capsule["id"]:
                return
            
            capsule_id = active_capsule["id"]
            
            if capsule_contents[capsule_id]["loading_more"]:
                return
            
            more_btn.config(state=tk.DISABLED, text="‚è≥ Loading...")
            done_btn.config(state=tk.DISABLED)
            capsule_contents[capsule_id]["loading_more"] = True
            
            def generate_more():
                try:
                    from openai import OpenAI
                    from secrets_util import get_secret
                    from token_tracker import chat_complete_with_tracking
                    from token_manager import get_token_manager
                    
                    tm = get_token_manager()
                    balance_info = tm.get_balance()
                    if balance_info.get("balance", 0) <= 0:
                        def show_error():
                            messagebox.showwarning("Insufficient Tokens", 
                                                 "You don't have enough tokens to generate more content.")
                            capsule_contents[capsule_id]["loading_more"] = False
                            more_btn.config(state=tk.NORMAL, text="üìö Load More PYQs")
                            done_btn.config(state=tk.NORMAL)
                        dive.after(0, show_error)
                        return
                    
                    client = OpenAI(api_key=get_secret("AI_API"))
                    section_info = next(s for s in CAPSULE_SECTIONS if s["id"] == capsule_id)
                    
                    prompt = (
                        f"Generate ADDITIONAL exam-focused content for section: {section_info['title']}\n"
                        f"Topic: {topic_name} (Day {current_day})\n"
                        f"Context: {session_name} | Focus: {content_brief}\n\n"
                        "Generate MORE:\n"
                        "‚Ä¢ 10 additional PYQ-style questions with solutions\n"
                        "‚Ä¢ Advanced problem patterns\n"
                        "‚Ä¢ Tricky variations and edge cases\n"
                        "‚Ä¢ More formulas and shortcuts\n\n"
                        "Use PLAIN TEXT for formulas (NO LaTeX!)\n"
                        "Focus ONLY on exam-relevant content!"
                    )
                    
                    additional_content = chat_complete_with_tracking(
                        client,
                        messages=[
                            {"role": "system", "content": "You are a competitive exam coach. Provide exam-focused content only."},
                            {"role": "user", "content": prompt}
                        ],
                        model="gpt-4o-mini",
                        temperature=0.7,
                        session_name=f"{session_name}_{topic_name}_{capsule_id}_more",
                        purpose="deep_dive_expansion"
                    )
                    
                    additional_content = self._convert_latex_to_plain(additional_content)
                    
                    separator = "\n\n" + "="*80 + "\n" + "  ADDITIONAL CONTENT" + "\n" + "="*80 + "\n\n"
                    full_content = capsule_contents[capsule_id]["text"] + separator + additional_content
                    
                    save_capsule_to_cache(capsule_id, full_content)
                    
                    def update_ui():
                        capsule_emoji_images[capsule_id].clear()
                        
                        content_text.config(state=tk.NORMAL)
                        content_text.delete("1.0", tk.END)
                        insert_with_emojis(content_text, full_content, capsule_emoji_images[capsule_id], size_override=18)
                        content_text.config(state=tk.DISABLED)
                        
                        capsule_contents[capsule_id]["text"] = full_content
                        capsule_contents[capsule_id]["loading_more"] = False
                        
                        more_btn.config(state=tk.NORMAL, text="üìö Load More PYQs")
                        done_btn.config(state=tk.NORMAL)
                        
                        load_more_splash.place_forget()
                        load_more_visible["state"] = False
                        
                        sep_pos = content_text.search("ADDITIONAL CONTENT", "1.0", tk.END)
                        if sep_pos:
                            content_text.see(sep_pos)
                        
                        if hasattr(self, 'master') and hasattr(self.master, 'refresh_token_usage_display'):
                            self.master.refresh_token_usage_display()
                    
                    dive.after(0, update_ui)
                    
                except Exception as e:
                    def show_error():
                        messagebox.showerror("Error", f"Failed to generate content: {e}")
                        capsule_contents[capsule_id]["loading_more"] = False
                        more_btn.config(state=tk.NORMAL, text="üìö Load More PYQs")
                        done_btn.config(state=tk.NORMAL)
                    dive.after(0, show_error)
                    import traceback
                    traceback.print_exc()
            
            import threading
            threading.Thread(target=generate_more, daemon=True).start()
        
        more_btn = tk.Button(
            splash_inner,
            text="üìö Load More PYQs",
            font=("Segoe UI", 10, "bold"),
            bg="#3498db",
            fg="white",
            relief="flat",
            bd=0,
            padx=20,
            pady=8,
            cursor="hand2",
            command=load_more_for_capsule
        )
        more_btn.pack(side="left", padx=5)
        
        done_btn = tk.Button(
            splash_inner,
            text="‚úì Continue Reading",
            font=("Segoe UI", 10, "bold"),
            bg="#95a5a6",
            fg="white",
            relief="flat",
            bd=0,
            padx=20,
            pady=8,
            cursor="hand2",
            command=lambda: [
                load_more_splash.place_forget(), 
                load_more_visible.update({"state": False})
            ]
        )
        done_btn.pack(side="left", padx=5)
        
        # ========== SCROLL DETECTION ==========
        def check_scroll_position(event=None):
            try:
                if not active_capsule["id"]:
                    return
                
                capsule_id = active_capsule["id"]
                
                if not capsule_contents[capsule_id]["loaded"] or capsule_contents[capsule_id]["loading_more"]:
                    return
                
                yview = content_text.yview()
                has_scrollbar = (yview[1] - yview[0]) < 1.0
                
                if not has_scrollbar:
                    if load_more_visible["state"]:
                        load_more_splash.place_forget()
                        load_more_visible["state"] = False
                    return
                
                if yview[1] >= 0.98 and not load_more_visible["state"]:
                    load_more_splash.place(relx=0.5, rely=0.5, anchor="center")
                    load_more_visible["state"] = True
                elif yview[1] < 0.95 and load_more_visible["state"]:
                    load_more_splash.place_forget()
                    load_more_visible["state"] = False
            except Exception as e:
                print(f"‚ùå Scroll check error: {e}")
        
        content_text.bind("<MouseWheel>", check_scroll_position)
        content_text.bind("<Button-4>", check_scroll_position)
        content_text.bind("<Button-5>", check_scroll_position)
        content_text.bind("<KeyPress>", check_scroll_position)
        
        scrollbar = content_text.vbar
        original_set = scrollbar.set
        
        def on_scrollbar_set(*args):
            original_set(*args)
            check_scroll_position()
        
        scrollbar.set = on_scrollbar_set
        
        def periodic_check():
            if dive.winfo_exists():
                check_scroll_position()
                dive.after(200, periodic_check)
        
        dive.after(200, periodic_check)
        
        # ========== CACHE MANAGEMENT ==========
        def save_capsule_to_cache(capsule_id, content):
            deep_dive_file.parent.mkdir(parents=True, exist_ok=True)
            if deep_dive_file.exists():
                deep_dives = json.loads(deep_dive_file.read_text(encoding="utf-8"))
            else:
                deep_dives = {}
            
            dive_key = f"{dive_key_prefix}_{capsule_id}"
            deep_dives[dive_key] = content
            deep_dive_file.write_text(json.dumps(deep_dives, indent=2, ensure_ascii=False), encoding="utf-8")
        
        def load_capsule_from_cache(capsule_id):
            if not deep_dive_file.exists():
                return None
            
            try:
                deep_dives = json.loads(deep_dive_file.read_text(encoding="utf-8"))
                dive_key = f"{dive_key_prefix}_{capsule_id}"
                return deep_dives.get(dive_key)
            except:
                return None
        
        # ========== DISPLAY CAPSULE CONTENT ==========
        def display_capsule_content(capsule_id):
            capsule_data = capsule_contents[capsule_id]
            
            capsule_emoji_images[capsule_id].clear()
            
            content_text.config(state=tk.NORMAL)
            content_text.delete("1.0", tk.END)
            
            if capsule_data["loaded"]:
                insert_with_emojis(content_text, capsule_data["text"], capsule_emoji_images[capsule_id], size_override=18)
            else:
                content_text.insert("1.0", "‚è≥ Loading content...\n\nPlease wait while we generate this section.")
            
            content_text.config(state=tk.DISABLED)
            
            load_more_splash.place_forget()
            load_more_visible["state"] = False
            
            dive.after(100, check_scroll_position)
        
        # ========== GENERATE CAPSULE CONTENT ==========
        def generate_capsule_content(capsule_id):
            cached_content = load_capsule_from_cache(capsule_id)
            if cached_content:
                display_content = self._convert_latex_to_plain(cached_content)
                capsule_contents[capsule_id]["text"] = display_content
                capsule_contents[capsule_id]["loaded"] = True
                
                if active_capsule["id"] == capsule_id:
                    display_capsule_content(capsule_id)
                
                print(f"‚úÖ Loaded cached content for {capsule_id}")
                return
            
            def generate():
                try:
                    from openai import OpenAI
                    from secrets_util import get_secret
                    from token_tracker import chat_complete_with_tracking
                    from token_manager import get_token_manager
                    
                    tm = get_token_manager()
                    balance_info = tm.get_balance()
                    if balance_info.get("balance", 0) <= 0:
                        def show_error():
                            if active_capsule["id"] == capsule_id:
                                capsule_emoji_images[capsule_id].clear()
                                content_text.config(state=tk.NORMAL)
                                content_text.delete("1.0", tk.END)
                                content_text.insert("1.0", "‚ö†Ô∏è INSUFFICIENT TOKENS\n\nPlease purchase tokens to continue.")
                                content_text.config(state=tk.DISABLED)
                        dive.after(0, show_error)
                        return
                    
                    client = OpenAI(api_key=get_secret("AI_API"))
                    section_info = next(s for s in CAPSULE_SECTIONS if s["id"] == capsule_id)
                    
                    print(f"üîÑ Generating {section_info['title']} for {topic_name}...")
                    
                    profile_file = Path(app_paths.appdata_dir) / "profile.json"
                    exam_name = "competitive exam"
                    if profile_file.exists():
                        try:
                            profile = json.loads(profile_file.read_text(encoding="utf-8"))
                            exam_name = profile.get("exam_name", "competitive exam")
                        except:
                            pass
                    
                    prompts = {
                        "objectives": (
                            f"Create EXAM OBJECTIVES for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name} | Session: {session_name}\n"
                            f"Focus: {content_brief}\n\n"
                            "List 5-7 specific learning objectives that are EXAM-FOCUSED:\n"
                            "‚Ä¢ What questions can you solve after this?\n"
                            "‚Ä¢ Which formulas must you remember?\n"
                            "‚Ä¢ What concepts are frequently tested?\n"
                            "‚Ä¢ What marks can you score from this topic?\n\n"
                            "Use bullet points (‚Ä¢) and PLAIN TEXT formulas only!"
                        ),
                        "concepts": (
                            f"Create CORE CONCEPTS for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name} | Focus: {content_brief}\n\n"
                            "Cover:\n"
                            "‚Ä¢ Key definitions (as asked in exams)\n"
                            "‚Ä¢ Important theory points\n"
                            "‚Ä¢ Concept relationships\n"
                            "‚Ä¢ Common question patterns\n"
                            "‚Ä¢ Exam-relevant explanations only\n\n"
                            "Use PLAIN TEXT formulas (NO LaTeX!)"
                        ),
                        "formulas": (
                            f"Create KEY FORMULAS section for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name}\n\n"
                            "List 12-15 most important formulas:\n"
                            "‚Ä¢ Formula with proper notation (PLAIN TEXT)\n"
                            "‚Ä¢ When to use it\n"
                            "‚Ä¢ Units and dimensions\n"
                            "‚Ä¢ Common mistakes\n"
                            "‚Ä¢ Quick checking methods\n\n"
                            "Format: Œ∑ = W/Q_in, R = œÅL/A, P = V¬≤/R\n"
                            "Use: Œ∑ Œ± Œ≤ œÄ Œî Œ£ ‚àö √ó √∑ ‚âà ‚â§ ‚â•"
                        ),
                        "practice": (
                            f"Create PRACTICE PROBLEMS for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name} | Focus: {content_brief}\n\n"
                            "Provide:\n"
                            "‚Ä¢ 5 solved examples (with complete steps)\n"
                            "‚Ä¢ 6 practice problems (exam-style)\n"
                            "‚Ä¢ Step-by-step solutions\n"
                            "‚Ä¢ Alternative faster methods\n"
                            "‚Ä¢ Difficulty levels marked\n\n"
                            "Use PLAIN TEXT formulas only!"
                        ),
                        "strategy": (
                            f"Create EXAM STRATEGY for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name}\n\n"
                            "Cover:\n"
                            "‚Ä¢ How to identify question types\n"
                            "‚Ä¢ Step-by-step solving approach\n"
                            "‚Ä¢ Time management tips\n"
                            "‚Ä¢ Common mistakes to avoid\n"
                            "‚Ä¢ Marking scheme insights\n"
                            "‚Ä¢ Quick checking methods\n"
                            "‚Ä¢ Elimination techniques\n\n"
                            "Focus on scoring maximum marks!"
                        ),
                        "materials": (
                            f"Create STUDY MATERIALS GUIDE for: {topic_name} (Day {current_day})\n"
                            f"Exam: {exam_name}\n\n"
                            "‚ö†Ô∏è CRITICAL: Provide ONLY resources that are ACTUALLY RECOMMENDED by successful aspirants!\n\n"
                            "Provide comprehensive study resources:\n\n"
                            "üìö RECOMMENDED BOOKS (Most Popular Among Aspirants)\n"
                            "‚Ä¢ List 3-5 books that are WIDELY USED by toppers\n"
                            "‚Ä¢ Include: Book name, Author, Why it's recommended\n"
                            "‚Ä¢ Mention which specific chapters/sections to read\n"
                            "‚Ä¢ Example format: 'Concepts of Physics by H.C. Verma - Chapter 15 (Wave Motion) - Recommended by 95% of JEE toppers for conceptual clarity'\n\n"
                            "üåê QUALITY ONLINE RESOURCES\n"
                            "‚Ä¢ List 4-6 VERIFIED websites/platforms used by aspirants\n"
                            "‚Ä¢ MUST include full working URLs (https://...)\n"
                            "‚Ä¢ Mention what specific content is good (videos, notes, PYQs)\n"
                            "‚Ä¢ Example: 'Khan Academy Physics - https://www.khanacademy.org/science/physics - Excellent animated explanations'\n\n"
                            "üì∫ YOUTUBE CHANNELS (Verified & Popular)\n"
                            "‚Ä¢ List 3-4 channels that aspirants actually follow\n"
                            "‚Ä¢ Mention channel name and what they're known for\n"
                            "‚Ä¢ Include channel URLs if possible\n\n"
                            "üì± MOBILE APPS & TOOLS\n"
                            "‚Ä¢ List 2-3 helpful apps for this topic\n"
                            "‚Ä¢ Free and paid options\n\n"
                            "üìÑ FREE STUDY MATERIALS\n"
                            "‚Ä¢ Where to find free notes, PYQs, practice papers\n"
                            "‚Ä¢ Government/official resources\n"
                            "‚Ä¢ Include working URLs\n\n"
                            "üí° STUDY TIPS FOR RESOURCES\n"
                            "‚Ä¢ How to effectively use these materials\n"
                            "‚Ä¢ Recommended study sequence\n"
                            "‚Ä¢ Time allocation\n\n"
                            "IMPORTANT:\n"
                            "‚Ä¢ Provide REAL URLs that work (https://...)\n"
                            "‚Ä¢ Only suggest resources that are PROVEN and POPULAR\n"
                            "‚Ä¢ Focus on FREE or affordable options\n"
                            "‚Ä¢ Be specific about what makes each resource good"
                        ),
                        "preview": (
                            f"Create TOMORROW'S PREVIEW for Day {current_day + 1}\n"
                            f"Current topic: {topic_name}\n"
                            f"Exam: {exam_name} | Session: {session_name}\n\n"
                            "Provide:\n"
                            "‚Ä¢ Brief overview of next day's topics\n"
                            "‚Ä¢ How it connects to today's learning\n"
                            "‚Ä¢ What to revise tonight\n"
                            "‚Ä¢ Preparation tips for tomorrow\n\n"
                            "Keep it brief and motivating!"
                        )
                    }
                    
                    prompt = prompts.get(capsule_id, "Generate exam-focused content.")
                    
                    content = chat_complete_with_tracking(
                        client,
                        messages=[
                            {"role": "system", "content": f"You are an expert {exam_name} coach. Create exam-focused content. NO theory exploration - ONLY what helps score marks."},
                            {"role": "user", "content": prompt}
                        ],
                        model="gpt-4o-mini",
                        temperature=0.7,
                        session_name=f"{session_name}_{topic_name}_{capsule_id}",
                        purpose=f"deep_dive_{capsule_id}"
                    )
                    
                    print(f"‚úÖ Generated {len(content)} chars for {capsule_id}")
                    
                    content = self._convert_latex_to_plain(content)
                    save_capsule_to_cache(capsule_id, content)
                    
                    def update_ui():
                        capsule_contents[capsule_id]["text"] = content
                        capsule_contents[capsule_id]["loaded"] = True
                        
                        if active_capsule["id"] == capsule_id:
                            display_capsule_content(capsule_id)
                        
                        if hasattr(self, 'master') and hasattr(self.master, 'refresh_token_usage_display'):
                            self.master.refresh_token_usage_display()
                    
                    dive.after(0, update_ui)
                    
                except Exception as e:
                    def show_error():
                        if active_capsule["id"] == capsule_id:
                            capsule_emoji_images[capsule_id].clear()
                            content_text.config(state=tk.NORMAL)
                            content_text.delete("1.0", tk.END)
                            content_text.insert("1.0", f"‚ùå Error: {e}")
                            content_text.config(state=tk.DISABLED)
                    dive.after(0, show_error)
                    import traceback
                    traceback.print_exc()
            
            import threading
            threading.Thread(target=generate, daemon=True).start()
        
        # ========== AUTO-LOAD ALL CAPSULES ==========
        def auto_load_all_capsules():
            def load_next_capsule(index):
                if index >= len(CAPSULE_SECTIONS):
                    print("‚úÖ All capsules loaded!")
                    return
                
                capsule_id = CAPSULE_SECTIONS[index]["id"]
                
                if capsule_contents[capsule_id]["loaded"]:
                    print(f"‚è≠Ô∏è Skipping {capsule_id} (already loaded)")
                    dive.after(100, lambda: load_next_capsule(index + 1))
                    return
                
                print(f"üîÑ Auto-loading capsule {index + 1}/{len(CAPSULE_SECTIONS)}: {capsule_id}")
                
                generate_capsule_content(capsule_id)
                
                def check_and_continue():
                    if capsule_contents[capsule_id]["loaded"]:
                        print(f"‚úÖ Capsule {capsule_id} loaded, moving to next...")
                        dive.after(500, lambda: load_next_capsule(index + 1))
                    else:
                        dive.after(1000, check_and_continue)
                
                dive.after(2000, check_and_continue)
            
            dive.after(1000, lambda: load_next_capsule(0))
        
        auto_load_all_capsules()
        
        # ========== CAPSULE SWITCHING ==========
        def switch_capsule(capsule_id):
            if active_capsule["id"] == capsule_id:
                return
            
            for cid, btn in capsule_buttons.items():
                if cid == capsule_id:
                    btn.config(bg="#3498db", fg="white")
                else:
                    btn.config(bg="#bdc3c7", fg="#2c3e50")
            
            active_capsule["id"] = capsule_id
            display_capsule_content(capsule_id)
        
        # Create capsule buttons
        for section in CAPSULE_SECTIONS:
            btn = tk.Button(
                capsule_inner,
                text=f"{section['emoji']} {section['short']}",
                font=("Segoe UI", 10, "bold"),
                bg="#bdc3c7",
                fg="#2c3e50",
                relief="flat",
                bd=0,
                padx=20,
                pady=10,
                cursor="hand2",
                command=lambda cid=section["id"]: switch_capsule(cid)
            )
            btn.pack(side="left", padx=5)
            capsule_buttons[section["id"]] = btn
            btn.config(highlightthickness=0, borderwidth=0)
        
        # ========== CLOSE BUTTON ==========
        close_btn = tk.Button(
            dive,
            text="‚úñ Close",
            command=dive.destroy,
            font=("Segoe UI", 10, "bold"),
            bg="#e74c3c",
            fg="white",
            relief="flat",
            bd=0,
            padx=30,
            pady=10,
            cursor="hand2"
        )
        close_btn.pack(pady=(0, 15))
        
        # ========== INITIALIZE ==========
        first_capsule = CAPSULE_SECTIONS[0]["id"]
        switch_capsule(first_capsule)
        
    def _get_global_study_day(self):
        """Get the UNIVERSAL global study day (same for all plans)."""
        from config_paths import app_paths
        
        global_progress_file = Path(app_paths.appdata_dir) / "global_study_progress.json"
        
        print(f"üîç Checking global day... File exists: {global_progress_file.exists()}")
        
        if not global_progress_file.exists():
            print("üÜï Creating new global progress file")
            self._save_global_study_day(1)
            return 1
        
        try:
            data = json.loads(global_progress_file.read_text(encoding="utf-8"))
            global_key = "_universal_global_day"
            
            if global_key not in data:
                print("üÜï Initializing universal global day")
                data[global_key] = {
                    "global_day": 1,
                    "last_access_date": date.today().isoformat()
                }
                global_progress_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
                return 1
            
            global_data = data[global_key]
            last_access = global_data.get("last_access_date", "")
            current_global_day = global_data.get("global_day", 1)
            today_str = date.today().isoformat()
            
            print(f"üìä Current global day: {current_global_day}")
            print(f"üìÖ Last access: {last_access}")
            print(f"üìÖ Today: {today_str}")
            
            if last_access == today_str:
                print(f"‚úÖ Same day - returning Day {current_global_day}")
                return current_global_day
            elif last_access and last_access < today_str:
                from datetime import datetime
                last_date = datetime.strptime(last_access, "%Y-%m-%d").date()
                today = date.today()
                days_passed = (today - last_date).days
                
                new_global_day = current_global_day + days_passed
                
                print(f"üöÄ REAL DAYS PASSED: {days_passed} days. Day {current_global_day} ‚Üí {new_global_day}")
                
                data[global_key] = {
                    "global_day": new_global_day,
                    "last_access_date": today_str
                }
                
                global_progress_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
                print(f"üíæ Saved new global day: {new_global_day}")
                
                return new_global_day
            else:
                print(f"‚úÖ Returning current day: {current_global_day}")
                return current_global_day
                
        except Exception as e:
            print(f"‚ùå Error getting global day: {e}")
            import traceback
            traceback.print_exc()
            self._save_global_study_day(1)
            return 1

    def _save_global_study_day(self, global_day):
        """Save UNIVERSAL global study day (applies to all plans)."""
        from config_paths import app_paths
        
        global_progress_file = Path(app_paths.appdata_dir) / "global_study_progress.json"
        
        try:
            if global_progress_file.exists():
                data = json.loads(global_progress_file.read_text(encoding="utf-8"))
            else:
                data = {}
            
            # ‚úÖ Use a SINGLE global day for ALL plans
            global_key = "_universal_global_day"
            
            data[global_key] = {
                "global_day": global_day,
                "last_access_date": date.today().isoformat()
            }
            
            global_progress_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
            
            print(f"üíæ Saved UNIVERSAL global day: {global_day}")
            
        except Exception as e:
            print(f"‚ö† Error saving global day: {e}")
            
    def _get_session_start_global_day(self, session_name):
        """Get which global day this session was created on."""
        from config_paths import app_paths
        
        session_registry_file = Path(app_paths.appdata_dir) / "session_registry.json"
        
        if not session_registry_file.exists():
            return None
        
        try:
            data = json.loads(session_registry_file.read_text(encoding="utf-8"))
            key = f"{self.current_plan_name}_{session_name}"
            return data.get(key, {}).get("created_on_global_day")
        except:
            return None


    def _register_session_creation(self, session_name, global_day):
        """Register when a session was first created (on which global day)."""
        from config_paths import app_paths
        
        session_registry_file = Path(app_paths.appdata_dir) / "session_registry.json"
        
        try:
            if session_registry_file.exists():
                data = json.loads(session_registry_file.read_text(encoding="utf-8"))
            else:
                data = {}
            
            key = f"{self.current_plan_name}_{session_name}"
            
            # Only register if not already registered
            if key not in data:
                data[key] = {
                    "created_on_global_day": global_day,
                    "created_date": date.today().isoformat()
                }
                session_registry_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
                print(f"üìù Registered {session_name} created on Global Day {global_day}")
        
        except Exception as e:
            print(f"‚ö† Error registering session: {e}")


    def _get_session_current_day(self, session_name):
        """Calculate current day for a specific session based on when it was created."""
        
        # Get current global day
        current_global_day = self._get_global_study_day()
        
        # Get when this session was created
        session_start_day = self._get_session_start_global_day(session_name)
        
        if session_start_day is None:
            # First time opening this session - register it
            self._register_session_creation(session_name, current_global_day)
            return 1  # It's Day 1 for this session
        
        # Calculate session day
        session_day = current_global_day - session_start_day + 1
        
        print(f"üìä {session_name}: Global Day {current_global_day}, Session created on Global Day {session_start_day}, Session Day {session_day}")
        
        return max(1, session_day)  # Never go below Day 1
        
    def _get_session_completed_days(self, session_name):
        """Get list of completed days for a specific session."""
        from config_paths import app_paths
        
        completion_file = Path(app_paths.appdata_dir) / "session_completion.json"
        
        if not completion_file.exists():
            return []
        
        try:
            data = json.loads(completion_file.read_text(encoding="utf-8"))
            key = f"{self.current_plan_name}_{session_name}"
            return data.get(key, [])
        except:
            return []


    def _toggle_session_day_completion(self, session_name, day_number):
        """Toggle completion status for a specific session day."""
        from config_paths import app_paths
        
        completion_file = Path(app_paths.appdata_dir) / "session_completion.json"
        
        try:
            if completion_file.exists():
                data = json.loads(completion_file.read_text(encoding="utf-8"))
            else:
                data = {}
            
            key = f"{self.current_plan_name}_{session_name}"
            completed_days = data.get(key, [])
            
            if day_number in completed_days:
                completed_days.remove(day_number)
                status = "pending"
            else:
                completed_days.append(day_number)
                status = "complete"
            
            data[key] = completed_days
            completion_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
            
            return status
        
        except Exception as e:
            print(f"‚ö† Error toggling completion: {e}")
            return "pending"
            
    def _register_all_plan_sessions(self):
        """Register all sessions in the current plan if not already registered."""
        from config_paths import app_paths
        
        if not hasattr(self, 'current_plan_name') or not self.current_plan_name:
            return
        
        # Get current global day
        current_global_day = self._get_global_study_day()
        
        # Get current schedule (sessions)
        if not hasattr(self, 'schedule') or not self.schedule:
            return
        
        # Register each session if not already registered
        for session in self.schedule:
            # ‚úÖ FIX: Sessions are lists, not dicts
            # Format: ["Session Name", "Start", "End", "Break"]
            if isinstance(session, (list, tuple)) and len(session) >= 1:
                session_name = session[0]  # First element is name
                if session_name:
                    self._register_session_if_not_exists(session_name, current_global_day)
        
        print(f"‚úÖ Registered all sessions for plan: {self.current_plan_name}")


    def _register_session_if_not_exists(self, session_name, global_day):
        """Register a session only if it doesn't already exist in registry."""
        from config_paths import app_paths
        
        session_registry_file = Path(app_paths.appdata_dir) / "session_registry.json"
        
        try:
            if session_registry_file.exists():
                data = json.loads(session_registry_file.read_text(encoding="utf-8"))
            else:
                data = {}
            
            key = f"{self.current_plan_name}_{session_name}"
            
            # Only register if not already registered
            if key not in data:
                data[key] = {
                    "created_on_global_day": global_day,
                    "created_date": date.today().isoformat()
                }
                session_registry_file.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
                print(f"üìù NEW: Registered {session_name} created on Global Day {global_day}")
            else:
                existing_day = data[key].get("created_on_global_day")
                print(f"‚ÑπÔ∏è EXISTING: {session_name} already registered on Global Day {existing_day}")
        
        except Exception as e:
            print(f"‚ö† Error registering session: {e}")

    def add_session(self):
        import copy
        
        # Save undo state
        state_backup = {
            'schedule': copy.deepcopy(self.schedule),
            'plan_session_names': copy.deepcopy(getattr(self, 'plan_session_names', [])),
            'current_plan_name': getattr(self, 'current_plan_name', 'Default'),
            'plans': copy.deepcopy(getattr(self, 'plans', {}))
        }
        self.undo_stack.append(state_backup)
        self.redo_stack = []
        
        # Call popup without edit_idx (indicating new session)
        self.session_popup()
        self.auto_save_plan()
        
        # ‚úÖ NEW: Register all sessions after adding (will only register the new one)
        self._register_all_plan_sessions()
        

    def edit_session(self):      
        import copy
        self.undo_stack.append(copy.deepcopy(self.schedule))
        self.redo_stack = []
        
        selected = self.plan_tree.selection()
        if not selected:
            messagebox.showinfo("Edit Session", "Please select a session to edit.")
            return

        idx = self.plan_tree.index(selected[0])
        session_obj = self.schedule[idx]
        old_session_data = list(session_obj)
        old_session_name = session_obj[0]
        old_start_time = parse_time(session_obj[1])
        old_end_time = parse_time(session_obj[2])

        def after_edit_callback():
            self.manual_plan_row_selected = False
            self.save_session_history("Edited", old_session_data)

            self.schedule = [sess[:4] for sess in self.schedule if isinstance(sess, (list, tuple)) and len(sess) >= 4]

            new_start_time = parse_time(self.schedule[idx][1])
            new_end_time = parse_time(self.schedule[idx][2])

            new_schedule = self.schedule.copy()

            # Shift previous session's end time if start changed
            if idx > 0 and new_start_time != old_start_time:
                shift = datetime.combine(date.today(), new_start_time) - datetime.combine(date.today(), old_start_time)

                confirm = messagebox.askyesno(
                    "Adjust Previous Session?",
                    f"You changed the start time of session {idx + 1}.\nDo you want to adjust end time of session {idx} by same difference?"
                )
                if confirm:
                    prev_name, prev_start, prev_end, prev_break = new_schedule[idx - 1]
                    prev_end_dt = datetime.combine(date.today(), parse_time(prev_end)) + shift
                    prev_end_str = prev_end_dt.strftime("%H:%M")
                    new_schedule[idx - 1] = (prev_name, prev_start, prev_end_str, prev_break)

            # Shift future sessions if end changed
            if new_end_time != old_end_time:
                pass

            self.schedule = [s[:4] for s in new_schedule]
            save_schedule(self.schedule)
            self.refresh_plan_tree()

            # Update wastage log if session name changed
            new_session_name = self.schedule[idx][0]
            if old_session_name != new_session_name:
                self.rename_session_everywhere(old_session_name, new_session_name)

        self.session_popup(idx, on_save=after_edit_callback)
        self.auto_save_plan()

    


    def show_session_history(self):
        # Load history data
        history = []
        try:
            with open(app_paths.session_history_file, "r", encoding='utf-8') as f:
                reader = csv.DictReader(f)
                history = list(reader)
        except FileNotFoundError:
            pass

        # Get all unique session names for the filter
        session_names = sorted(set(row['Session'] for row in history if row['Session'].strip()))

        # Prepare a mapping of session to date: duration
        # Load wastage_log as a list of dicts: [{'Session': ..., 'Date': ..., 'Wastage (hh:mm:ss)': ...}, ...]
        wastage_log = []
        try:
            with open(app_paths.wastage_file, "r", encoding='utf-8') as f:
                reader = csv.DictReader(f)
                wastage_log = list(reader)
        except FileNotFoundError:
            pass

        # Pre-compute wastage data for each session
        session_wastage = defaultdict(lambda: {'total': 0, 'per_date': defaultdict(int)})
        for entry in wastage_log:
            sess = entry.get('Session', '').strip()
            date = entry.get('Date', '').strip()
            duration = entry.get('Wastage (hh:mm:ss)', '').strip()
            if sess and date and duration:
                # Convert hh:mm:ss to seconds
                try:
                    h, m, s = map(int, duration.split(':'))
                    seconds = h*3600 + m*60 + s
                    session_wastage[sess]['total'] += seconds
                    session_wastage[sess]['per_date'][date] += seconds
                except Exception:
                    continue

       

        # Build Tkinter window
        win = tk.Toplevel(self)
        win.title("Session History")
        win.geometry("1000x400")

        # Filter row
        tk.Label(win, text="Filter by Session:").pack(side="top", anchor="w")
        session_var = tk.StringVar()
        session_cb = ttk.Combobox(win, textvariable=session_var, values=["All"] + session_names)
        session_cb.pack(side="top", anchor="w", padx=5, pady=2)
        session_cb.set("All")

        # Treeview table
        columns = ("Session", "Action", "Overall Wastage", "Timestamp", "Dates")
        tree = ttk.Treeview(win, columns=columns, show="headings", height=16)
        x_scroll = ttk.Scrollbar(win, orient="horizontal", command=tree.xview)
        tree.configure(xscrollcommand=x_scroll.set)
        x_scroll.pack(side="bottom", fill="x")
        # Vertical Scrollbar (add these lines)
        y_scroll = ttk.Scrollbar(win, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=y_scroll.set)
        y_scroll.pack(side="right", fill="y")
        for col in columns:
            tree.heading(col, text=col, anchor="center")
            tree.column(col, anchor="center", width=200 if col == "Dates" 
        else 130)
        tree.pack(fill="both", expand=True)

        def refresh_tree():
            # Clear table
            for i in tree.get_children():
                tree.delete(i)
            # Which session to filter?
            filt = session_var.get().strip()
            for row in history:
                sess = row['Session'].strip()
                if filt != "All" and sess != filt:
                    continue
                # Get overall wastage for this session
                tot_secs = session_wastage[sess]['total'] if sess in session_wastage else 0
                dates = session_wastage[sess]['per_date'] if sess in session_wastage else {}
                datestr = ', '.join([f"{d}: {format_seconds(secs)}" for d, secs in dates.items()])
                # Compose row
                tree.insert('', 'end', values=(
                    sess, row["Action"], format_seconds(tot_secs), row["Timestamp"], datestr
                ))
        # On combobox change
        session_cb.bind("<<ComboboxSelected>>", lambda e: 
    refresh_tree())
        refresh_tree()

        # Optional: add scrollbar
        vsb = ttk.Scrollbar(win, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=vsb.set)
        vsb.pack(side="right", fill="y")
            
   
    def session_popup(self, edit_idx=None, on_save=None):
        # Create popup as child of main window
        popup = tk.Toplevel(self)
        popup.title("Session Details")
        popup.geometry("440x620")
        popup.resizable(False, False)
        
        # Make it modal without affecting appearance
        popup.transient(self)
        popup.grab_set()
        
        # Center the popup on screen
        popup.update_idletasks()
        x = (popup.winfo_screenwidth() // 2) - 240
        y = (popup.winfo_screenheight() // 2) - 310
        popup.geometry(f"480x620+{x}+{y}")
        
        # Bind close event
        def on_popup_close():
            popup.grab_release()
            popup.destroy()
        
        popup.protocol("WM_DELETE_WINDOW", on_popup_close)
        
        # Professional color scheme
        BG_COLOR = "#f8f9fa"
        HEADER_BG = "#2c3e50"
        HEADER_FG = "#ffffff"
        ACCENT_COLOR = "#3498db"
        SUCCESS_COLOR = "#27ae60"
        WARNING_COLOR = "#e74c3c"
        CARD_BG = "#ffffff"
        BORDER_COLOR = "#dce1e7"
        TEXT_DARK = "#2c3e50"
        TEXT_LIGHT = "#7f8c8d"
        
        popup.configure(bg=BG_COLOR)
        
        # Main container with very tight padding
        main_frame = tk.Frame(popup, bg=BG_COLOR)
        main_frame.pack(fill="both", expand=True, padx=12, pady=6)
        
        # Header Section
        header_frame = tk.Frame(main_frame, bg=HEADER_BG, height=36)
        header_frame.pack(fill="x", pady=(0, 6))
        header_frame.pack_propagate(False)
        
        header_label = tk.Label(header_frame, 
                                text="üìã Session Configuration",
                                font=("Segoe UI", 11, "bold"),
                                bg=HEADER_BG, fg=HEADER_FG)
        header_label.pack(expand=True)

        # Session Name Card
        name_card = tk.Frame(main_frame, bg=CARD_BG, relief="flat", bd=1, highlightbackground=BORDER_COLOR, highlightthickness=1)
        name_card.pack(fill="x", pady=(0, 6))
        
        name_inner = tk.Frame(name_card, bg=CARD_BG)
        name_inner.pack(padx=8, pady=8)
        
        tk.Label(name_inner, text="Session Name", font=("Segoe UI", 9, "bold"), bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w")
        
        # Entry field with autocomplete
        name_entry = tk.Entry(name_inner, font=("Segoe UI", 10), width=35, relief="solid", bd=1,
                     bg="#f7f9fc", fg=TEXT_DARK, insertbackground=ACCENT_COLOR)
        name_entry.pack(pady=(4, 0), ipady=2)

        # ========== AUTOCOMPLETE SUGGESTION BOX (OVERLAY) ==========
        # Use place instead of pack to create overlay without moving content
        suggestion_frame = tk.Frame(popup, bg="white", relief="solid", bd=1,
                                   highlightbackground=BORDER_COLOR, highlightthickness=1)
        suggestion_listbox = tk.Listbox(suggestion_frame, font=("Segoe UI", 9), 
                                       bg="white", fg=TEXT_DARK,
                                       selectbackground=ACCENT_COLOR, selectforeground="white",
                                       height=5, relief="flat", bd=0,
                                       activestyle="none")
        suggestion_listbox.pack(fill="both", expand=True)
        
        # Hide initially - don't place yet
        suggestion_frame.place_forget()
        
        def get_all_session_names():
            """Get unique session names from schedule, excluding current edit"""
            names = set()
            for i, sess in enumerate(self.schedule):
                if edit_idx is not None and i == edit_idx:
                    continue  # Skip the session being edited
                names.add(sess[0])
            return sorted(names, key=str.lower)
        
        def show_suggestions(matches):
            """Display matching suggestions as overlay"""
            if not matches:
                suggestion_frame.place_forget()
                return
            
            suggestion_listbox.delete(0, tk.END)
            for name in matches:
                suggestion_listbox.insert(tk.END, name)
            
            # Position the suggestion frame below the name_entry as an overlay
            # Update the popup to get accurate positioning
            popup.update_idletasks()
            
            # Get the absolute position of name_entry
            entry_x = name_entry.winfo_x() + name_inner.winfo_x() + name_card.winfo_x() + main_frame.winfo_x()
            entry_y = name_entry.winfo_y() + name_entry.winfo_height() + name_inner.winfo_y() + name_card.winfo_y() + main_frame.winfo_y()
            entry_width = name_entry.winfo_width()
            
            # Place the suggestion frame
            suggestion_frame.place(x=entry_x, y=entry_y, width=entry_width)
            suggestion_frame.lift()  # Ensure it's on top
            
        def hide_suggestions():
            """Hide the suggestion box"""
            suggestion_frame.place_forget()
        
        def on_name_change(*args):
            """Filter and show suggestions based on input"""
            text = name_entry.get().strip()
            
            if not text:
                hide_suggestions()
                return
            
            # Get all session names
            all_names = get_all_session_names()
            
            # Filter names that start with the typed text (case-insensitive)
            matches = [name for name in all_names if name.lower().startswith(text.lower())]
            
            if matches:
                show_suggestions(matches)
            else:
                hide_suggestions()
        
        def on_suggestion_select(event):
            """Handle suggestion selection"""
            selection = suggestion_listbox.curselection()
            if selection:
                selected_name = suggestion_listbox.get(selection[0])
                name_entry.delete(0, tk.END)
                name_entry.insert(0, selected_name)
                hide_suggestions()
                name_entry.focus_set()
        
        def on_entry_keypress(event):
            """Handle keyboard navigation in suggestions"""
            if not suggestion_frame.winfo_ismapped():
                return
            
            if event.keysym == "Down":
                suggestion_listbox.focus_set()
                suggestion_listbox.selection_clear(0, tk.END)
                suggestion_listbox.selection_set(0)
                suggestion_listbox.activate(0)
                return "break"
            elif event.keysym == "Escape":
                hide_suggestions()
                return "break"
            elif event.keysym == "Return":
                selection = suggestion_listbox.curselection()
                if selection:
                    selected_name = suggestion_listbox.get(selection[0])
                    name_entry.delete(0, tk.END)
                    name_entry.insert(0, selected_name)
                    hide_suggestions()
                return "break"
        
        def on_listbox_keypress(event):
            """Handle keyboard navigation within listbox"""
            if event.keysym == "Return":
                on_suggestion_select(event)
                return "break"
            elif event.keysym == "Escape":
                hide_suggestions()
                name_entry.focus_set()
                return "break"
            elif event.keysym == "Up":
                current = suggestion_listbox.curselection()
                if current and current[0] == 0:
                    name_entry.focus_set()
                    hide_suggestions()
                    return "break"
        
        # Bind events
        name_entry.bind('<KeyRelease>', lambda e: on_name_change())
        name_entry.bind('<KeyPress>', on_entry_keypress)
        suggestion_listbox.bind('<<ListboxSelect>>', on_suggestion_select)
        suggestion_listbox.bind('<Double-Button-1>', on_suggestion_select)
        suggestion_listbox.bind('<KeyPress>', on_listbox_keypress)
        
        # Hide suggestions when clicking outside
        def on_popup_click(event):
            widget = event.widget
            if widget not in (name_entry, suggestion_listbox, suggestion_frame):
                hide_suggestions()
        
        popup.bind('<Button-1>', on_popup_click)
        # ========== END AUTOCOMPLETE ==========

        # ==== TIME CONFIGURATION CARD ====
        time_card = tk.Frame(main_frame, bg=CARD_BG, relief="flat", bd=1, highlightbackground=BORDER_COLOR, highlightthickness=1)
        time_card.pack(fill="both", expand=True, pady=(0, 6))
        
        # Increased padding for time configuration
        time_inner = tk.Frame(time_card, bg=CARD_BG)
        time_inner.pack(padx=12, pady=10)
        
        # Time header with icon
        time_header = tk.Frame(time_inner, bg=CARD_BG)
        time_header.pack(fill="x", pady=(0, 5))
        tk.Label(time_header, text="‚è∞ Time Configuration", font=("Segoe UI", 10, "bold"), 
                bg=CARD_BG, fg=ACCENT_COLOR).pack(side="left")
        
        # Duration display badge - now editable
        duration_frame = tk.Frame(time_inner, bg=CARD_BG)
        duration_frame.pack(pady=(0, 6))
        
        tk.Label(duration_frame, text="Enter Duration:", font=("Segoe UI", 8), bg=CARD_BG, fg=TEXT_LIGHT).pack(side="left", padx=(0, 5))
        
        # Editable hour and minute fields
        duration_edit_frame = tk.Frame(duration_frame, bg="#e8f8f5", relief="flat", bd=1,
                                       highlightbackground=SUCCESS_COLOR, highlightthickness=1)
        duration_edit_frame.pack(side="left")
        
        duration_hours_var = tk.StringVar(value="2")
        duration_mins_var = tk.StringVar(value="0")
        
        # Hour entry
        duration_hours_entry = tk.Entry(duration_edit_frame, textvariable=duration_hours_var,
                                       font=("Segoe UI", 9, "bold"), fg=SUCCESS_COLOR, bg="#e8f8f5",
                                       width=3, justify="center", relief="flat", bd=0)
        duration_hours_entry.pack(side="left", padx=(5, 0))
        
        tk.Label(duration_edit_frame, text="h", font=("Segoe UI", 9, "bold"), 
                fg=SUCCESS_COLOR, bg="#e8f8f5").pack(side="left", padx=(0, 5))
        
        # Minute entry
        duration_mins_entry = tk.Entry(duration_edit_frame, textvariable=duration_mins_var,
                                      font=("Segoe UI", 9, "bold"), fg=SUCCESS_COLOR, bg="#e8f8f5",
                                      width=3, justify="center", relief="flat", bd=0)
        duration_mins_entry.pack(side="left", padx=(5, 0))
        
        tk.Label(duration_edit_frame, text="m", font=("Segoe UI", 9, "bold"),
                fg=SUCCESS_COLOR, bg="#e8f8f5").pack(side="left", padx=(0, 5))

        # Styled separator
        separator1 = tk.Frame(time_inner, bg=BORDER_COLOR, height=1)
        separator1.pack(fill="x", pady=(0, 6))

        # Start Time Section - Reduced padding
        start_section = tk.Frame(time_inner, bg=CARD_BG)
        start_section.pack(fill="x", pady=(0, 6))
        
        tk.Label(start_section, text="Start Time", font=("Segoe UI", 9, "bold"), bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w", pady=(0, 3))
        
        start_controls = tk.Frame(start_section, bg=CARD_BG)
        start_controls.pack()
        
        # Create a clean horizontal layout with Entry fields
        start_hour_var = tk.StringVar(value="09")
        start_hour_entry = tk.Entry(start_controls, textvariable=start_hour_var, width=4, 
                            font=("Segoe UI", 10), justify="center", relief="solid", bd=1,
                            bg="#f7f9fc", fg=TEXT_DARK)
        start_hour_entry.pack(side="left")
        
        tk.Label(start_controls, text=":", font=("Segoe UI", 11, "bold"), bg=CARD_BG, fg=TEXT_DARK).pack(side="left", padx=2)
        
        start_min_var = tk.StringVar(value="00")
        start_min_entry = tk.Entry(start_controls, textvariable=start_min_var, width=4,
                                   font=("Segoe UI", 10), justify="center", relief="solid", bd=1,
                                   bg="#f7f9fc", fg=TEXT_DARK)
        start_min_entry.pack(side="left")
        
        tk.Label(start_controls, text="  ", bg=CARD_BG).pack(side="left", padx=8)
        
        # AM/PM as radio buttons in a frame
        start_ampm_var = tk.StringVar(value="AM")
        ampm_frame = tk.Frame(start_controls, bg=CARD_BG)
        ampm_frame.pack(side="left")
        
        am_btn = tk.Radiobutton(ampm_frame, text="AM", variable=start_ampm_var, value="AM",
                                font=("Segoe UI", 10), bg=CARD_BG, fg=TEXT_DARK,
                                activebackground=CARD_BG, selectcolor="#e8f8f5")
        am_btn.pack(side="left")
        
        pm_btn = tk.Radiobutton(ampm_frame, text="PM", variable=start_ampm_var, value="PM",
                                font=("Segoe UI", 10), bg=CARD_BG, fg=TEXT_DARK,
                                activebackground=CARD_BG, selectcolor="#e8f8f5")
        pm_btn.pack(side="left")

        # End Time Section - Reduced padding
        end_section = tk.Frame(time_inner, bg=CARD_BG)
        end_section.pack(fill="x", pady=(0, 4))
        
        tk.Label(end_section, text="End Time", font=("Segoe UI", 9, "bold"), bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w", pady=(0, 3))
        
        end_controls = tk.Frame(end_section, bg=CARD_BG)
        end_controls.pack()
        
        # Create same clean horizontal layout
        end_hour_var = tk.StringVar(value="11")
        end_hour_entry = tk.Entry(end_controls, textvariable=end_hour_var, width=4,
                                  font=("Segoe UI", 10), justify="center", relief="solid", bd=1,
                                  bg="#f7f9fc", fg=TEXT_DARK)
        end_hour_entry.pack(side="left")
        
        tk.Label(end_controls, text=":", font=("Segoe UI", 12, "bold"), bg=CARD_BG, fg=TEXT_DARK).pack(side="left", padx=3)
        
        end_min_var = tk.StringVar(value="00")
        end_min_entry = tk.Entry(end_controls, textvariable=end_min_var, width=4,
                                 font=("Segoe UI", 10), justify="center", relief="solid", bd=1,
                                 bg="#f7f9fc", fg=TEXT_DARK)
        end_min_entry.pack(side="left")
        
        tk.Label(end_controls, text="  ", bg=CARD_BG).pack(side="left", padx=8)
        
        # AM/PM as radio buttons
        end_ampm_var = tk.StringVar(value="AM")
        end_ampm_frame = tk.Frame(end_controls, bg=CARD_BG)
        end_ampm_frame.pack(side="left")
        
        end_am_btn = tk.Radiobutton(end_ampm_frame, text="AM", variable=end_ampm_var, value="AM",
                                    font=("Segoe UI", 10), bg=CARD_BG, fg=TEXT_DARK,
                                    activebackground=CARD_BG, selectcolor="#e8f8f5")
        end_am_btn.pack(side="left")
        
        end_pm_btn = tk.Radiobutton(end_ampm_frame, text="PM", variable=end_ampm_var, value="PM",
                                    font=("Segoe UI", 10), bg=CARD_BG, fg=TEXT_DARK,
                                    activebackground=CARD_BG, selectcolor="#e8f8f5")
        end_pm_btn.pack(side="left")

        # Auto-calc duration
        updating_from_duration = False  # Flag to prevent circular updates
        updating_from_end_time = False  # New flag for end time updates

        def update_duration(*_):
            """Calculate duration from start and end times"""
            if updating_from_duration:
                return
            
            nonlocal updating_from_end_time
            updating_from_end_time = True
            
            try:
                from datetime import datetime, timedelta
                sh, sm = start_hour_var.get().strip(), start_min_var.get().strip()
                eh, em = end_hour_var.get().strip(),   end_min_var.get().strip()
                sap, eap = start_ampm_var.get(), end_ampm_var.get()
                if not all([sh,sm,sap,eh,em,eap]): 
                    duration_hours_var.set("0")
                    duration_mins_var.set("0")
                    return
                if len(sh)==1: sh="0"+sh
                if len(sm)==1: sm="0"+sm
                if len(eh)==1: eh="0"+eh
                if len(em)==1: em="0"+em
                s12=f"{sh}:{sm} {sap}"; e12=f"{eh}:{em} {eap}"
                sdt=datetime.strptime(s12,"%I:%M %p"); edt=datetime.strptime(e12,"%I:%M %p")
                if edt<=sdt: edt+=timedelta(days=1)
                mins=int((edt-sdt).total_seconds()//60); h=mins//60; m=mins%60
                
                # Update duration fields
                duration_hours_var.set(str(h))
                duration_mins_var.set(str(m))
            except: 
                duration_hours_var.set("0")
                duration_mins_var.set("0")
            finally:
                updating_from_end_time = False

        def update_end_time_from_duration(*_):
            """Calculate end time from start time and duration"""
            # Only update if we're not currently updating from end time
            if updating_from_end_time:
                return
                
            nonlocal updating_from_duration
            updating_from_duration = True
            
            try:
                from datetime import datetime, timedelta
                
                # Get duration
                hours = int(duration_hours_var.get() or "0")
                minutes = int(duration_mins_var.get() or "0")
                
                # Validate duration values
                if hours < 0: 
                    hours = 0
                    duration_hours_var.set("0")
                if minutes < 0: 
                    minutes = 0
                    duration_mins_var.set("0")
                if minutes >= 60:
                    # Convert excess minutes to hours
                    hours += minutes // 60
                    minutes = minutes % 60
                    duration_hours_var.set(str(hours))
                    duration_mins_var.set(str(minutes))
                
                total_minutes = hours * 60 + minutes
                
                # Get start time
                sh = start_hour_var.get().strip()
                sm = start_min_var.get().strip()
                sap = start_ampm_var.get()
                
                if not all([sh, sm, sap]):
                    updating_from_duration = False
                    return
                
                # Parse start time
                if len(sh)==1: sh="0"+sh
                if len(sm)==1: sm="0"+sm
                s12 = f"{sh}:{sm} {sap}"
                start_dt = datetime.strptime(s12, "%I:%M %p")
                
                # Calculate end time
                end_dt = start_dt + timedelta(minutes=total_minutes)
                
                # Set end time fields
                end_hour_var.set(str(int(end_dt.strftime("%I"))))
                end_min_var.set(end_dt.strftime("%M"))
                end_ampm_var.set(end_dt.strftime("%p"))
                
            except Exception as e:
                print(f"DEBUG: update_end_time_from_duration error: {e}")
            finally:
                updating_from_duration = False

        # Modified binding approach - use different events to avoid conflicts
        # For start time and AM/PM changes - update both duration and potentially end time
        start_hour_var.trace('w', update_duration)
        start_min_var.trace('w', update_duration)
        start_ampm_var.trace('w', update_duration)

        # For end time - only update duration when not being updated by duration
        end_hour_var.trace('w', update_duration)
        end_min_var.trace('w', update_duration)
        end_ampm_var.trace('w', update_duration)

        # For duration fields - only update end time
        duration_hours_var.trace('w', update_end_time_from_duration)
        duration_mins_var.trace('w', update_end_time_from_duration)

        def time_12h_to_24h(hour, minute, ampm):
            try:
                from datetime import datetime
                if len(hour)==1: hour="0"+hour
                if len(minute)==1: minute="0"+minute
                dt = datetime.strptime(f"{hour}:{minute} {ampm}", "%I:%M %p")
                return dt.strftime("%H:%M")
            except:
                return "09:00"

        # --- helper for shifting in 24h format ---
        def add_minutes_24h(hhmm: str, delta_min: int) -> str:
            from datetime import datetime, timedelta
            try:
                dt = datetime.strptime(hhmm.strip(), "%H:%M")
            except Exception:
                return hhmm
            dt = dt + timedelta(minutes=delta_min)
            return dt.strftime("%H:%M")

        # ==== SHIFT OTHER SESSIONS CARD ====
        separator2 = tk.Frame(time_inner, bg=BORDER_COLOR, height=1)
        separator2.pack(fill="x", pady=6)
        
        shift_section = tk.Frame(time_inner, bg=CARD_BG)
        shift_section.pack(fill="x")
        
        tk.Label(shift_section, text="‚ö° Quick Shift Sessions", font=("Segoe UI", 9, "bold"), 
                bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w", pady=(0, 5))
        
        shift_wrap = tk.Frame(shift_section, bg="#f7f9fc", relief="flat", bd=1,
                             highlightbackground=BORDER_COLOR, highlightthickness=1)
        shift_wrap.pack(fill="x", pady=(0, 3))
        
        shift_inner = tk.Frame(shift_wrap, bg="#f7f9fc")
        shift_inner.pack(padx=5, pady=5)

        shift_dir = tk.StringVar(value="before")
        radio_style = {"font": ("Segoe UI", 8), "bg": "#f7f9fc", "fg": TEXT_DARK,
                      "activebackground": "#f7f9fc", "selectcolor": "#f7f9fc"}
        tk.Radiobutton(shift_inner, text="Push all previous sessions by", variable=shift_dir, 
                      value="before", **radio_style).grid(row=0, column=0, sticky="w", padx=(0,6))
        tk.Radiobutton(shift_inner, text="Push all after sessions by", variable=shift_dir, 
                      value="after", **radio_style).grid(row=1, column=0, sticky="w", padx=(0,6))

        tk.Label(shift_inner, text="Hours", font=("Segoe UI", 8), bg="#f7f9fc", fg=TEXT_LIGHT).grid(row=0, column=1, padx=(6,2))
        tk.Label(shift_inner, text="Minutes", font=("Segoe UI", 8), bg="#f7f9fc", fg=TEXT_LIGHT).grid(row=1, column=1, padx=(6,2))

        shift_h_var = tk.StringVar(value="0")
        shift_m_var = tk.StringVar(value="0")
        
        # Entry fields with thin black outline
        entry_style = {"width": 5, "justify": "center", "relief": "solid", "bd": 1,
                      "bg": "white", "fg": TEXT_DARK, "font": ("Segoe UI", 9)}
        hour_entry = tk.Entry(shift_inner, textvariable=shift_h_var, **entry_style)
        hour_entry.grid(row=0, column=2, padx=(0,6))
        min_entry = tk.Entry(shift_inner, textvariable=shift_m_var, **entry_style)
        min_entry.grid(row=1, column=2, padx=(0,6))

        def apply_shift():
            # Must be editing (need pivot index)
            if edit_idx is None or not (0 <= edit_idx < len(self.schedule)):
                from tkinter import messagebox
                popup.attributes("-topmost", True)
                popup.update()
                messagebox.showwarning("Pick a session", "Open this popup via Edit on a session to use shifting.", parent=popup)
                popup.attributes("-topmost", True)
                return
            try:
                delta = max(0, int(shift_h_var.get() or 0)*60 + int(shift_m_var.get() or 0))
            except Exception:
                delta = 0
            if delta == 0:
                return

            new_sched = []
            for i, row in enumerate(self.schedule):
                name, s24, e24, brk = row

                # Decide shift direction
                shift_amount = 0
                if shift_dir.get() == "before" and i < edit_idx:
                    shift_amount = -delta
                elif shift_dir.get() == "after" and i > edit_idx:
                    shift_amount = +delta

                # Shift start/end
                if shift_amount != 0:
                    s24 = add_minutes_24h(s24, shift_amount)
                    e24 = add_minutes_24h(e24, shift_amount)

                    # Shift break if it exists
                    if brk and "-" in brk:
                        try:
                            start_b, end_b = brk.split("-")
                            start_b = add_minutes_24h(start_b.strip(), shift_amount)
                            end_b = add_minutes_24h(end_b.strip(), shift_amount)
                            brk = f"{start_b}-{end_b}"
                        except Exception as e:
                            print(f"DEBUG: Break shift error: {e}")

                new_sched.append((name, s24, e24, brk))

            self.schedule = new_sched
            try: self.clean_schedule()
            except: pass
            try: save_schedule(self.schedule)
            except: pass
            try: self.app.recompute_required_rates()
            except: pass
            try: self.refresh_plan_tree()
            except: pass

        shift_btn = tk.Button(shift_inner, text="Apply", command=apply_shift,
                             font=("Segoe UI", 8, "bold"), bg=ACCENT_COLOR, fg="white",
                             relief="flat", bd=0, padx=10, pady=3, cursor="hand2")
        shift_btn.grid(row=0, column=3, rowspan=2, padx=(6,0))

        # ==== BREAK TIME CARD ====
        break_card = tk.Frame(main_frame, bg=CARD_BG, relief="flat", bd=1, 
                             highlightbackground=BORDER_COLOR, highlightthickness=1)
        break_card.pack(fill="x", pady=(0, 6))
        
        break_inner = tk.Frame(break_card, bg=CARD_BG)
        break_inner.pack(padx=8, pady=6)
        
        tk.Label(break_inner, text="‚òï Break Time", font=("Segoe UI", 9, "bold"), 
                bg=CARD_BG, fg=TEXT_DARK).pack(anchor="w", pady=(0, 5))
        
        # Break input section
        break_input_frame = tk.Frame(break_inner, bg=CARD_BG)
        break_input_frame.pack(fill="x", pady=(0, 5))
        
        tk.Label(break_input_frame, text="Break:", font=("Segoe UI", 9), 
        bg=CARD_BG, fg=TEXT_LIGHT).pack(side="left", padx=(0,8))
        break_minutes_var = tk.StringVar(value="0")
        break_minutes_entry = tk.Entry(break_input_frame, textvariable=break_minutes_var, 
                                      width=12, font=("Segoe UI", 10), relief="flat", bd=5,
                                      bg="#f7f9fc", fg=TEXT_DARK)
        break_minutes_entry.pack(side="left", padx=(0,15))

        # Tooltip hint
        tk.Label(break_input_frame, text="(minutes or text)", font=("Segoe UI", 7, "italic"), 
                bg=CARD_BG, fg=TEXT_LIGHT).pack(side="left", padx=(0,8))
        
        tk.Label(break_input_frame, text="‚Üí", font=("Segoe UI", 12), 
                bg=CARD_BG, fg=ACCENT_COLOR).pack(side="left", padx=(0,10))
        break_display_var = tk.StringVar(value="No Break")
        break_display_label = tk.Label(break_input_frame, textvariable=break_display_var, 
                                     font=("Segoe UI", 10, "bold"), bg="#fff4e6", fg="#f39c12",
                                     relief="flat", width=20, anchor="center", pady=5)
        break_display_label.pack(side="left", fill="x", expand=True)
        
        # Quick preset buttons
        buttons_frame = tk.Frame(break_inner, bg=CARD_BG)
        buttons_frame.pack()
        
        def set_break_minutes(minutes):
            break_minutes_var.set(str(minutes))
            update_break_display()
        
        def update_break_display(*args):
            try:
                input_str = break_minutes_var.get().strip()
                
                # Check if input is numeric
                try:
                    minutes = int(input_str)
                    is_numeric = True
                except ValueError:
                    is_numeric = False
                    minutes = 0

                if not input_str or (is_numeric and minutes <= 0):
                    break_display_var.set("No Break")
                    break_display_label.configure(bg="#ffe6e6", fg="#e74c3c")
                    return

                # If it's free text (not numeric), display it directly
                if not is_numeric:
                    break_display_var.set(f"üìù {input_str}")
                    break_display_label.configure(bg="#fff4e6", fg="#f39c12")
                    return

                # Rest of numeric logic
                end_hour = end_hour_var.get().strip()
                end_min = end_min_var.get().strip()
                end_ampm = end_ampm_var.get()

                if not all([end_hour, end_min, end_ampm]):
                    break_display_var.set("Set end time first")
                    break_display_label.configure(bg="#fff4e6", fg="#f39c12")
                    return

                from datetime import datetime, timedelta

                # Convert to datetime
                end_hour_int = int(end_hour)
                if end_ampm == "PM" and end_hour_int != 12:
                    end_hour_int += 12
                elif end_ampm == "AM" and end_hour_int == 12:
                    end_hour_int = 0

                end_time = datetime.strptime(f"{end_hour_int:02d}:{end_min}", "%H:%M")
                break_end_time = end_time + timedelta(minutes=minutes)

                # Format nicely in 12-hour format
                nice_start = end_time.strftime("%I:%M %p").lstrip("0")
                nice_end = break_end_time.strftime("%I:%M %p").lstrip("0")

                break_display_var.set(f"{nice_start} - {nice_end}")
                break_display_label.configure(bg="#e8f8f5", fg="#27ae60")

            except Exception as e:
                break_display_var.set("No Break")
                break_display_label.configure(bg="#ffe6e6", fg="#e74c3c")
                print(f"DEBUG: update_break_display error: {e}")
        
        # Bind update function to variable changes
        break_minutes_var.trace('w', update_break_display)
        end_hour_var.trace('w', update_break_display)
        end_min_var.trace('w', update_break_display)
        end_ampm_var.trace('w', update_break_display)
        
        # Styled preset buttons
        btn_style = {"font": ("Segoe UI", 8), "relief": "flat", "bd": 0, 
                    "padx": 6, "pady": 2, "cursor": "hand2"}
        
        tk.Button(buttons_frame, text="No Break", command=lambda: set_break_minutes(0),
                 bg="#ffe6e6", fg="#c0392b", **btn_style).pack(side="left", padx=2)
        tk.Button(buttons_frame, text="15 min", command=lambda: set_break_minutes(15),
                 bg="#e3f2fd", fg="#1976d2", **btn_style).pack(side="left", padx=2)
        tk.Button(buttons_frame, text="30 min", command=lambda: set_break_minutes(30),
                 bg="#e3f2fd", fg="#1976d2", **btn_style).pack(side="left", padx=2)
        tk.Button(buttons_frame, text="45 min", command=lambda: set_break_minutes(45),
                 bg="#e3f2fd", fg="#1976d2", **btn_style).pack(side="left", padx=2)
        tk.Button(buttons_frame, text="1 hour", command=lambda: set_break_minutes(60),
                 bg="#e3f2fd", fg="#1976d2", **btn_style).pack(side="left", padx=2)

        # ========== AUTO-POPULATE START TIME FROM LAST SESSION ==========
        if edit_idx is None:  # Only for new sessions, not editing
            if self.schedule:  # If there are existing sessions
                last_session = self.schedule[-1]  # Get the last session
                last_break = last_session[3]  # Break time
                
                try:
                    from datetime import datetime, timedelta
                    
                    # Determine the time to use (break end or session end)
                    if last_break and last_break != "No Break" and "-" in last_break:
                        # Use break end time
                        time_to_use = last_break.split("-")[1].strip()
                    else:
                        # Use session end time
                        time_to_use = last_session[2]
                    
                    # Parse the 24h time
                    time_dt = datetime.strptime(time_to_use, "%H:%M")
                    
                    # Set the start time fields
                    start_hour_var.set(str(int(time_dt.strftime("%I"))))  # Remove leading zero
                    start_min_var.set(time_dt.strftime("%M"))
                    start_ampm_var.set(time_dt.strftime("%p"))
                    
                    # Also set a default end time (2 hours later)
                    end_time_dt = time_dt + timedelta(hours=2)
                    end_hour_var.set(str(int(end_time_dt.strftime("%I"))))
                    end_min_var.set(end_time_dt.strftime("%M"))
                    end_ampm_var.set(end_time_dt.strftime("%p"))
                    
                except Exception as e:
                    print(f"DEBUG: Error auto-populating time: {e}")
                    # Keep default values if there's an error

        if edit_idx is not None:
            old = self.schedule[edit_idx]
            name_entry.insert(0, old[0])
            try:
                from datetime import datetime
                start_dt = datetime.strptime(old[1], "%H:%M")
                end_dt   = datetime.strptime(old[2], "%H:%M")
                
                # Set time fields with leading zeros stripped from hours
                start_hour_var.set(str(int(start_dt.strftime("%I"))))  # Remove leading zero
                start_min_var.set(start_dt.strftime("%M"))
                start_ampm_var.set(start_dt.strftime("%p"))
                end_hour_var.set(str(int(end_dt.strftime("%I"))))      # Remove leading zero  
                end_min_var.set(end_dt.strftime("%M"))
                end_ampm_var.set(end_dt.strftime("%p"))
            except:
                pass
            
            # Extract minutes/text from existing break time
            existing_break = old[3]
            if not existing_break or existing_break == "No Break":
                break_minutes_var.set("0")
            else:
                try:
                    # Check if it's a time range (HH:MM-HH:MM)
                    if "-" in existing_break and ":" in existing_break:
                        from datetime import datetime, timedelta

                        start_str, end_str = existing_break.split("-")
                        start_time = datetime.strptime(start_str.strip(), "%H:%M")
                        end_time = datetime.strptime(end_str.strip(), "%H:%M")

                        # Handle overnight breaks
                        if end_time < start_time:
                            end_time += timedelta(days=1)

                        diff_mins = int((end_time - start_time).total_seconds() / 60)
                        break_minutes_var.set(str(diff_mins if diff_mins > 0 else 0))
                    else:
                        # It's free text, display as-is
                        break_minutes_var.set(existing_break)
                except Exception as e:
                    print(f"DEBUG: Error parsing existing break time '{existing_break}': {e}")
                    break_minutes_var.set(existing_break)  # Fallback: show as-is

            # Force display updates after loading values
            def delayed_update():
                # Only update if we have an end time and minutes
                if end_hour_var.get() and end_min_var.get() and end_ampm_var.get():
                    update_break_display()
                else:
                    # Try again shortly if fields not ready yet
                    popup.after(100, delayed_update)

            popup.after(100, delayed_update)
            popup.after(100, update_duration)
                    

        def save_data():
            from tkinter import messagebox
            from datetime import datetime, timedelta
            import copy

            # Hide suggestions when saving
            hide_suggestions()

            # ================================
            # ADD UNDO BACKUP BEFORE ANY CHANGES
            # ================================
            # Save COMPLETE state before adding/editing (same as delete method)
            state_backup = {
                'schedule': copy.deepcopy(self.schedule),
                'plan_session_names': copy.deepcopy(getattr(self, 'plan_session_names', [])),
                'current_plan_name': getattr(self, 'current_plan_name', 'Default'),
                'plans': copy.deepcopy(getattr(self, 'plans', {}))
            }
            self.undo_stack.append(state_backup)
            self.redo_stack = []  # Clear redo stack when new action is performed
            
            print(f"[ADD/EDIT] Saved state with {len(state_backup['schedule'])} sessions to undo stack")

            # --- read fields ---
            session_name = name_entry.get().strip()
            if not session_name:
                popup.attributes("-topmost", True)
                popup.update()
                messagebox.showerror("Error", "Session name is required.", parent=popup)
                popup.attributes("-topmost", True)
                return

            # --- Get break time in 24h format ---
            input_str = (break_minutes_var.get() or "").strip()

            # Check if input is numeric
            try:
                minutes = int(input_str)
                is_numeric = True
            except ValueError:
                is_numeric = False
                minutes = 0

            if not input_str or (is_numeric and minutes <= 0):
                break_time = "No Break"
            elif not is_numeric:
                # Store free text as-is
                break_time = input_str
            else:
                # Calculate time range for numeric input
                try:
                    end_hour = end_hour_var.get().strip()
                    end_min = end_min_var.get().strip()
                    end_ampm = end_ampm_var.get().strip()

                    if end_hour and end_min and end_ampm:
                        end_hour_int = int(end_hour)
                        if end_ampm == "PM" and end_hour_int != 12:
                            end_hour_int += 12
                        elif end_ampm == "AM" and end_hour_int == 12:
                            end_hour_int = 0

                        end_time = datetime.strptime(f"{end_hour_int:02d}:{end_min}", "%H:%M")
                        break_end_time = end_time + timedelta(minutes=minutes)
                        break_time = f"{end_time.strftime('%H:%M')}-{break_end_time.strftime('%H:%M')}"
                    else:
                        break_time = "No Break"
                except Exception as e:
                    print(f"DEBUG: Break calc failed: {e}")
                    break_time = "No Break"

            # --- Validate start/end ---
            sh = start_hour_var.get().strip()
            sm = start_min_var.get().strip()
            eh = end_hour_var.get().strip()
            em = end_min_var.get().strip()

            if not all([sh, sm, start_ampm_var.get(), eh, em, end_ampm_var.get()]):
                popup.attributes("-topmost", True)
                popup.update()
                messagebox.showerror("Error", "Please fill in all time fields.", parent=popup)
                popup.attributes("-topmost", True)
                return
            try:
                shi = int(sh); smi = int(sm); ehi = int(eh); emi = int(em)
                if not (1 <= shi <= 12 and 1 <= ehi <= 12):
                    raise ValueError
                if not (0 <= smi <= 59 and 0 <= emi <= 59):
                    raise ValueError
            except ValueError:
                popup.attributes("-topmost", True)
                popup.update()
                messagebox.showerror("Error", "Please enter valid numeric values for time.", parent=popup)
                popup.attributes("-topmost", True)
                return

            # --- Convert to 24h ---
            start_24h = time_12h_to_24h(sh, sm, start_ampm_var.get())
            end_24h = time_12h_to_24h(eh, em, end_ampm_var.get())
            
            # --- Check for overlapping sessions (including breaks) ---
            from datetime import datetime

            def to_dt(t):
                return datetime.strptime(t, "%H:%M")

            def parse_break(brk):
                """Return (break_start, break_end) as datetime objects, or None if no break."""
                if not brk or brk == "No Break" or "-" not in brk:
                    return None
                try:
                    bstart, bend = brk.split("-")
                    return (to_dt(bstart.strip()), to_dt(bend.strip()))
                except:
                    return None

            new_start_dt = to_dt(start_24h)
            new_end_dt = to_dt(end_24h)
            new_break = parse_break(break_time)

            for i, sess in enumerate(self.schedule):
                if edit_idx is not None and i == edit_idx:
                    continue  # skip current editing session
                sname, sstart, send, sbrk = sess
                sstart_dt = to_dt(sstart)
                send_dt = to_dt(send)
                s_break = parse_break(sbrk)

                # 1. Check session time overlap
                if (new_start_dt < send_dt) and (new_end_dt > sstart_dt):
                    from tkinter import messagebox
                    # Force messagebox to appear on top of popup
                    popup.lift()
                    popup.attributes("-topmost", True)
                    popup.update()
                    result = messagebox.showerror(
                        "Schedule Conflict",
                        f"'{session_name}' overlaps with '{sname}'!\nPlease adjust the times.", 
                        parent=popup
                    )
                    popup.attributes("-topmost", True)  # Re-enable topmost after messagebox
                    # If validation fails, we should remove the undo backup we just added
                    if self.undo_stack and self.undo_stack[-1] == state_backup:
                        self.undo_stack.pop()
                    return

                # 2. Check new break against other sessions
                if new_break:
                    bstart, bend = new_break
                    if (bstart < send_dt) and (bend > sstart_dt):
                        from tkinter import messagebox
                        popup.attributes("-topmost", True)
                        popup.update()
                        messagebox.showerror(
                            "Schedule Conflict",
                            f"Break for '{session_name}' overlaps with '{sname}'!\nPlease adjust the times.",
                            parent=popup
                        )
                        popup.attributes("-topmost", True)
                        # If validation fails, we should remove the undo backup we just added
                        if self.undo_stack and self.undo_stack[-1] == state_backup:
                            self.undo_stack.pop()
                        return

                # 3. Check other breaks against this session
                if s_break:
                    sbstart, sbend = s_break
                    if (new_start_dt < sbend) and (new_end_dt > sbstart):
                        from tkinter import messagebox
                        popup.attributes("-topmost", True)
                        popup.update()
                        messagebox.showerror(
                            "Schedule Conflict",
                            f"'{session_name}' overlaps with a break in '{sname}'!\nPlease adjust the times.",
                            parent=popup
                        )
                        popup.attributes("-topmost", True)
                        # If validation fails, we should remove the undo backup we just added
                        if self.undo_stack and self.undo_stack[-1] == state_backup:
                            self.undo_stack.pop()
                        return

            cleaned = (session_name, start_24h, end_24h, break_time)
            print("DEBUG CLEANED SESSION:", cleaned)
         
            # ‚úÖ Track if this is a NEW session (not an edit)
            is_new_session = (edit_idx is None)

            # --- Update schedule in memory ---
            if edit_idx is not None:
                print(f"[ADD/EDIT] Editing session at index {edit_idx}")
                self.schedule[edit_idx] = cleaned
                # Update plan_session_names too
                if hasattr(self, 'plan_session_names') and edit_idx < len(self.plan_session_names):
                    self.plan_session_names[edit_idx] = session_name
            else:
                print(f"[ADD/EDIT] Adding new session")
                self.schedule.append(cleaned)
                # Add to plan_session_names too
                if hasattr(self, 'plan_session_names'):
                    self.plan_session_names.append(session_name)

            # --- Sync plan memory BEFORE saving ---
            self.plans[self.current_plan_name] = copy.deepcopy(self.schedule)

            # --- Save everywhere ---
            self.clean_schedule()
            save_schedule(self.schedule)
            save_all_plans(self.plans)
            
            # ‚úÖ ===============================
            # REGISTER SESSION (ONLY IF NEW)
            # ‚úÖ ===============================
            if is_new_session:
                try:
                    current_global_day = self._get_global_study_day()
                    self._register_session_if_not_exists(session_name, current_global_day)
                    print(f"‚úÖ Registered new session: {session_name} on Global Day {current_global_day}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to register session: {e}")
                    # Don't fail the save if registration fails - it's not critical
            else:
                print(f"‚ÑπÔ∏è Skipping registration - editing existing session: {session_name}")

            print(f"[ADD/EDIT] Save completed - schedule now has {len(self.schedule)} sessions")

            # --- UI refresh ---
            try:
                self.refresh_plan_tree()
                tree = getattr(self, "plan_tree", None)
                if tree:
                    for iid in tree.get_children():
                        vals = tree.item(iid, "values")
                        if len(vals) >= 4 and (vals[0], vals[1], vals[2], vals[3]) == cleaned:
                            tree.selection_set(iid)
                            tree.see(iid)
                            break
            except Exception as e:
                print("[SCHEDULE] refresh_plan_tree:", e)

            try:
                self.recompute_required_rates()
            except Exception as e:
                print("[RATE] recompute:", e)

            try:
                if hasattr(self, "refresh_goal_and_markers"):
                    self.refresh_goal_and_markers()
            except Exception as e:
                print("[GOAL] refresh:", e)

            try:
                if on_save:
                    on_save()
            except Exception as e:
                print("[SCHEDULE] on_save:", e)

            popup.destroy()
            if on_save:
                on_save()
            else:
                self.refresh_plan_tree()

        # Action buttons at bottom - Reduced height
        button_frame = tk.Frame(main_frame, bg=BG_COLOR)
        button_frame.pack(fill="x", pady=(8, 5))
        
        # Cancel button - smaller
        cancel_btn = tk.Button(button_frame, text="Cancel", command=on_popup_close,
                              font=("Segoe UI", 10), bg="#ecf0f1", fg=TEXT_DARK,
                              relief="flat", bd=0, padx=20, pady=6, cursor="hand2")
        cancel_btn.pack(side="left", padx=(0, 10))
        
        # Save button with icon - smaller
        save_btn = tk.Button(button_frame, text="‚úì Save Session", command=save_data, 
                            font=("Segoe UI", 10, "bold"), bg=SUCCESS_COLOR, fg="white",
                            relief="flat", bd=0, padx=25, pady=6, cursor="hand2")
        save_btn.pack(side="right")
        
        # Add hover effects
        def on_enter_save(e):
            save_btn['bg'] = '#229954'
        
        def on_leave_save(e):
            save_btn['bg'] = SUCCESS_COLOR
            
        def on_enter_cancel(e):
            cancel_btn['bg'] = '#d5dbdb'
        
        def on_leave_cancel(e):
            cancel_btn['bg'] = '#ecf0f1'
            
        def on_enter_shift(e):
            shift_btn['bg'] = '#2980b9'
        
        def on_leave_shift(e):
            shift_btn['bg'] = ACCENT_COLOR
        
        save_btn.bind("<Enter>", on_enter_save)
        save_btn.bind("<Leave>", on_leave_save)
        cancel_btn.bind("<Enter>", on_enter_cancel)
        cancel_btn.bind("<Leave>", on_leave_cancel)
        shift_btn.bind("<Enter>", on_enter_shift)
        shift_btn.bind("<Leave>", on_leave_shift)

        # Initialize display and focus
        popup.after(100, lambda: [update_duration(), update_break_display()])
        name_entry.focus_set()
        
        # Center the popup on screen
        popup.update_idletasks()
        x = (popup.winfo_screenwidth() // 2) - (popup.winfo_width() // 2)
        y = (popup.winfo_screenheight() // 2) - (popup.winfo_height() // 2) - 30
        popup.geometry(f"+{x}+{y}")
    
    def after_session_change(self):
        self.session_started_flags = [False] * len(self.schedule)
        self.refresh_plan_tree()
        self.setup_live_tab()
        self.setup_wastage_tab()
        self.update_timer()

    def save_alarm_settings(self):
        obj = {"alarm_time": self.alarm_time, "alarm_folder": self.alarm_folder}
        with open(app_paths.alarm_settings_file, "w") as f:
            json.dump(obj, f)

    def load_alarm_settings(self):
        if os.path.exists(app_paths.alarm_settings_file):
            with open(app_paths.alarm_settings_file, "r") as f:
                obj = json.load(f)
            self.alarm_time = obj.get("alarm_time", "")
            self.alarm_folder = obj.get("alarm_folder", "")
        else:
            self.alarm_time = ""
            self.alarm_folder = ""

    def select_alarm_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.alarm_folder = folder
            self.save_alarm_settings()

   
    def set_alarm(self):
        """Show one window with Hour/Minute inputs and AM/PM dropdown plus folder chooser."""
        from tkinter import Toplevel, Label, Entry, Button, filedialog, messagebox, StringVar, ttk

        # Parse last time into hour, minute, and AM/PM
        hour_val, minute_val, ampm_val = "08", "00", "AM"
        if self.alarm_time:
            try:
                import datetime
                parsed = datetime.datetime.strptime(self.alarm_time, "%I:%M %p")
                hour_val = parsed.strftime("%I")
                minute_val = parsed.strftime("%M")
                ampm_val = parsed.strftime("%p")
            except:
                pass

        # Create popup window
        win = Toplevel(self)
        win.title("Set Alarm")
        win.geometry("280x220+{}+{}".format(
            self.winfo_screenwidth() // 2 - 200,
            self.winfo_screenheight() // 2 - 110
        ))
        win.grab_set()  # Make modal

        # ===== Alarm Time Selection =====
        Label(win, text="Alarm Time:", font=("Arial", 11)).pack(pady=(10, 0))

        time_frame = ttk.Frame(win)
        time_frame.pack(pady=5)

        hour_var = StringVar(value=hour_val)
        minute_var = StringVar(value=minute_val)
        ampm_var = StringVar(value=ampm_val)

        hour_entry = Entry(time_frame, width=3, font=("Arial", 11), textvariable=hour_var, justify="center")
        Label(time_frame, text=":", font=("Arial", 11)).pack(side="left", padx=(0, 2))
        minute_entry = Entry(time_frame, width=3, font=("Arial", 11), textvariable=minute_var, justify="center")
        ampm_menu = ttk.Combobox(time_frame, values=["AM", "PM"], textvariable=ampm_var, width=3, state="readonly")

        hour_entry.pack(side="left", padx=2)
        minute_entry.pack(side="left", padx=2)
        ampm_menu.pack(side="left", padx=2)

        # ===== Alarm Folder Selection =====
        Label(win, text="Select Music Folder:", font=("Arial", 11)).pack(pady=(10, 0))
        folder_var = StringVar(value=self.alarm_folder if self.alarm_folder else "No folder selected")
        folder_label = Label(win, textvariable=folder_var, wraplength=300, fg="blue")
        folder_label.pack()

        def choose_folder():
            folder = filedialog.askdirectory(title="Select Alarm Sound Folder")
            if folder:
                self.alarm_folder = folder
                folder_var.set(folder)

        Button(win, text="üìÇ Choose Folder", command=choose_folder).pack(pady=5)

        # ===== Save Button =====
        def save_and_close():
            try:
                h = int(hour_var.get())
                m = int(minute_var.get())
                ap = ampm_var.get()
                if not (1 <= h <= 12 and 0 <= m <= 59):
                    raise ValueError
                if not self.alarm_folder:
                    messagebox.showwarning("Missing Folder", "Please choose a folder!")
                    return
                self.alarm_time = f"{h:02}:{m:02} {ap}"
                self.save_alarm_settings()
                messagebox.showinfo("Alarm Set", f"Alarm set for {self.alarm_time}")
                win.destroy()
            except:
                messagebox.showwarning("Invalid Time", "Please enter a valid time!")

        Button(win, text="Save Alarm", font=("Arial", 11, "bold"), command=save_and_close).pack(pady=10)

    def check_custom_alarm_time(self):
        if not self.alarm_time or not self.alarm_folder:
            self.after(1000, self.check_custom_alarm_time)
            return

        now = datetime.now()
        try:
            target = datetime.strptime(self.alarm_time, "%I:%M %p")
            target = target.replace(year=now.year, month=now.month, day=now.day)
        except Exception:
        # fallback if format error
            self.after(1000, self.check_custom_alarm_time)
            return

    # If the alarm time is right now (+/- 2 seconds)
        if abs((now - target).total_seconds()) < 2 and not self.alarm_playing:
            self.play_alarm_song()
            self.alarm_playing = True  # Set flag so it won't repeat for 2 seconds
    # Reset flag if not in time window
        elif abs((now - target).total_seconds()) > 2:
            self.alarm_playing = False
            self.after(1000, self.check_custom_alarm_time)

    def play_alarm_song(self):
        """Play a random alarm sound and show Stop button in a centered popup."""
        import random
        from tkinter import Toplevel, Button, messagebox

        if not self.alarm_folder:
            messagebox.showwarning("No Folder", "Select a folder with alarm songs first!")
            return

        # Get all audio files
        files = [f for f in os.listdir(self.alarm_folder) if f.lower().endswith(('.mp3', '.wav'))]
        if not files:
            messagebox.showwarning("No Songs", "No MP3/WAV files found in selected folder!")
            return

        # Choose random file
        song_path = os.path.join(self.alarm_folder, random.choice(files))
        try:
            pygame.mixer.init()
            pygame.mixer.music.load(song_path)
            pygame.mixer.music.play(-1)  # Loop until stopped
        except Exception as e:
            messagebox.showwarning("Error", f"Could not play sound: {e}")
            return

        # Create popup window for Stop button
        self.stop_alarm_popup = Toplevel(self)
        self.stop_alarm_popup.title("Alarm")
        self.stop_alarm_popup.geometry("300x150+{}+{}".format(
            self.winfo_screenwidth() // 2 - 150,
            self.winfo_screenheight() // 2 - 75
        ))
        self.stop_alarm_popup.attributes("-topmost", True)  # Keep on top
        self.stop_alarm_popup.grab_set()  # Lock focus

        stop_btn = Button(
            self.stop_alarm_popup,
            text="STOP ALARM",
            font=("Arial", 14, "bold"),
            bg="red",
            fg="white",
            command=self.stop_alarm
        )
        stop_btn.pack(expand=True, fill="both", padx=20, pady=20)
    

    def stop_alarm(self):
        """Stop alarm sound and close popup."""
        try:
            pygame.mixer.music.stop()
        except:
            pass

        if hasattr(self, "stop_alarm_popup") and self.stop_alarm_popup.winfo_exists():
            self.stop_alarm_popup.destroy()
        
    def _handle_midnight_reset_during_pause(self):
        """
        Handle case where midnight reset happens while paused.
        Creates new wastage row for the new day.
        """
        if not getattr(self, "paused", False):
            return
            
        now = datetime.now()
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        if idx is not None and not is_on_break(now, idx, self.schedule):
            session_name = self.schedule[idx][0]
            
            # ‚úÖ KEY FIX: Use TODAY'S date for scheduled start, not original session date
            # For sessions spanning midnight (like 10:15 PM to 1:00 AM), 
            # we need to create new wastage entry for today's date
            today = now.date()
            scheduled_today = datetime.combine(today, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")
            
            # Create wastage row for new day with TODAY'S date
            add_or_update_wastage(session_name, scheduled_today, "PAUSED", 0, missed="No", app=self)
            print(f"[MIDNIGHT] Created new wastage row for {session_name} on {today} after midnight reset")
            
            # Reset pause start time to now (new day)
            self.pause_start = now
            self.pause_start_time = now
            
            # Force refresh of wastage display
            if hasattr(self, "refresh_wastage"):
                self.refresh_wastage()

    def stopwatch_update(self):
        # === INITIALIZE VARIABLES AT THE TOP ===
        if not hasattr(self, "_pause_waste_carry"):
            self._pause_waste_carry = 0.0
        
        now = datetime.now()

        # --- midnight reset ---
        today_str = now.strftime("%Y-%m-%d")
        last_update_date = self.last_study_stopwatch_update.strftime("%Y-%m-%d")
        if today_str != last_update_date:
            # ‚úÖ Save before resetting
            set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=self.current_plan_name)
            self.today_study_stopwatch_seconds = 0
            self._handle_midnight_reset_during_pause()

        elapsed = (now - self.last_study_stopwatch_update).total_seconds()
        self.last_study_stopwatch_update = now

        # --- tick during normal session ---
        if self.stopwatch_running:
            self.today_study_stopwatch_seconds += elapsed
            if time.time() - self.last_stopwatch_disk_write > self.stopwatch_disk_write_interval:
                set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=self.current_plan_name)
                self.last_stopwatch_disk_write = time.time()

        # --- tick during extra study ---
        if getattr(self, "extra_study_running", False):
            self.today_study_stopwatch_seconds += elapsed
            self.pause_credit_seconds += elapsed
            self.update_pause_credit_label()
            if time.time() - self.last_stopwatch_disk_write > self.stopwatch_disk_write_interval:
                set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=self.current_plan_name)
                self.last_stopwatch_disk_write = time.time()

        # === live wastage while PAUSED & inside a session (credit-first) ===
        if getattr(self, "paused", False):
            idx, st_dt, en_dt = get_active_session_idx(self.schedule)
            if idx is not None and not is_on_break(now, idx, self.schedule):
                self._pause_waste_carry += elapsed
                whole = int(self._pause_waste_carry)

                if whole > 0:
                    # üîπ Deduct pause credit first
                    if self.pause_credit_seconds > 0:
                        if whole <= self.pause_credit_seconds:
                            self.pause_credit_seconds -= whole
                            self._pause_waste_carry -= whole
                            self.update_pause_credit_label()
                            whole = 0
                        else:
                            whole -= self.pause_credit_seconds
                            self._pause_waste_carry -= self.pause_credit_seconds
                            self.pause_credit_seconds = 0
                            self.update_pause_credit_label()

                if whole > 0:
                    self._pause_waste_carry -= whole
                    session_name = self.schedule[idx][0]
                    today = now.date()
                    today_key = today.strftime("%Y-%m-%d")
                    scheduled_today = datetime.combine(today, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")

                    # Ensure wastage row exists
                    row_exists = False
                    try:
                        load_wastage_log()
                        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
                        for entry in wastage_log:
                            if (entry.get("Session") == session_name and
                                entry.get("Scheduled Start") == scheduled_today and
                                entry.get("Date") == today_key and
                                entry.get("Missed", "No") == "No"):
                                row_exists = True
                                break
                    except Exception:
                        pass

                    if not row_exists:
                        add_or_update_wastage(session_name, scheduled_today, "PAUSED", 0, missed="No", app=self)
                        print(f"[STOPWATCH] Created missing wastage row for {session_name} on {today_key}")

                    add_or_update_wastage(session_name, scheduled_today, "PAUSED", whole, missed="No", app=self)

        # === WASTAGE TRACKING FOR UNREGISTERED SESSIONS ===
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        if (idx is not None and 
            not getattr(self, "registered", False) and  
            not getattr(self, "paused", False) and     
            not is_on_break(now, idx, self.schedule)):  

            if not hasattr(self, '_unregistered_waste_carry'):
                self._unregistered_waste_carry = 0.0

            self._unregistered_waste_carry += elapsed

            if self._unregistered_waste_carry >= 1.0:
                whole = int(self._unregistered_waste_carry)
                self._unregistered_waste_carry -= whole

                session_name = self.schedule[idx][0]
                today = now.date()
                today_key = today.strftime("%Y-%m-%d")
                scheduled_today = datetime.combine(today, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")

                row_exists = False
                try:
                    load_wastage_log()
                    backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
                    for entry in wastage_log:
                        if (entry.get("Session") == session_name and 
                            entry.get("Scheduled Start") == scheduled_today and 
                            entry.get("Date") == today_key and 
                            entry.get("Missed", "No") == "No"):
                            row_exists = True
                            break
                except Exception:
                    pass

                if not row_exists:
                    add_or_update_wastage(session_name, scheduled_today, "NOT STARTED", 0, missed="No", app=self)
                    print(f"[UNREGISTERED] Created wastage row for {session_name} on {today_key}")

                add_or_update_wastage(session_name, scheduled_today, "NOT STARTED", whole, missed="No", app=self)

        # ======== AUTO-DISABLE EXTRA STUDY BUTTON DURING SESSION ========
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        if hasattr(self, "extra_study_btn"):
            if idx is not None:
                self.extra_study_btn.config(state="disabled")
                if self.extra_study_running:
                    self.toggle_extra_study()
            else:
                self.extra_study_btn.config(state="normal")
        # ================================================================

        # ‚úÖ Update today studied label - PLAN-SPECIFIC
        if hasattr(self, "today_study_label"):
            self.today_study_label.config(
                text=f"Today Studied: {hhmmss_from_seconds(int(self.today_study_stopwatch_seconds))}"
            )

        # ‚úÖ Live update UI elements - PLAN-SPECIFIC
        if hasattr(self, "progress_text_label"):
            self.update_progress_bar(live_today_seconds=int(self.today_study_stopwatch_seconds))
        if hasattr(self, "bar_canvas"):
            self.update_study_bar_chart(live_today_seconds=int(self.today_study_stopwatch_seconds))
        
        # ‚úÖ Total studied label - ALL PLANS
        if hasattr(self, "total_study_label"):
            self._update_total_study_label_live()

        if hasattr(self, "update_wastage_labels"):
            self.update_wastage_labels()

        # schedule next tick
        self.after(1000, self.stopwatch_update)

    def toggle_theme(self):
        self.dark_mode = not self.dark_mode
        self.set_theme(self.dark_mode)

    def set_theme(self, dark):
        if dark:
            bg = "#1a1b1d"
            fg = "#f1f1f1"
            select_bg = "#444857"
            select_fg = "#ffffff"
            tree_style_bg = "#222227"
            tree_style_fg = "#f8f8fa"
            style = ttk.Style()
            style.theme_use('default')
            style.configure(".", background=bg, foreground=fg, fieldbackground=bg)
            style.configure("Treeview", background=tree_style_bg, fieldbackground=tree_style_bg, foreground=tree_style_fg, rowheight=30)
            style.map("Treeview", background=[('selected', select_bg)], foreground=[('selected', select_fg)])
            style.configure("Treeview.Heading", background=bg, foreground="#feb800", font=("Arial", 13, "bold"))
            self.theme_btn.config(text="‚òÄÔ∏è", bg=bg, fg="#fff", activebackground=bg, activeforeground="#feb800")
            self.configure(bg=bg)
            self.alarm_tip.config(bg=bg)
        else:
            bg = "#f4f4f8"
            fg = "#232323"
            select_bg = "#cfe3ff"
            select_fg = "#222"
            tree_style_bg = "#ffffff"
            tree_style_fg = "#232323"
            style = ttk.Style()
            style.theme_use('default')
            style.configure(".", background=bg, foreground=fg, fieldbackground=bg)
            style.configure("Treeview", background=tree_style_bg, fieldbackground=tree_style_bg, foreground=tree_style_fg, rowheight=30)
            style.map("Treeview", background=[('selected', select_bg)], foreground=[('selected', select_fg)])
            style.configure("Treeview.Heading", background="#f0f0f0", foreground="#232323", font=("Arial", 13, "bold"))
            self.theme_btn.config(text="üåô", bg=bg, fg="#232323", activebackground="#e1e2ee", activeforeground="#feb800")
            self.configure(bg=bg)
            self.alarm_tip.config(bg=bg)

    def select_alarm_file(self):
        filetypes = [("WAV files", "*.wav")]
        file = filedialog.askopenfilename(title="Select Alarm Sound", filetypes=filetypes)
        if file:
            self.alarm_file = file
            self.alarm_btn.config(text="üîî‚úÖ")
        else:
            self.alarm_file = None
            self.alarm_btn.config(text="üîî")

    def on_app_close(self):
        import os
        
        # ========== CHECK RESTART FLAG ==========
        restart_flag_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', '.pending_restart')
        
        if os.path.exists(restart_flag_file):
            print("\n" + "="*60)
            print("[CLOSE] ‚ö†‚ö†‚ö† RESTART FLAG DETECTED ‚ö†‚ö†‚ö†")
            print("[CLOSE] SKIPPING ALL BACKUP TO PRESERVE CLOUD DATA")
            print("="*60 + "\n")
            
            # Remove flag
            try:
                os.remove(restart_flag_file)
                print("[CLOSE] Flag removed")
            except Exception as e:
                print(f"[CLOSE] Flag removal error: {e}")
            
            # Hide window
            self.withdraw()
            
            # Save ONLY critical runtime state (not profile/files)
            try:
                if hasattr(self, "state"):
                    save_state(self.state)
                print("[CLOSE] Minimal state saved")
            except Exception as e:
                print(f"[CLOSE] State save error: {e}")
            
            # Exit immediately - NO BACKUP
            print("[CLOSE] Exiting for restore restart...\n")
            self.destroy()
            return  # ‚Üê CRITICAL: Exit here
        
        # ========== NORMAL CLOSE - Continue with your existing code ==========
        now = datetime.now()
        
        # Immediately hide and minimize the window
        self.withdraw()
        
        print(f"[CLOSE] App closing at {now.strftime('%Y-%m-%d %H:%M:%S')}")

        try:
            # Save all local data (fast)
            self.auto_save_profile()

            try:
                self.upload_daily_report_to_firebase()
            except Exception as e:
                print(f"[CLOSE] Report upload skipped: {e}")

            self._save_last_seen(now)
            
            # Finalize elapsed time
            if self.active_session_idx is not None and self.registered and self.elapsed_timer_enabled:
                if not self.paused and not self.remaining_visual_freeze and self.study_active_from:
                    self.study_elapsed_seconds += (now - self.study_active_from).total_seconds()
                    self.study_active_from = now
                self.state["close_time"] = now.isoformat()
                self.state["closed_session_idx"] = self.active_session_idx
            else:
                self.state["close_time"] = None
                self.state["closed_session_idx"] = None

            if self.active_session_idx is not None and self.study_elapsed_seconds > 0:
                prev = get_total_studied_seconds()
                save_total_studied_seconds(prev + int(self.study_elapsed_seconds))

            # Save state
            self.state["elapsed"] = float(self.study_elapsed_seconds)
            self.state["registered"] = bool(self.registered)
            self.state["paused"] = bool(self.paused)
            self.state["active_session_idx"] = self.active_session_idx
            self.state["session_start_datetime"] = self.session_start_datetime.isoformat() if self.session_start_datetime else None
            self.state["session_end_datetime"] = self.session_end_datetime.isoformat() if self.session_end_datetime else None
            self.state["remaining_visual_freeze"] = self.remaining_visual_freeze
            self.state["remaining_visual_frozen_value"] = self.remaining_visual_frozen_value
            self.state["actual_start"] = self.study_active_from.isoformat() if self.study_active_from else None
            self.state["pause_total"] = getattr(self, "pause_total", 0)
            self.state["pause_active"] = getattr(self, "paused", False)
            self.state["pause_start"] = self.pause_start.isoformat() if hasattr(self, "pause_start") and self.pause_start else None
            
            if not hasattr(self, "state") or not isinstance(self.state, dict):
                self.state = load_state()
            self.state["pause_credit_seconds"] = int(getattr(self, "pause_credit_seconds", 0))
            
            save_state(self.state)
            
            # ‚úÖ FIX: Save with plan name
            set_today_studied_elapsed(
                int(getattr(self, "today_study_stopwatch_seconds", 0)),
                plan_name=self.current_plan_name  # ‚úÖ Added this
            )
            
            if hasattr(self, "_save_target_drift_today"):
                self._save_target_drift_today()
            
            print("[CLOSE] Local data saved")
            
        except Exception as e:
            print(f"[CLOSE] Error: {e}")
            import traceback
            traceback.print_exc()
        
        # Cloud backup while hidden
        if self.is_authenticated():
            print("[CLOSE] Starting cloud backup (window hidden)...")
            
            try:
                self.backup_all_files_sync()
                print("[CLOSE] Cloud backup complete")
            except Exception as e:
                print(f"[CLOSE] Cloud backup error: {e}")
        
        # Final cleanup
        try:
            if hasattr(self, 'runrate_graph') and self.runrate_graph:
                self.runrate_graph.save_snapshot_programmatic()
            hide_and_protect_files()
        except:
            pass
        
        print("[CLOSE] Destroying window")
        self.destroy()

    def restore_or_init_session(self):
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        self.active_session_idx = idx
        self.session_start_datetime = st_dt
        self.session_end_datetime = en_dt
        self.study_elapsed_seconds = 0.0
        self.registered = False
        self.paused = False
        self.elapsed_timer_enabled = False
        self.remaining_visual_freeze = False
        self.remaining_visual_frozen_value = None

        prev_state = self.state
        self.state = {}
        if idx is not None:
            log_skipped_sessions(self.schedule, app=self)
            if (
                prev_state.get("active_session_idx") == idx and
                prev_state.get("session_start_datetime") == (self.session_start_datetime.isoformat() if self.session_start_datetime else None) and
                prev_state.get("session_end_datetime") == (self.session_end_datetime.isoformat() if self.session_end_datetime else None)
            ):
                self.study_elapsed_seconds = prev_state.get("elapsed", 0.0)
                self.registered = prev_state.get("registered", False)
                self.paused = prev_state.get("paused", False)
                self.elapsed_timer_enabled = self.registered
                self.remaining_visual_freeze = prev_state.get("remaining_visual_freeze", False)
                self.remaining_visual_frozen_value = prev_state.get("remaining_visual_frozen_value", None)
                close_time = prev_state.get("close_time")
                closed_idx = prev_state.get("closed_session_idx")
                if (
                    self.registered and self.elapsed_timer_enabled and not self.paused and
                    close_time and closed_idx == idx
                ):
                    closed_at = datetime.fromisoformat(close_time)
                    now = datetime.now()
                    if closed_at < now < self.session_end_datetime:
                        dt = (now - closed_at).total_seconds()
                        scheduled = self.session_start_datetime.strftime("%d-%b-%Y %I:%M %p")
                        actual = f"{closed_at.strftime('%I:%M %p')} (reopen: {now.strftime('%I:%M %p')})"
                        add_or_update_wastage(self.schedule[idx][0], scheduled, actual, int(dt), app=self)
                if self.registered and self.elapsed_timer_enabled and not self.paused:
                    self.study_active_from = datetime.now()
            self.display_session(idx)
        else:
            self.display_no_active_session()
            
            

    def setup_plan_tab(self):
        from datetime import datetime, date, timedelta
        
        # ‚úÖ IMPORTANT: Clear the plan_tab completely first
        for widget in self.plan_tab.winfo_children():
            widget.destroy()
        
        # ‚úÖ CREATE A DEDICATED CONTAINER FOR TREEVIEW/SPLASH AREA
        # This container will hold EITHER the treeview OR the splash
        self.treeview_container = tk.Frame(self.plan_tab)
        self.treeview_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # ‚úÖ Check if schedule is empty - show splash IN THE CONTAINER
        if not self.schedule or len(self.schedule) == 0:
            self._show_plan_splash_in_tree_area()
            # DON'T RETURN - continue to create buttons below
        else:
            # ‚úÖ Create treeview IN THE CONTAINER
            self._create_plan_treeview()
        
        # ‚úÖ ALWAYS CREATE BUTTONS (shown below treeview/splash)
        self._create_plan_buttons()
        
        # ‚úÖ ALWAYS CREATE COMMUNICATION SECTION (shown below buttons)
        self._create_communication_section()
        
    def _create_plan_treeview(self):
        """Create the treeview inside self.treeview_container"""
        from datetime import datetime, date, timedelta
        
        # === YOUR EXISTING TREEVIEW CREATION CODE ===
        self.plan_session_names = [sess[0] for sess in self.schedule]
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Arial", 13, "bold"))
        style.map("Treeview", background=[("selected", "#d0e6ff")])
        style.configure("current_session.Treeview", background="#5faaff", foreground="white")
        
        total_minutes = 0
        for sess in self.schedule:
            if isinstance(sess, (list, tuple)) and len(sess) >= 3:
                start = parse_time(sess[1])
                end = parse_time(sess[2])
                if start and end:
                    st_dt = datetime.combine(date.today(), start)
                    en_dt = datetime.combine(date.today(), end)
                    if en_dt <= st_dt:
                        en_dt += timedelta(days=1)
                    total_minutes += int((en_dt - st_dt).total_seconds() // 60)
        
        total_hours = total_minutes // 60
        total_rem_min = total_minutes % 60
        duration_col_name = f"Duration ({total_hours:02}:{total_rem_min:02})"
        
        cols = ("Session", "Study Material", "Start Time", "End Time", duration_col_name, "Break Time")
        
        # ‚úÖ IMPORTANT: Parent is self.treeview_container (not self.plan_tab)
        self.plan_tree = ttk.Treeview(
            self.treeview_container,  # ‚úÖ Changed from self.plan_tab
            columns=cols,
            show="headings",
            height=11,
            selectmode="extended"
        )
        self.plan_tree.bind("<<TreeviewSelect>>", self.on_plan_row_select)
        self.plan_tree.bind("<Delete>", lambda e: self.delete_session())
        self.plan_tree.bind("<Double-Button-1>", self.on_study_material_click)
        
        self.plan_tree.column("Session", width=200, anchor="w")
        self.plan_tree.column("Study Material", width=100, anchor="center")
        self.plan_tree.column("Start Time", width=100, anchor="center")
        self.plan_tree.column("End Time", width=100, anchor="center")
        self.plan_tree.column(duration_col_name, width=120, anchor="center")
        self.plan_tree.column("Break Time", width=150, anchor="center")
        
        self.plan_tree.heading("Session", text="Session")
        self.plan_tree.heading("Study Material", text="üìö Material")
        self.plan_tree.heading("Start Time", text="Start Time")
        self.plan_tree.heading("End Time", text="End Time")
        self.plan_tree.heading(duration_col_name, text=duration_col_name)
        self.plan_tree.heading("Break Time", text="Break Time")
        
        self.plan_tree.pack(fill=tk.BOTH, expand=True)

        # ================================
        # üî• Unified Mouse Event Handling
        # ================================
        self.drag_selecting = False
        self.drag_start_y = None
        self.last_motion_y = None
        self.dragged_row = None
        self.drag_start_time = None
        self.is_dragging_row = False
        self.click_start_x = None
        self.click_start_y = None
        self.selection_rectangle = None

        def unified_button_press(event):
            """Unified handler for mouse press - handles both selection and drag-drop."""
            import time
            tree = self.plan_tree
            
            self.drag_start_time = time.time()
            self.drag_start_y = event.y
            self.click_start_x = event.x
            self.click_start_y = event.y
            self.last_motion_y = event.y
            
            item = tree.identify('item', event.x, event.y)
            region = tree.identify('region', event.x, event.y)
            
            if item and region in ('cell', 'tree'):
                self.dragged_row = item
                self.is_dragging_row = False
                self.drag_selecting = False
            else:
                self.dragged_row = None
                self.is_dragging_row = False
                self.drag_selecting = True
                tree.selection_remove(tree.selection())
                tree.focus('')
                print(f"Starting drag selection at ({event.x}, {event.y})")
                self.create_selection_rectangle(event.x, event.y)
                return "break"

        def unified_motion(event):
            """Unified handler for mouse motion - handles both selection and drag-drop."""
            import time
            tree = self.plan_tree
            
            if not hasattr(self, 'drag_start_time') or self.drag_start_time is None:
                return
            
            motion_distance = abs(event.y - self.drag_start_y)
            time_elapsed = time.time() - self.drag_start_time
            
            if motion_distance > 5 or time_elapsed > 0.3:
                if self.dragged_row and not self.drag_selecting:
                    self.is_dragging_row = True
                    mock_event = type('MockEvent', (), {
                        'x': event.x, 
                        'y': event.y,
                        'widget': event.widget
                    })
                    if hasattr(self, 'on_drag_motion'):
                        self.on_drag_motion(mock_event)
                    
                elif self.drag_selecting:
                    self.last_motion_y = event.y
                    
                    print(f"Updating drag selection to ({event.x}, {event.y})")
                    self.update_selection_rectangle(event.x, event.y)
                    
                    start_y = min(self.drag_start_y, event.y)
                    end_y = max(self.drag_start_y, event.y)
                    
                    all_items = tree.get_children()
                    selected_items = []
                    
                    for item in all_items:
                        try:
                            bbox = tree.bbox(item)
                            if bbox:
                                item_top = bbox[1]
                                item_bottom = bbox[1] + bbox[3]
                                item_center = bbox[1] + bbox[3] // 2
                                
                                if (start_y <= item_center <= end_y or 
                                    start_y <= item_top <= end_y or 
                                    start_y <= item_bottom <= end_y or
                                    (item_top <= start_y and item_bottom >= end_y)):
                                    selected_items.append(item)
                        except:
                            continue
                    
                    tree.selection_set(selected_items)

        def unified_button_release(event):
            """Unified handler for mouse release."""
            tree = self.plan_tree
            
            if self.is_dragging_row and self.dragged_row:
                if hasattr(self, 'on_drag_drop'):
                    self.on_drag_drop(event)
                    
            elif self.drag_selecting:
                motion_distance = abs(event.y - self.drag_start_y) if self.drag_start_y else 0
                
                if motion_distance < 5:
                    tree.selection_remove(tree.selection())
                    tree.focus('')
            
            print("Ending drag selection")
            self.remove_selection_rectangle()
            
            if self.dragged_row and hasattr(self, 'on_drag_start'):
                mock_event = type('MockEvent', (), {
                    'x': self.click_start_x, 
                    'y': self.click_start_y,
                    'widget': event.widget
                })
                motion_distance = abs(event.y - self.drag_start_y) if self.drag_start_y else 0
                if motion_distance < 3:
                    self.on_drag_start(mock_event)
            
            self.drag_selecting = False
            self.drag_start_y = None
            self.last_motion_y = None
            self.dragged_row = None
            self.drag_start_time = None
            self.is_dragging_row = False
            self.click_start_x = None
            self.click_start_y = None

        self.plan_tree.bind("<ButtonPress-1>", unified_button_press)
        self.plan_tree.bind("<B1-Motion>", unified_motion) 
        self.plan_tree.bind("<ButtonRelease-1>", unified_button_release)

        def parent_click_handler(event):
            """Handle clicks on parent container."""
            tree = self.plan_tree
            
            tree_x = event.x - tree.winfo_x()
            tree_y = event.y - tree.winfo_y()
            
            if (tree_x < 0 or tree_x > tree.winfo_width() or 
                tree_y < 0 or tree_y > tree.winfo_height()):
                tree.selection_remove(tree.selection())
                tree.focus('')
            elif tree_y > 0 and tree_x > 0:
                try:
                    item = tree.identify('item', tree_x, tree_y)
                    region = tree.identify('region', tree_x, tree_y)
                    if not item or region == '':
                        tree.selection_remove(tree.selection())
                        tree.focus('')
                except:
                    tree.selection_remove(tree.selection())
                    tree.focus('')

        self.plan_tab.bind("<Button-1>", parent_click_handler, add="+")

        self.selection_overlay = None

        for c in cols:
            self.plan_tree.heading(c, text=c)
            self.plan_tree.column(c, anchor=tk.CENTER, width=130 if c != "Session" else 180)

        self.plan_rows = []
        self.refresh_plan_tree()
        
    def _format_plan_button_label(self, plan_name: str) -> str:
        """
        Show a compact label like 'Aptitude an‚Ä¶ ‚ñº' with the name centered when short
        and the ‚ñº pinned to the right edge of the fixed-width button.
        """
        if not plan_name:
            plan_name = "Default Plan"

        total_width = getattr(self, "plan_button_char_width", 15)
        arrow = " ‚ñº"
        name_space = max(total_width - len(arrow), 1)

        safe_name = str(plan_name)
        if len(safe_name) > name_space:
            safe_name = safe_name[: max(name_space - 1, 1)] + "‚Ä¶"

        if len(safe_name) < name_space:
            left_pad = (name_space - len(safe_name)) // 2
            right_pad = name_space - len(safe_name) - left_pad
        else:
            left_pad = right_pad = 0

        return f"{' ' * left_pad}{safe_name}{' ' * right_pad}{arrow}"
        
    def _create_plan_buttons(self):
        """Create the button frame (always shown below treeview/splash)"""
        # Button frame
        btn_frame = tk.Frame(self.plan_tab)
        btn_frame.pack(pady=(3, 8))
        self.plan_button_frame = btn_frame
        btn_style = {"font": ("Arial", 12), "width": 2, "height": 1}

        # Plan selector button
        self.current_plan_name = getattr(self, "current_plan_name", "Default")
        self.plan_var = tk.StringVar(value=self.current_plan_name)

        button_text = self._format_plan_button_label(self.current_plan_name)

        self.plan_button_char_width = 15
        self.plan_display_btn = tk.Button(
            btn_frame,
            text=button_text,
            font=("Segoe UI", 9),
            bg="white",
            relief="solid",
            bd=1,
            padx=10,
            pady=4,
            cursor="hand2",
            width=self.plan_button_char_width,
            anchor="w",  # left align; spacing is handled in text formatting
        )
        self.plan_display_btn.pack(side="left", padx=5)
        self.plan_display_btn.config(command=self.show_plan_menu)

        # Place/update the exam pill next to the plan dropdown
        self._init_exam_header_on_tabs()

        self.new_plan_btn = tk.Button(
            btn_frame, text="üÜï", command=self.create_new_plan, **btn_style
        )
        self.new_plan_btn.pack(side="left", padx=7)
        self.add_hover_effect(self.new_plan_btn, hover_bg="#E0E0E0")
        ToolTip(self.new_plan_btn, "Create New Plan")

        self.undo_btn = tk.Button(btn_frame, text="‚Ü©", command=self.undo_last_action, **btn_style)
        self.redo_btn = tk.Button(btn_frame, text="‚Ü™", command=self.redo_last_action, **btn_style)
        self.add_btn = tk.Button(btn_frame, text="‚ûï", command=self.add_session, **btn_style)
        self.plan_edit_btn = tk.Button(btn_frame, text="üñâ", command=self.edit_session, **btn_style)
        self.delete_btn = tk.Button(btn_frame, text="üóë", command=self.delete_session, **btn_style)
        self.history_btn = tk.Button(btn_frame, text="üìñ", command=self.show_session_history, **btn_style)

        self.undo_btn.pack(side="left", padx=7)
        self.redo_btn.pack(side="left", padx=7)
        self.add_btn.pack(side="left", padx=7)
        self.plan_edit_btn.pack(side="left", padx=7)
        self.delete_btn.pack(side="left", padx=7)
        self.history_btn.pack(side="left", padx=10, pady=5)

        self.add_hover_effect(self.undo_btn, hover_bg="#E0E0E0")
        self.add_hover_effect(self.redo_btn, hover_bg="#E0E0E0")
        self.add_hover_effect(self.add_btn, hover_bg="#D4EDDA")
        self.add_hover_effect(self.plan_edit_btn, hover_bg="#FFF3CD")
        self.add_hover_effect(self.delete_btn, hover_bg="#F8D7DA")
        self.add_hover_effect(self.history_btn, hover_bg="#D1ECF1")

        ToolTip(self.undo_btn, "Undo Last Action")
        ToolTip(self.redo_btn, "Redo Last Action")
        ToolTip(self.add_btn, "Add Session")
        ToolTip(self.plan_edit_btn, "Edit Session")
        ToolTip(self.delete_btn, "Delete Session")
        ToolTip(self.history_btn, "Session History")
        
        def handle_keyboard_undo(event):
            try:
                self.undo_last_action()
                return "break"
            except Exception as e:
                print(f"[KEYBOARD] Error in undo: {e}")
                return "break"

        def handle_keyboard_redo(event):
            try:
                self.redo_last_action()
                return "break"
            except Exception as e:
                print(f"[KEYBOARD] Error in redo: {e}")
                return "break"

        self.bind_all("<Control-z>", handle_keyboard_undo)
        self.bind_all("<Control-y>", handle_keyboard_redo)
        self.bind_all("<Control-Shift-Z>", handle_keyboard_redo)

        try:
            self.bind_all("<Command-z>", handle_keyboard_undo)
            self.bind_all("<Command-y>", handle_keyboard_redo)
            self.bind_all("<Command-Shift-z>", handle_keyboard_redo)
        except:
            pass

        print("[KEYBOARD] Undo/Redo keyboard shortcuts activated")
        
    def _create_communication_section(self):
        """Create communication settings section (always shown below buttons)"""
        
        # COMMUNICATION SETTINGS SECTION
        ttk.Separator(self.plan_tab, orient="horizontal").pack(fill="x", padx=10, pady=(10, 5))

        # ‚úÖ Token usage display WITH Buy Tokens button on the same row
        token_row_frame = tk.Frame(self.plan_tab)
        token_row_frame.pack(pady=(5, 5))
        
        # Token usage widget on the left
        self.token_widget = create_token_usage_widget(token_row_frame)
        self.token_widget.pack(side="left", padx=(0, 10))
        set_refresh_callback(self.refresh_token_usage_display)

        # Buy Tokens button
        self.buy_tokens_btn = tk.Button(
            token_row_frame,
            text="üí≥ Buy Tokens",
            command=self.show_purchase_dialog,
            font=("Arial", 10, "bold"),
            bg="#4CAF50", fg="white",
            width=15
        )
        self.buy_tokens_btn.pack(side="left", padx=(0, 10))
        if hasattr(self, 'add_hover_effect'):
            self.add_hover_effect(self.buy_tokens_btn, 
                                 hover_bg="#45a049", hover_fg="white",
                                 normal_bg="#4CAF50", normal_fg="white")
        
       
        # Section title
        comm_title = tk.Label(self.plan_tab, text="üì± Daily Report Settings", 
                             font=("Arial", 12, "bold"), fg="#2c3e50")
        comm_title.pack(pady=(5, 8))
        
        # TELEGRAM SETTINGS
        telegram_frame = tk.Frame(self.plan_tab)
        telegram_frame.pack(pady=5)

        self.telegram_btn = tk.Button(
            telegram_frame,
            text="Connect Telegram",
            command=self._open_telegram_with_premium_check,
            font=("Arial", 10),
            bg="#0088cc",
            fg="white",
            width=20
        )
        self.telegram_btn.pack(side="left", padx=5)
        self.add_hover_effect(self.telegram_btn, hover_bg="#006ba3", hover_fg="white", 
                             normal_bg="#0088cc", normal_fg="white")

        self.test_telegram_btn = tk.Button(
            telegram_frame, 
            text="Test Telegram", 
            command=lambda: self.send_telegram("üîî Test notification from StudyTimer!")
        )
        self.test_telegram_btn.pack(side="left", padx=7)
        self.add_hover_effect(self.test_telegram_btn, hover_bg="#E0E0E0")

        telegram_status_label = tk.Label(
            telegram_frame,
            text="Not Configured",
            font=("Arial", 10),
            fg="red"
        )
        telegram_status_label.pack(side="left", padx=10)

        prof = _load_profile()
        if prof.get("telegram_chat_id"):
            telegram_status_label.config(text="Configured", fg="green")

        # EMAIL SETTINGS
        email_frame = tk.Frame(self.plan_tab, relief="flat", bd=0)
        email_frame.pack(pady=10)

        self.email_btn = tk.Button(email_frame, text="üìß Setup Email Reports", 
                     command=self.setup_simple_email_recipients_with_premium_check,
                     font=("Arial", 11, "bold"), bg="#4CAF50", fg="white", 
                     width=25, height=2)
        self.email_btn.pack(side=tk.LEFT, padx=5)

        if hasattr(self, 'add_hover_effect'):
            self.add_hover_effect(self.email_btn, hover_bg="#45a049", hover_fg="white", 
                                 normal_bg="#4CAF50", normal_fg="white")

        # Right side frame for referral
        right_frame = tk.Frame(email_frame, relief="flat", bd=0)
        right_frame.pack(side=tk.RIGHT, padx=5)

        self.referral_btn = tk.Button(right_frame, text="üéÅ Join Referral Program",
                                    command=self.join_referral_program,
                                    font=("Arial", 11, "bold"), bg="#FF9800", fg="white", 
                                    width=25, height=2)
        self.referral_btn.pack(side=tk.LEFT)

        if hasattr(self, 'add_hover_effect'):
            self.add_hover_effect(self.referral_btn, hover_bg="#F57C00", hover_fg="white",
                                normal_bg="#FF9800", normal_fg="white")

        # Get referral stats
        import os
        from dotenv import load_dotenv
        from cryptography.fernet import Fernet
        import gspread
        import json

        total_installs = "0"
        total_subscriptions = "0" 
        total_earnings = "0"

        try:
            referral_sheet_id = get_secret("LB_SHEET_ID")
            referral_worksheet = get_secret("REFERRAL_WORKSHEET") or "referral_program"
            
            load_dotenv()
            encryption_key = get_secret('ENCRYPTION_KEY')
            encrypted_creds = get_secret('ENCRYPTED_CREDENTIALS')
            
            fernet = Fernet(encryption_key.encode())
            decrypted_creds = fernet.decrypt(encrypted_creds.encode()).decode()
            creds_dict = json.loads(decrypted_creds)
            
            gc = gspread_client
            sheet = gc.open_by_key(referral_sheet_id)
            worksheet = sheet.worksheet(referral_worksheet)
            all_records = worksheet.get_all_values()
            
            if len(all_records) > 1:
                installs_sum = 0
                subs_sum = 0
                earnings_sum = 0
                
                for i, row in enumerate(all_records[1:], 1):
                    if len(row) > 16:
                        if row[12] and row[12].strip().isdigit():
                            installs_sum += int(row[12])
                        
                        if row[14] and row[14].strip().isdigit():
                            subs_sum += int(row[14])
                        
                        if row[16] and row[16].strip():
                            earnings_str = str(row[16]).replace('‚Çπ', '').replace(',', '').strip()
                            if earnings_str and (earnings_str.isdigit() or earnings_str.replace('.', '').isdigit()):
                                earnings_sum += float(earnings_str)
                
                total_installs = str(installs_sum)
                total_subscriptions = str(subs_sum)
                total_earnings = str(int(earnings_sum))
                
        except Exception as e:
            print(f"üîç REFERRAL_STATS_DEBUG: Error: {e}")
            total_installs = "--"
            total_subscriptions = "--"
            total_earnings = "--"

        # Stats labels
        stats_frame = tk.Frame(right_frame, relief="flat", bd=0)
        stats_frame.pack(side=tk.RIGHT, padx=(10, 0))

        tk.Label(stats_frame, text=f"Install: {total_installs}", 
                font=("Arial", 7), fg="#333", relief="flat", bd=0).pack(anchor="w")

        tk.Label(stats_frame, text=f"Subscription: {total_subscriptions}", 
                font=("Arial", 7), fg="#333", relief="flat", bd=0).pack(anchor="w")

        tk.Label(stats_frame, text=f"Total reward: ‚Çπ{total_earnings}", 
                font=("Arial", 7, "bold"), fg="#4CAF50", relief="flat", bd=0).pack(anchor="w")
        
        # Email status
        recipient_count = len(self.config.get("recipient_emails", []))
        email_enabled = self.config.get("email_enabled", False)
        
        if email_enabled and recipient_count > 0:
            status_text = f"‚úÖ Email reports enabled ({recipient_count} recipients)"
            status_color = "green"
        elif recipient_count > 0:
            status_text = f"üìß {recipient_count} recipients added (reports disabled)"
            status_color = "orange"
        else:
            status_text = "üìß No email recipients configured"
            status_color = "gray"
        
        status_label = tk.Label(email_frame, text=status_text, font=("Arial", 9), fg=status_color)
        status_label.pack(pady=5)

        # INFO
        info_frame = tk.Frame(self.plan_tab)
        info_frame.pack(pady=10)
        
        info_text = "‚Ñπ Reports are automatically sent daily at 11:59 PM via configured channels"
        info_label = tk.Label(info_frame, text=info_text, 
                             font=("Arial", 9), fg="#666666", wraplength=500)
        info_label.pack()
        
        self.after(400, self.disable_communication_features_for_non_premium)
        
        
    # ================================
    # üé® Visual Selection Rectangle Methods
    # ================================

    def create_selection_rectangle(self, x, y):
        """Create a visual selection rectangle overlay using a simple approach."""
        try:
            # Remove any existing rectangle
            self.remove_selection_rectangle()
            
            print(f"Creating selection rectangle at ({x}, {y})")
            
            # Get the tree widget's absolute screen position
            tree_root_x = self.plan_tree.winfo_rootx()
            tree_root_y = self.plan_tree.winfo_rooty()
            
            # Create a simple toplevel window as overlay
            self.selection_overlay = tk.Toplevel(self)
            self.selection_overlay.withdraw()  # Hide initially
            self.selection_overlay.overrideredirect(True)  # No window decorations
            self.selection_overlay.attributes('-alpha', 0.3)  # Semi-transparent
            self.selection_overlay.attributes('-topmost', True)  # Always on top
            
            # Set background color to light blue with border
            self.selection_overlay.configure(bg='#87CEEB')
            
            # Add a visible border by creating a frame inside
            border_frame = tk.Frame(self.selection_overlay, bg='#0078d4', bd=1, relief='solid')
            border_frame.pack(fill='both', expand=True)
            
            # Position relative to the treeview widget
            screen_x = tree_root_x + x
            screen_y = tree_root_y + y
            
            self.selection_overlay.geometry(f"5x5+{screen_x}+{screen_y}")
            self.selection_overlay.deiconify()  # Show it
            
            print(f"Created selection overlay at screen position ({screen_x}, {screen_y})")
            
        except Exception as e:
            print(f"Error creating selection rectangle: {e}")
            import traceback
            traceback.print_exc()

    def update_selection_rectangle(self, x, y):
        """Update the visual selection rectangle with throttling to prevent bouncing."""
        try:
            if not hasattr(self, 'selection_overlay') or not self.selection_overlay:
                return
                
            # Throttle updates to reduce bouncing effect
            import time
            current_time = time.time()
            if hasattr(self, '_last_rect_update') and current_time - self._last_rect_update < 0.02:  # 50fps max
                return
            self._last_rect_update = current_time
            
            # Calculate rectangle bounds
            start_x = self.click_start_x
            start_y = self.click_start_y
            
            left = min(start_x, x)
            top = min(start_y, y) 
            width = max(abs(x - start_x), 5)  # Minimum width of 5
            height = max(abs(y - start_y), 5)  # Minimum height of 5
            
            # Cache the tree coordinates to avoid multiple winfo calls
            if not hasattr(self, '_tree_root_cache') or current_time - getattr(self, '_tree_cache_time', 0) > 0.1:
                self._tree_root_cache = (self.plan_tree.winfo_rootx(), self.plan_tree.winfo_rooty())
                self._tree_cache_time = current_time
            
            tree_root_x, tree_root_y = self._tree_root_cache
            screen_x = tree_root_x + left
            screen_y = tree_root_y + top
            
            # Use a single geometry call with proper formatting
            geometry_str = f"{width}x{height}+{screen_x}+{screen_y}"
            
            # Only update if the geometry actually changed
            if not hasattr(self, '_last_geometry') or self._last_geometry != geometry_str:
                self.selection_overlay.geometry(geometry_str)
                self._last_geometry = geometry_str
                
        except Exception as e:
            print(f"Error updating selection rectangle: {e}")

    def remove_selection_rectangle(self):
        """Remove the visual selection rectangle."""
        try:
            if hasattr(self, 'selection_overlay') and self.selection_overlay:
                self.selection_overlay.destroy()
                self.selection_overlay = None
                print("Removed selection rectangle")
        except Exception as e:
            print(f"Error removing selection rectangle: {e}")

    def setup_live_tab(self):   
        if hasattr(self, 'live_frame') and self.live_frame.winfo_exists():
            self.live_frame.destroy()        
        self.live_frame = ttk.Frame(self.live_tab)
        self.live_frame.pack(expand=True, fill="both")
        self.live_frame.update_idletasks()
        # ======= TRIAL VALIDATION =======
        # Load user profile from file and check trial status
        user_profile = {}
        profile_exists = False
        try:
            # Load user profile from the AppData Roaming location
            app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
            profile_file = os.path.join(app_data_dir, "profile.json")
            
            # ‚úÖ ADD THIS - Check if profile was just restored
            if hasattr(self, '_profile_restored_flag') and self._profile_restored_flag:
                print("[LIVE] Profile was restored from cloud - forcing fresh load")
                self._profile_restored_flag = False  # Reset flag
                
                # Give filesystem a moment to settle
                import time
                time.sleep(0.1)
            
            if os.path.exists(profile_file):
                with open(profile_file, 'r') as f:
                    user_profile = json.load(f)
                profile_exists = True
                
                # ‚úÖ ADD THIS - Better debug output
                user_name = user_profile.get('user_name', 'Unknown')
                user_email = user_profile.get('user_email', 'Not set')
                trial_start = user_profile.get('trial_start_date', 'Not set')
                
                print(f"[LIVE] Loaded user profile:")
                print(f"  Name: {user_name}")
                print(f"  Email: {user_email}")
                print(f"  Trial start: {trial_start}")
                print(f"  Profile keys: {list(user_profile.keys())}")
            else:
                print(f"[LIVE] No profile file found at: {profile_file}")
                profile_exists = False
        except Exception as e:
            print(f"[LIVE] Error loading profile: {e}")
            import traceback
            traceback.print_exc()
            user_profile = {}
            profile_exists = False

        # Check trial status and license status
        trial_status, trial_message, days_remaining = 'no_trial', 'No trial manager', 0
        license_valid, license_message = False, 'No license manager'

        if self.trial_manager:
            try:
                trial_status, trial_message, days_remaining = self.trial_manager.validate_trial(user_profile)
                print(f"[LIVE] Trial status: {trial_status}, Message: {trial_message}, Days remaining: {days_remaining}")
            except Exception as e:
                print(f"[LIVE] Trial validation error: {e}")
                trial_status = 'error'

        if self.license_manager:
            try:
                # Use the comprehensive_validation method from UnifiedLicenseManager
                license_valid, license_message = self.license_manager.comprehensive_validation(user_profile)
                print(f"[LIVE] License valid: {license_valid}, Message: {license_message}")
                # ‚úÖ NEW: Treat first-time user as no license (but not blocked)
                if license_message == "first_time_user":
                    license_valid = False
                    print("[LIVE] First-time user detected")
            except Exception as e:
                print(f"[LIVE] License validation error: {e}")
                license_valid, license_message = False, str(e)

        # MODIFIED LOGIC: Show premium features based on trial and license status
        show_premium_features = False

        if license_valid:
            # Valid license - always show
            show_premium_features = True
            print(f"[LIVE] License valid - showing premium features")

        elif license_message == "first_time_user" or trial_status == 'no_trial':
            # First-time user OR no trial yet - SHOW features (they'll get trial popup)
            show_premium_features = True
            print(f"[LIVE] First-time user / No trial yet - showing features (trial popup will appear)")

        elif trial_status == 'valid':
            # Active trial - show features
            show_premium_features = True
            print(f"[LIVE] Trial valid ({days_remaining} days remaining) - showing premium features")

        elif trial_status == 'expired':
            # Trial expired - hide features
            show_premium_features = False
            print(f"[LIVE] Trial expired - hiding premium features")

        elif trial_status == 'tampered':
            # Tampering detected - hide features
            show_premium_features = False
            print(f"[LIVE] Tampering detected - hiding premium features")

        else:
            # Any other case - hide features
            show_premium_features = False
            print(f"[LIVE] Unknown state (status: {trial_status}) - hiding premium features")

        print(f"[LIVE] Final decision - Show premium features: {show_premium_features}")
        print(f"[LIVE] Profile exists: {profile_exists}, Trial status: {trial_status}, License valid: {license_valid}")
        # ‚úÖ CREATE FIREBASE SYNC INSTANCE BEFORE CREATING WIDGETS
        print("[LIVE TAB DEBUG] Creating FirebaseSync instance...")
        try:
            if not hasattr(self, 'firebase_sync') or self.firebase_sync is None:
                self.firebase_sync = FirebaseSync(
                    profile_loader=_load_profile,     # Your existing function
                    profile_saver=_save_profile,      # Your existing function
                    database_url=FIREBASE_DATABASE_URL,
                    service_account_path=FIREBASE_SERVICE_ACCOUNT
                )
                print("[LIVE TAB DEBUG] ‚úÖ FirebaseSync created successfully")
            else:
                print("[LIVE TAB DEBUG] FirebaseSync already exists, reusing")
        except Exception as e:
            print(f"[LIVE TAB DEBUG] ‚ùå Error creating FirebaseSync: {e}")
            import traceback
            traceback.print_exc()
            
        # ======= LEADERBOARD OVERLAYS =======
        LB_LEFT  = {"x": 14, "y": 120, "w": 500, "h": 380}
        LB_RIGHT = {"relx": 1.0, "x": -350, "y": 120, "w": 240, "h": 240}

        
        LB_SHEET_ID    = get_secret("LB_SHEET_ID")
        LB_WORKSHEET   = "Sheet1"

        print("="*60)
        print("[LIVE TAB DEBUG] Starting leaderboard widget creation")
        print(f"[LIVE TAB DEBUG] show_premium_features = {show_premium_features}")
        print("="*60)
        
        # Create/position widgets (overlay)
        try:
            print("[LIVE TAB DEBUG] Inside try block - creating leaderboard table...")
            shrink_px = int(self.live_frame.winfo_fpixels("3c"))
            LB_LEFT_W = max(320, LB_LEFT["w"] - shrink_px)
            extra_h = int(self.live_frame.winfo_fpixels("2c"))
            LB_LEFT_H = LB_LEFT["h"] + extra_h
            
            self.lb_table = LeaderboardTablePanel(
                self.live_frame,
                database_url=FIREBASE_DATABASE_URL,
                service_account_path=FIREBASE_SERVICE_ACCOUNT,
                width=LB_LEFT_W, height=LB_LEFT_H, show_rows=10, 
                title_text="Leaderboard",
                poll_seconds=60
            )
            self.lb_table.place(x=LB_LEFT["x"], y=LB_LEFT["y"], 
                                width=LB_LEFT_W, height=LB_LEFT_H)
            self.lb_table.lift()
            print("[LIVE TAB DEBUG] Leaderboard table created successfully")
            
            # Create overlay for leaderboard if premium features disabled
            if not show_premium_features:
                print("[LIVE TAB DEBUG] Creating leaderboard overlay...")
                self.lb_table_overlay = self._create_premium_overlay(
                    self.live_frame, 
                    LB_LEFT["x"], LB_LEFT["y"], 
                    LB_LEFT_W, LB_LEFT_H,
                    "Trial Expired - Subscribe to Access Leaderboard"
                )
                print("[LIVE TAB DEBUG] Leaderboard overlay created")

            # === TOP 3 PANEL ===
            print("[LIVE TAB DEBUG] Creating Top3 Panel...")
            print(f"[LIVE TAB DEBUG] firebase_sync exists: {hasattr(self, 'firebase_sync')}")
            print(f"[LIVE TAB DEBUG] firebase_sync value: {getattr(self, 'firebase_sync', None)}")
            
            top3_offset_y = -25 
            new_width = LB_RIGHT["w"] + 100
            new_height = LB_RIGHT["h"] - 54

            self.lb_top3 = Top3Panel(
                self.live_frame,
                firebase_sync=self.firebase_sync,  # ‚úÖ Now this exists
                width=new_width,
                height=new_height,
                title_text="Last Week Top Rankers"
            )
            top3_x = LB_RIGHT["x"] - 50
            top3_y = LB_RIGHT["y"] + top3_offset_y

            self.lb_top3.place(
                relx=LB_RIGHT["relx"], 
                x=top3_x,
                y=top3_y,
                width=new_width, 
                height=new_height, 
                anchor="nw"
            )
            self.lb_top3.lift()
            
            print(f"[LIVE TAB DEBUG] Top3 Panel created successfully")
            print(f"[LIVE TAB DEBUG] Top3 exists: {self.lb_top3.winfo_exists()}")
            
            # Create overlay for top3 if premium features disabled
            if not show_premium_features:
                print("[LIVE TAB DEBUG] Creating Top3 overlay...")
                self.lb_top3_overlay = self._create_premium_overlay(
                    self.live_frame,
                    self.live_frame.winfo_reqwidth() + top3_x,
                    top3_y,
                    new_width, new_height,
                    "Trial Expired - Subscribe to Access Top Rankers",
                    use_relx=True, relx=LB_RIGHT["relx"], rel_x=top3_x
                )
                print("[LIVE TAB DEBUG] Top3 overlay created")

            # === RUNRATE GRAPH ===
            print("[LIVE TAB DEBUG] Creating RunRate Graph...")
            runrate_offset_y = -50  
            graph_h = getattr(self, "cm_to_pixels", lambda v: 0)(7.5) or 300 
            gap_y = getattr(self, "cm_to_pixels", lambda v: 0)(0.15) or 4     
            graph_w = LB_RIGHT['w'] + 100
            graph_x = LB_RIGHT['x'] - 50
            graph_y = LB_RIGHT['y'] + LB_RIGHT['h'] + gap_y + top3_offset_y + runrate_offset_y
            print(f"[LIVE TAB DEBUG] RunRate params: w={graph_w}, h={graph_h}")
            print(f"[LIVE TAB DEBUG] RunRate position: relx={LB_RIGHT['relx']}, x={graph_x}, y={graph_y}")
            
            # ‚úÖ Get exam date
            exam_date = None
            try:
                exam_date = self._load_exam_date() if hasattr(self, '_load_exam_date') else None
                print(f"[LIVE TAB DEBUG] Exam date: {exam_date}")
            except Exception as e:
                print(f"[LIVE TAB DEBUG] Could not load exam date: {e}")
            
            # ‚úÖ Create with plan name and exam date
            self.runrate_graph = RunRateGraph(
                self.live_frame, 
                width=graph_w, 
                height=graph_h,
                exam_date=exam_date,
                plan_name=self.current_plan_name  # ‚úÖ Add current plan name
            )
            
            print(f"[LIVE TAB DEBUG] RunRateGraph object created: {self.runrate_graph}")
            print(f"[LIVE TAB DEBUG] RunRateGraph exists: {self.runrate_graph.winfo_exists()}")
            
            self.runrate_graph.place(
                relx=LB_RIGHT['relx'],       
                x=graph_x,
                y=graph_y,
                width=graph_w,               
                height=graph_h,
                anchor="nw"                  
            )
            
            print(f"[LIVE TAB DEBUG] RunRateGraph placed successfully")
            
            self.runrate_graph.lift()
            
            print(f"[LIVE TAB DEBUG] RunRateGraph lifted, exists: {self.runrate_graph.winfo_exists()}")
            
            # Create overlay for runrate graph if premium features disabled
            if not show_premium_features:
                print("[LIVE TAB DEBUG] Creating RunRate overlay...")
                self.runrate_graph_overlay = self._create_premium_overlay(
                    self.live_frame,
                    self.live_frame.winfo_reqwidth() + graph_x,
                    graph_y,
                    graph_w, graph_h,
                    "Trial Expired - Subscribe to Access Performance Graph",
                    use_relx=True, relx=LB_RIGHT["relx"], rel_x=graph_x
                )
                print("[LIVE TAB DEBUG] RunRate overlay created")
            
            print("="*60)
            print("[LIVE TAB DEBUG] All widgets created successfully!")
            print("="*60)
            
        except Exception as e:  # ‚úÖ ADD THIS except BLOCK
            print("="*60)
            print(f"[LIVE TAB DEBUG] ‚ùå ERROR during RunRate Graph creation: {e}")
            import traceback
            traceback.print_exc()
            print("="*60)
        
        # === BAR CHART ===
        bar_frame = tk.Frame(self.live_frame, bg="#faf8ef")
        bar_frame.pack(fill="x", padx=12, pady=(0, 0), anchor="w")
        self.bar_canvas = tk.Canvas(bar_frame, width=350, height=60, bg="#faf8ef", highlightthickness=0, bd=0)
        self.bar_canvas.pack(side="left", padx=(14,0), pady=(0, 0))
        self.update_study_bar_chart()
        
        # Create overlay for bar chart if premium features disabled
        if not show_premium_features:
            self.bar_chart_overlay = self._create_premium_overlay(
                self.live_frame,
                22,  # x position (padx=12 + padx=(14,0) = 26)
                4,  # y position (approximate, adjust as needed)
                350, # width (same as canvas)
                55,  # height (same as canvas)
                "Trial Expired - Premium Feature",
                info_only=True  # This removes the subscribe button
            )

        # ======= END LEADERBOARD OVERLAYS =======

        # Keep the overlays above any later-created widgets
        def _raise_lb_overlays():
            try:
                if hasattr(self, "lb_table"):
                    self.lb_table.lift(); self.lb_table.tkraise()
                if hasattr(self, "lb_top3"):
                    self.lb_top3.lift(); self.lb_top3.tkraise()
                if hasattr(self, "runrate_graph"):
                    self.runrate_graph.lift(); self.runrate_graph.tkraise()
                
                # Raise premium overlays if they exist (keep them on top)
                if not show_premium_features:
                    if hasattr(self, "lb_table_overlay"):
                        self.lb_table_overlay.lift(); self.lb_table_overlay.tkraise()
                    if hasattr(self, "lb_top3_overlay"):
                        self.lb_top3_overlay.lift(); self.lb_top3_overlay.tkraise()
                    if hasattr(self, "runrate_graph_overlay"):
                        self.runrate_graph_overlay.lift(); self.runrate_graph_overlay.tkraise()
                    if hasattr(self, "bar_chart_overlay"):
                        self.bar_chart_overlay.lift(); self.bar_chart_overlay.tkraise()                
            except Exception:
                pass
            self.after(1000, _raise_lb_overlays)
        self.after(0, _raise_lb_overlays)

        # Row 1: Today studied time (top left), Today wastage time (top right)
        top_frame = ttk.Frame(self.live_frame)
        top_frame.pack(fill="x", padx=12, pady=(4, 0))
        self.day_label_var = tk.StringVar()
        self.day_label_var.set(f"Day: {self.day_count}")
       
        self.day_label = tk.Label(self.live_frame, textvariable=self.day_label_var, font=("Arial", 15, "bold"))
        self.day_label.pack(side="top", pady=(6,2))
        self.day_label.place(relx=0.5, rely=0, anchor="n")  # Centered at top
        self.today_study_label = ttk.Label(top_frame, text="Today Studied: 00:00:00", font=("Arial", 12, "bold"), foreground="#077b18")
        self.today_study_label.pack(side="left", anchor="nw", padx=(5,0))
        bar_frame = tk.Frame(self.live_frame, bg="#faf8ef")
        bar_frame.pack(fill="x", padx=12, pady=(0, 0), anchor="w")
        self.today_waste_label = ttk.Label(top_frame, text="Today Wastage: 00:00:00", font=("Arial", 12, "bold"), foreground="#d13221")
        self.today_waste_label.pack(side="right", anchor="ne", padx=(0,5))
        self.session_label = ttk.Label(self.live_frame, text="Session:", font=("Arial", 16, "bold"), anchor="center")
        self.session_label.pack(pady=(8, 2), fill="x")      
        self.time_label = ttk.Label(self.live_frame, text="Scheduled: --", font=("Arial", 14), anchor="center")
        self.time_label.pack(pady=2, fill="x")
        self.break_label = ttk.Label(self.live_frame, text="Break: --", font=("Arial", 14), anchor="center")
        self.break_label.pack(pady=2, fill="x")
        self.status_label = ttk.Label(self.live_frame, text="", font=("Arial", 13), foreground="red", anchor="center")
        self.status_label.pack(pady=5, fill="x")

        # Create container with clock symbol and three separate labels
        clock_container = ttk.Frame(self.live_frame)
        clock_container.pack(pady=(0,2))

        # Clock symbol
        clock_symbol_label = ttk.Label(clock_container, text="‚è±", font=("Arial", 32), foreground="#2976D9")
        clock_symbol_label.pack(side=tk.LEFT, padx=(0, 8))

        # Hour part (never changes color)
        self.hour_var = tk.StringVar()
        hour_label = ttk.Label(clock_container, textvariable=self.hour_var, font=("Arial", 38, "bold"), foreground="#2976D9")
        hour_label.pack(side=tk.LEFT)

        # Colon part (only this blinks)
        self.colon_var = tk.StringVar()
        self.colon_label = ttk.Label(clock_container, textvariable=self.colon_var, font=("Arial", 38, "bold"))
        self.colon_label.pack(side=tk.LEFT)

        # Minute+AM/PM part (never changes color)
        self.minute_var = tk.StringVar() 
        minute_label = ttk.Label(clock_container, textvariable=self.minute_var, font=("Arial", 38, "bold"), foreground="#2976D9")
        minute_label.pack(side=tk.LEFT)

        self.update_clock()
        self.timer_display = ttk.Label(self.live_frame, text="Elapsed: 00:00:00.00", font=("Arial", 22, "bold"), anchor="center")
        self.timer_display.pack(pady=(0, 2), fill="x")
        tk.Label(self.live_frame, text="").pack()
        self.remain_display = ttk.Label(self.live_frame, text="Remaining: 00:00:00.00", font=("Arial", 22, "bold"), anchor="center")
        self.remain_display.pack(pady=(0,2), fill="x")
        btn_frame = ttk.Frame(self.live_frame)
        btn_frame.pack(pady=(2, 0))

        # --- load images and keep references so they don't get garbage-collected ---
        self.start_img  = ImageTk.PhotoImage(Image.open("buttons/start.png"))
        self.pause_img  = ImageTk.PhotoImage(Image.open("buttons/pause.png"))
        self.resume_img = ImageTk.PhotoImage(Image.open("buttons/resume.png"))

        from tkinter import Button   # at the top of your file

        # Just add cursor="hand2" to your existing buttons:

        self.start_btn = Button(
            btn_frame,
            image=self.start_img,
            command=self.start_session,
            borderwidth=0,
            highlightthickness=0,
            bg="white",
            activebackground="white",
            cursor="hand2"  # ‚úÖ This is all you need for hover cursor change
        )
        self.start_btn.pack(side="left", padx=5)

        self.pause_btn = Button(
            btn_frame,
            image=self.resume_img,
            command=self.toggle_pause,
            borderwidth=0,
            highlightthickness=0,
            bg="white",
            activebackground="white", 
            cursor="hand2"  # ‚úÖ This is all you need for hover cursor change
        )
        self.pause_btn.pack(side="left", padx=5)

        self.paused = True
        self.quote_label = tk.Label(self.live_frame, text="", wraplength=500, font=("Arial", 16), fg="#007700", justify="center")
        self.quote_label.pack(pady=(6, 4), anchor="center")
        self.refresh_quote()
        self.progress_canvas = tk.Canvas(self.live_frame, width=380, height=22, bg="white", highlightthickness=0)
        self.progress_canvas.pack(pady=(0, 1))
        # ===== Progress Text + Edit Button (Goal Duration) =====
        progress_frame = tk.Frame(self.live_frame)
        progress_frame.pack(pady=(0, 0))

        self.progress_text_label = tk.Label(progress_frame, text="", font=("Arial", 11), fg="#2266bb")
        self.progress_text_label.pack(side="left")

        self.live_edit_btn = tk.Button(progress_frame, text="‚úé", font=("Arial", 10), bd=0, fg="#2266bb", cursor="hand2", command=self.edit_goal_duration)
        self.live_edit_btn.pack(side="left", padx=(5, 0))

        # Hidden variable for syncing with goal hours (not shown on UI)
        self.target_hours_var = tk.StringVar(value=str(round(self.progress_goal_hours, 2)))
        self.target_hours_entry = tk.Entry(self.live_frame, textvariable=self.target_hours_var)
        self.target_hours_entry.pack_forget()  # Hide the entry completely

        # Ensure the goal duration uses the full exam target (not per-day hours)
        if hasattr(self, "refresh_goal_and_markers"):
            try:
                self.refresh_goal_and_markers()
            except Exception as e:
                print(f"[GOAL] Failed to refresh goal on live tab setup: {e}")



        # Continue normal UI
        self.after(500, self.update_progress_bar)
        self.extra_study_btn = tk.Button(self.live_frame, text="Start Extra Study", font=("Arial", 12), bg="#f0ca16", fg="#222", width=16, command=self.toggle_extra_study)
        self.extra_study_btn.pack(pady=(0, 4))
        self.add_hover_effect(self.extra_study_btn, hover_bg="#e6b800", hover_fg="#222", normal_bg="#f0ca16", normal_fg="#222")
        self.pause_credit_label = tk.Label(self.live_frame, text="Pause Credit: 00:00 min", font=("Arial", 12), fg="#1976D2")
        self.pause_credit_label.pack()
        
        # Row 2: bottom left (total studied) and right (total wastage)
        bottom_frame = ttk.Frame(self.live_frame)
        bottom_frame.pack(side="bottom", fill="x", pady=(4, 4))

        # Container for total study label and reset button (using tk.Frame for bg support)
        total_study_container = tk.Frame(bottom_frame)
        total_study_container.pack(side="left", padx=(10, 0), pady=(0, 2))

        self.total_study_label = ttk.Label(
            total_study_container,
            text="Total Studied Time: 00:00:00",
            font=("Arial", 12, "bold"),
            foreground="#077b18"
        )
        self.total_study_label.pack(side="left")

        # Small reset button (compact version)
        reset_study_btn = tk.Button(
            total_study_container,
            text="‚Üª",
            font=("Arial", 7),
            bg="#dc3545",
            fg="white",
            width=2,
            relief="flat",
            bd=0,
            cursor="hand2",
            command=self.reset_total_studied,
            padx=0,
            pady=0,
            highlightthickness=0
        )
        reset_study_btn.pack(side="left", padx=(5, 0))

        self.total_waste_label = ttk.Label(
            bottom_frame,
            text="Total Wastage Time: 00:00:00",
            font=("Arial", 12, "bold"),
            foreground="#d13221"
        )
        self.total_waste_label.pack(side="right", padx=(0,10), pady=(0,2))
        self.after(300, self.hide_live_tab_elements_for_non_premium)
        self.update_wastage_labels()
        
    def reset_total_studied(self):
        """Reset total studied hours for CURRENT PLAN only"""
        from tkinter import messagebox
        
        # Confirm before resetting
        confirm = messagebox.askyesno(
            "Reset Total Studied Time",
            f"Reset studied time for '{self.current_plan_name}'?\n\n"
            f"This will:\n"
            f"‚Ä¢ Clear all study records for this plan\n"
            f"‚Ä¢ Reset total studied time to 0\n"
            f"‚Ä¢ Keep today's active session\n"
            f"‚Ä¢ Other plans will NOT be affected",
            icon="warning"
        )
        
        if not confirm:
            return
        
        try:
            today = datetime.now().strftime("%Y-%m-%d")
            today_seconds = int(getattr(self, "today_study_stopwatch_seconds", 0))
            
            # Load all data
            all_data = load_today_studied_data()
            
            # Convert to plan structure if needed
            if all_data and not any(isinstance(v, dict) for v in all_data.values()):
                old_data = all_data.copy()
                all_data = {"Default": old_data}
            
            # Reset only current plan's data
            if today_seconds > 0:
                all_data[self.current_plan_name] = {today: today_seconds}
            else:
                all_data[self.current_plan_name] = {}
            
            # Save back
            save_today_studied_data(all_data)
            
            # Force update the UI
            self._update_total_study_label_live()
            self.update_progress_bar(live_today_seconds=today_seconds)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to reset studied time:\n{e}")
            print(f"Reset error: {e}")
        
    def check_for_session_start(self):
        now = datetime.now().strftime("%H:%M")
        for i, session in enumerate(self.schedule):
            session_name, start_time, end_time, *_ = session
            if now == start_time and not self.session_started_flags[i]:
                play_alarm_sound(self.alarm_file)
                self.session_started_flags[i] = True
        self.after(1000, self.check_for_session_start)  
        
    def refresh_quote(self):
        self.quote_label.config(text=get_random_quote_from_folder(app_paths.quotes_dir))
        self.live_tab.after(3600000, self.refresh_quote)
        
    def update_clock(self):
        now = datetime.now()
        current_second = now.second
        
        # Update text (these never change color)
        self.hour_var.set(now.strftime("%I").lstrip("0"))
        self.minute_var.set(now.strftime("%M %p"))
        self.colon_var.set(":")
        
        # Only change colon color
        if current_second % 2 == 0:
            self.colon_label.configure(foreground="#2976D9")  # Visible
        else:
            # Use system default background color
            style = ttk.Style()
            bg_color = style.lookup('TFrame', 'background')
            self.colon_label.configure(foreground=bg_color)    # Hidden (match background)
        
        self.after(1000, self.update_clock)
        
    def update_study_bar_chart(self, live_today_seconds=None):
        from datetime import datetime, timedelta
        today = datetime.now().date()
        data = {}
        import os, json

        if os.path.exists(app_paths.study_today_file):
            with open(app_paths.study_today_file, "r") as f:
                data = json.load(f)

        if live_today_seconds is not None:
            today_str = today.strftime("%Y-%m-%d")
            data[today_str] = live_today_seconds

        bars = []
        for i in range(2, -1, -1):  # Only last 3 days
            dt = today - timedelta(days=i)
            dt_str = dt.strftime("%Y-%m-%d")
            secs = data.get(dt_str, 0)
            bars.append((dt_str[5:], secs))  # MM-DD, seconds

        max_secs = max([s for _, s in bars] + [3600])  # At least 1 hour
        self.bar_canvas.delete("all")
        width, height = 340, 60
        x0, y0 = 10, 10
        bar_h = 10
        gap = 9

        bar_colors = ["#60d394", "#f6a01f", "#1fa8f6"]  # Green, Orange, Blue

        for idx, (date, secs) in enumerate(bars):
            bar_len = int((secs / max_secs) * (width - 100))
            color = bar_colors[idx]
            y = y0 + idx * (bar_h + gap)
            # Draw Date
            self.bar_canvas.create_text(x0+5, y + bar_h // 2, text=date, anchor="w", font=("Arial", 10, "bold"))
            # Draw Bar
            self.bar_canvas.create_rectangle(x0+50, y, x0+50+bar_len, y+bar_h, fill=color, outline="")
            # Draw Time
            self.bar_canvas.create_text(x0+50+bar_len+ 0, y + bar_h // 2, text=hhmmss_from_seconds(secs), anchor="w", font=("Arial", 10))

    # ====== EXTRA STUDY BUTTON ======
    def toggle_extra_study(self):
        now = datetime.now()
        if self.extra_study_running:
            # === STOPPING EXTRA STUDY ===
            self.extra_study_btn.config(text="Start Extra Study", bg="#f0ca16", fg="#222")
            self.extra_study_running = False
            self.extra_study_start = None
            self.last_extra_study_tick = None  # reset

            # Re-apply hover effect for "Start" state (yellow button)
            self.add_hover_effect(
                self.extra_study_btn,
                hover_bg="#e6b800", hover_fg="#222",
                normal_bg="#f0ca16", normal_fg="#222"
            )

        else:
            # === STARTING EXTRA STUDY ===
            idx, st_dt, en_dt = get_active_session_idx(self.schedule)
            if idx is not None:
                messagebox.showinfo("Extra Study", "You can't do Extra Study during session time.")
                return

            self.extra_study_running = True
            self.extra_study_start = now
            self.last_extra_study_tick = now  # baseline for per-second ticking
            self.extra_study_btn.config(text="Stop Extra Study", bg="#ec5c2e", fg="#fff")

            # Re-apply hover effect for "Stop" state (red button)
            self.add_hover_effect(
                self.extra_study_btn,
                hover_bg="#d9472a", hover_fg="#fff",
                normal_bg="#ec5c2e", normal_fg="#fff"
            )


   
    def setup_wastage_tab(self):
        """Alternative version using pack layout with always-visible scrollbar"""
        self.all_day_total_row_var = tk.StringVar()
        outer = ttk.Frame(self.wastage_tab)
        outer.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(outer, text="Today's Wastage", font=("Arial", 16, "bold")).pack(pady=(2,0))
        today_frame = ttk.Frame(outer)
        today_frame.pack(fill="x", padx=2, pady=0)
        cols = ("Session", "Scheduled Start", "Actual Start", "Wastage (hh:mm:ss)", "Missed")
        self.wastage_tree = ttk.Treeview(today_frame, columns=cols, show="headings", height=7)
        for c in cols:
            self.wastage_tree.heading(c, text=c)
            self.wastage_tree.column(c, anchor=tk.CENTER, width=180)
        
        # Top section scrollbar
        y_scroll = ttk.Scrollbar(today_frame, orient="vertical", command=self.wastage_tree.yview)
        self.wastage_tree.configure(yscrollcommand=y_scroll.set)
        self.wastage_tree.pack(side="left", fill="both", expand=True)
        y_scroll.pack(side="right", fill="y")
        
        self.today_total_row_var = getattr(self, 'today_total_row_var', None) or tk.StringVar()
        total_row_frame = tk.Frame(outer)
        total_row_frame.pack(fill="x", pady=(0,0))
        self.today_total_label = tk.Label(total_row_frame, textvariable=(self.today_total_row_var if hasattr(self, 'today_total_row_var') else tk.StringVar()), font=("Arial", 13, "bold"), anchor="w", fg="#333")
        self.today_total_label.pack(side="left", padx=8, pady=(0,5))
        self.reset_button = tk.Button(outer, text="Reset Selected Entry", command=self.reset_selected_wastage)
        self.reset_button.pack(pady=(0,8))
        if hasattr(self, 'add_hover_effect'):
            self.add_hover_effect(self.reset_button, hover_bg="#F8D7DA")
        ttk.Separator(outer, orient="horizontal").pack(fill="x", padx=6, pady=2)
        tk.Label(outer, text="All-Time Wastage By Date", font=("Arial", 15, "bold")).pack(pady=(5,1))
        
        # Get unique session names for columns
        unique_names = []
        for sess in self.schedule:
            base_name = re.sub(r'\s+\d+$', '', sess[0])
            try:
                group_name = SUBJECT_GROUPS.get(sess[0], SUBJECT_GROUPS.get(base_name, base_name))
            except NameError:
                group_name = base_name
            
            if group_name not in unique_names:
                unique_names.append(group_name)
        
        unique_names = sorted(unique_names)
        all_cols = ["Date"] + unique_names + ["Missed Sessions", "Total"]
        
        # Bottom table frame
        tree_frame = ttk.Frame(outer)
        tree_frame.pack(fill="both", expand=True, padx=2)
        
        # Reduce height to ensure scrolling is needed
        self.wastage_by_day_tree = ttk.Treeview(tree_frame, columns=all_cols, show="headings", height=6)
        
        # Column setup (same as before)
        num_cols = len(all_cols)
        available_width = 1200
        base_width = available_width // num_cols
        min_width = 60
        max_width = 150
        col_width = max(min_width, min(max_width, base_width))
        
        for c in all_cols:
            self.wastage_by_day_tree.heading(c, text=c)
            if c == "Date":
                self.wastage_by_day_tree.column(c, anchor=tk.CENTER, width=max(90, col_width))
            elif c == "Total":
                self.wastage_by_day_tree.column(c, anchor=tk.CENTER, width=max(70, col_width))
            elif c == "Missed Sessions":
                self.wastage_by_day_tree.column(c, anchor=tk.CENTER, width=max(80, col_width))
            else:
                if col_width < 80 and len(c) > 8:
                    abbrev = c[:6] + ".." if len(c) > 8 else c
                    self.wastage_by_day_tree.heading(c, text=abbrev)
                self.wastage_by_day_tree.column(c, anchor=tk.CENTER, width=col_width)
        
        # Vertical scrollbar - pack version
        y_scroll2 = ttk.Scrollbar(tree_frame, orient="vertical", command=self.wastage_by_day_tree.yview)
        self.wastage_by_day_tree.configure(yscrollcommand=y_scroll2.set)
        
        # Pack with specific order to ensure scrollbar visibility
        y_scroll2.pack(side="right", fill="y")  # Pack scrollbar first
        self.wastage_by_day_tree.pack(side="left", fill="both", expand=True)
        
        # Force scrollbar to appear by adding some dummy content initially
        for i in range(10):  # Add dummy rows to trigger scrollbar
            self.wastage_by_day_tree.insert("", tk.END, values=["" for _ in all_cols], tags=("dummy",))
        
        # Configure dummy row tags to be invisible
        self.wastage_by_day_tree.tag_configure("dummy", foreground="white", background="white")
        
        # Bottom controls
        allday_total_frame = tk.Frame(outer)
        allday_total_frame.pack(fill="x", pady=(2,5))
        
        label_font_size = max(9, min(13, int(140/max(1, num_cols-3))))
        self.allday_total_label = tk.Label(
            allday_total_frame, 
            textvariable=self.all_day_total_row_var, 
            font=("Arial", label_font_size, "bold"), 
            anchor="w", 
            fg="#333"
        )
        self.allday_total_label.pack(side="left", padx=8, fill="x", expand=True)
        
        button_font_size = max(8, min(10, int(120/max(1, num_cols-4))))
        button_text = "üóë Reset All" if num_cols <= 8 else "üóë Reset"
        
        self.reset_all_button = tk.Button(
            allday_total_frame,
            text=button_text,
            command=self.reset_all_wastage_data,
            bg="#dc3545",
            fg="white",
            font=("Arial", button_font_size, "bold"),
            relief="raised",
            bd=2,
            padx=max(8, 15-max(0, num_cols-6)),
            pady=3
        )
        self.reset_all_button.pack(side="right", padx=8)
        
        if hasattr(self, 'add_hover_effect'):
            self.add_hover_effect(self.reset_all_button, hover_bg="#c82333", hover_fg="white")       
        self.refresh_wastage() 
        
        # Load profile
        user_profile = {}
        profile_exists = False

        try:
            app_data_dir = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "StudyTimer")
            profile_file = os.path.join(app_data_dir, "profile.json")
            if os.path.exists(profile_file):
                with open(profile_file, 'r') as f:
                    user_profile = json.load(f)
                profile_exists = True
        except:
            pass

        # Check license FIRST
        license_valid = False
        if hasattr(self, 'license_manager'):
            try:
                license_valid, _ = self.license_manager.comprehensive_validation(user_profile)
            except:
                pass

        # ‚úÖ If license valid, show features immediately
        if license_valid:
            print("[WASTAGE] Valid license - showing features")
            return  # Don't hide anything

        # Check trial only if no license
        trial_valid = False
        trial_status = 'no_trial'

        if hasattr(self, 'trial_manager'):
            try:
                trial_status, _, _ = self.trial_manager.validate_trial(user_profile)
                trial_valid = (trial_status == 'valid')
            except:
                pass

        # ‚úÖ CORRECTED LOGIC: Show features for first-time users and active trials
        should_show_features = (
            trial_valid or                                      # Active trial
            (not profile_exists) or                            # Brand new user
            (profile_exists and trial_status == 'no_trial' and  # First-time user
             not user_profile.get('trial_tampered'))           # Not tampered
        )

        print(f"[WASTAGE] Profile: {profile_exists}, Trial: {trial_status}, Should show: {should_show_features}")

        # Only hide if should NOT show features
        if not should_show_features:
            # Hide the tree and controls
            if hasattr(self, 'wastage_by_day_tree'):
                self.wastage_by_day_tree.pack_forget()
            if hasattr(self, 'allday_total_label'):
                self.allday_total_label.master.pack_forget()
            if hasattr(self, 'reset_all_button'):
                self.reset_all_button.master.pack_forget()
            
            # Show premium message
            premium_msg = tk.Label(outer, text="üîí Historical Wastage Data - Premium Feature", 
                                 font=("Arial", 12, "bold"), fg="#666", bg="#f0f0f0", 
                                 relief="solid", bd=1, pady=20)
            premium_msg.pack(fill="x", padx=20, pady=10)
            
            subscribe_btn = tk.Button(outer, text="Subscribe Now", bg="#4CAF50", fg="white",
                                    font=("Arial", 10, "bold"), command=self._open_subscription_dialog)
            subscribe_btn.pack(pady=5)
            
            # Store references
            self.wastage_premium_msg = premium_msg
            self.wastage_subscribe_btn = subscribe_btn
            
            print("[WASTAGE] Features hidden for non-premium user")
        else:
            print("[WASTAGE] Features visible")
        
    def refresh_wastage(self):
        """
        Live refresh for:
          1) Top 'Today Wastage' list (wastage_tree)
          2) Bottom 'ALL time wastage by Date' table (wastage_by_day_tree), grouped by subject groups
        NOW FILTERS BY CURRENT PLAN.
        """
        import re
        from datetime import datetime
        import tkinter as tk

        # Get current plan name
        current_plan = getattr(self, 'current_plan_name', 'Default')

        # ---------- helper: map session name -> group ----------
        def _group_of(session_name: str) -> str:
            base = re.sub(r'\s+\d+$', '', (session_name or "").strip())
            try:
                return SUBJECT_GROUPS.get(session_name, SUBJECT_GROUPS.get(base, base))
            except NameError:
                return base

        # ---------- helper: normalize date display ----------
        def _date_str(d):
            if hasattr(d, "strftime"):
                return d.strftime("%Y-%m-%d")
            return str(d)

        # ---------- helper: Actual Start -> TIME ONLY or "MISSED" (ALL CAPS) ----------
        def _format_actual_start(entry):
            s = (entry.get("Actual Start", "") or "").strip()
            if not s:
                return "MISSED"
            # block unwanted labels
            if s.strip().lower() in {"offline","not started","pending","skipped","missed","paused"}:
                return "MISSED"
            # try full datetime -> time
            try:
                from datetime import datetime as _dt
                return _dt.strptime(s, "%d-%b-%Y %I:%M %p").strftime("%I:%M %p").lstrip("0")
            except Exception:
                pass
            # extract "h:mm AM/PM"
            m = re.search(r'(\d{1,2}:\d{2}\s*[AP]M)', s, flags=re.IGNORECASE)
            if m:
                try:
                    from datetime import datetime as _dt
                    return _dt.strptime(m.group(1).upper().replace(" ", ""), "%I:%M%p").strftime("%I:%M %p").lstrip("0")
                except Exception:
                    return m.group(1).upper().replace(" ", "")
            # "10:30" without AM/PM ‚Üí show as-is
            m2 = re.search(r'\b\d{1,2}:\d{2}\b', s)
            if m2:
                return m2.group(0)
            return "MISSED"

        # ---------- load freshest log ----------
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)

        # Filter to only current plan's wastage
        plan_wastage_log = get_current_plan_wastage_log(current_plan)

        # ---------- remember selection KEYS (Session, Scheduled Start time text) ----------
        sel_key_top = None
        sel_top_vals = None
        try:
            sel = self.wastage_tree.selection()
            if sel:
                sel_top_vals = self.wastage_tree.item(sel[0])['values']
                if sel_top_vals and len(sel_top_vals) >= 2:
                    # key is (Session, Scheduled Start time-text shown in column 2)
                    sel_key_top = (sel_top_vals[0], sel_top_vals[1])
        except Exception:
            pass

        sel_bottom_vals = None
        try:
            selb = self.wastage_by_day_tree.selection()
            if selb:
                sel_bottom_vals = self.wastage_by_day_tree.item(selb[0])['values']
        except Exception:
            pass

        # ---------- clear trees ----------
        try:
            for iid in self.wastage_tree.get_children():
                self.wastage_tree.delete(iid)
        except Exception:
            pass

        try:
            for iid in self.wastage_by_day_tree.get_children():
                self.wastage_by_day_tree.delete(iid)
        except Exception:
            pass

        now = datetime.now()
        today_str = now.strftime("%Y-%m-%d")

        # Load reset tracking
        try:
            resets = load_reset_wastage()
        except Exception:
            resets = {}
        today_reset_sessions = resets.get(today_str, [])

        # Respect plan activation time so we don't show pre-switch sessions as missed
        activation_ts = _ensure_today_activation(current_plan)

        # Filter today's entries for current plan only
        todays = [e for e in plan_wastage_log if e.get("Date") == today_str]

        def _sort_key(entry):
            try:
                return datetime.strptime(entry["Scheduled Start"], "%d-%b-%Y %I:%M %p")
            except Exception:
                return datetime.min

        todays = sorted(todays, key=_sort_key)

        attended_map, missed_map = {}, {}
        for e in todays:
            key = (e.get("Session"), e.get("Scheduled Start"))
            if str(e.get("Missed", "No")).strip().lower() == "yes":
                missed_map[key] = e
            else:
                attended_map[key] = e

        top_total_seconds = 0
        processed_keys = set()

        # build rows
        for sess in getattr(self, "schedule", []):
            if sess[0] in today_reset_sessions:
                continue

            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], now)
            scheduled_original = st_dt.strftime("%d-%b-%Y %I:%M %p")

            if now.date() != st_dt.date():
                from datetime import datetime as _dt2
                today_dt = _dt2.combine(now.date(), st_dt.time())
                scheduled_today = today_dt.strftime("%d-%b-%Y %I:%M %p")
                key_candidates = [(sess[0], scheduled_today), (sess[0], scheduled_original)]
            else:
                key_candidates = [(sess[0], scheduled_original)]

            if activation_ts and activation_ts.date() == now.date() and en_dt <= activation_ts:
                processed_keys.update(key_candidates)
                for k in key_candidates:
                    attended_map.pop(k, None)
                    missed_map.pop(k, None)
                continue

            key = None
            for k in key_candidates:
                if k in attended_map or k in missed_map:
                    key = k
                    break
            if key is None:
                key = key_candidates[0]

            processed_keys.add(key)
            sched_time_disp = st_dt.strftime("%I:%M %p").lstrip("0")

            if key in attended_map:
                e = attended_map[key]
                self.wastage_tree.insert(
                    "", tk.END,
                    values=(
                        e.get("Session", ""),
                        sched_time_disp,
                        _format_actual_start(e),                          # TIME or "MISSED"
                        e.get("Wastage (hh:mm:ss)", "00:00:00"),
                        "NO" if _format_actual_start(e) != "MISSED" else "YES",  # ALWAYS upper
                    ),
                )
                top_total_seconds += parse_hhmmss(e.get("Wastage (hh:mm:ss)", "00:00:00"))

            elif key in missed_map:
                e = missed_map[key]
                self.wastage_tree.insert(
                    "", tk.END,
                    values=(
                        e.get("Session", ""),
                        sched_time_disp,
                        "MISSED",
                        e.get("Wastage (hh:mm:ss)", "00:00:00"),
                        "YES",
                    ),
                )
                top_total_seconds += parse_hhmmss(e.get("Wastage (hh:mm:ss)", "00:00:00"))

            else:
                if now >= st_dt and (en_dt <= now):  # session finished with no entry
                    wasted_seconds = int((en_dt - st_dt).total_seconds())
                    self.wastage_tree.insert(
                        "", tk.END,
                        values=(sess[0], sched_time_disp, "MISSED",
                                hhmmss_from_seconds_total(wasted_seconds), "YES"),
                    )
                    top_total_seconds += wasted_seconds
                # else future / in-progress with no entry ‚Üí show nothing (matches your behavior)

        # unmatched entries
        for key, e in attended_map.items():
            if key not in processed_keys and e.get("Session","") not in today_reset_sessions:
                try:
                    sched_dt = datetime.strptime(e.get("Scheduled Start",""), "%d-%b-%Y %I:%M %p")
                    display_time = sched_dt.strftime("%I:%M %p").lstrip("0")
                except Exception:
                    display_time = "??:??"
                act = _format_actual_start(e)
                self.wastage_tree.insert(
                    "", tk.END,
                    values=(e.get("Session",""), display_time, act,
                            e.get("Wastage (hh:mm:ss)","00:00:00"),
                            "NO" if act != "MISSED" else "YES"),
                )
                top_total_seconds += parse_hhmmss(e.get("Wastage (hh:mm:ss)","00:00:00"))

        for key, e in missed_map.items():
            if key not in processed_keys and e.get("Session","") not in today_reset_sessions:
                try:
                    sched_dt = datetime.strptime(e.get("Scheduled Start",""), "%d-%b-%Y %I:%M %p")
                    display_time = sched_dt.strftime("%I:%M %p").lstrip("0")
                except Exception:
                    display_time = "??:??"
                self.wastage_tree.insert(
                    "", tk.END,
                    values=(e.get("Session",""), display_time, "MISSED",
                            e.get("Wastage (hh:mm:ss)","00:00:00"), "YES"),
                )
                top_total_seconds += parse_hhmmss(e.get("Wastage (hh:mm:ss)","00:00:00"))

        # TOTAL label
        if hasattr(self, "today_total_row_var") and getattr(self, 'today_total_row_var', None) is not None:
            self.today_total_row_var.set(f"TOTAL  -  Wastage: {hhmmss_from_seconds_total(top_total_seconds)}")

        # ---------------- bottom table with RESPONSIVE COLUMNS + VERTICAL SCROLL ----------------
        unique_groups = []
        for sess in getattr(self, "schedule", []):
            g = _group_of(sess[0])
            if g not in unique_groups:
                unique_groups.append(g)
        unique_groups = sorted(unique_groups)

        summary = self.update_wastage_day_summary() or {}

        cols = ["Date"] + unique_groups + ["Missed Sessions", "TOTAL"]
        tree = self.wastage_by_day_tree
        tree["columns"] = cols
        tree["show"] = "headings"

        # Calculate responsive column widths
        num_cols = len(cols)
        available_width = 1200  # Adjust based on your typical window size
        base_width = available_width // num_cols
        
        # Set minimum and maximum widths
        min_width = 60
        max_width = 150
        col_width = max(min_width, min(max_width, base_width))

        # Set column headers and widths with responsive sizing
        for c in cols:
            tree.heading(c, text=c)
            
            if c == "Date":
                tree.column(c, width=max(90, col_width), anchor="center")
            elif c == "TOTAL":
                tree.column(c, width=max(70, col_width), anchor="center")
            elif c == "Missed Sessions":
                tree.column(c, width=max(80, col_width), anchor="center")
            else:
                # For subject columns, abbreviate if too narrow
                if col_width < 80 and len(c) > 8:
                    abbrev = c[:6] + ".." if len(c) > 8 else c
                    tree.heading(c, text=abbrev)
                tree.column(c, width=col_width, anchor="center")

        col_totals = {g: 0 for g in unique_groups}
        missed_total = 0
        grand_total = 0

        for d in sorted(summary.keys(), reverse=True):
            m = summary.get(d, {})
            row_total = 0
            row = [_date_str(d)]
            for g in unique_groups:
                sec = int(m.get(g, 0))
                row.append(hhmmss_from_seconds_total(sec))
                col_totals[g] += sec
                row_total += sec
            missed = int(m.get("Missed Sessions", 0))
            missed_total += missed
            row.append(str(missed))
            row.append(hhmmss_from_seconds_total(row_total))
            grand_total += row_total
            tree.insert("", tk.END, values=row)

        total_row = ["TOTAL"]
        for g in unique_groups:
            total_row.append(hhmmss_from_seconds_total(col_totals[g]))
        total_row.append(str(missed_total))
        total_row.append(hhmmss_from_seconds_total(grand_total))
        tree.insert("", tk.END, values=total_row)

        # Store grand total for Live tab updates
        self.latest_grand_total = grand_total
        self.latest_today_total = top_total_seconds
        
        if not hasattr(self, "all_day_total_row_var") or self.all_day_total_row_var is None:
            self.all_day_total_row_var = tk.StringVar(value="")
        
        # Create responsive label text based on number of columns
        if num_cols <= 8:
            # Full format for fewer columns
            label_bits = [f"{g}: {hhmmss_from_seconds_total(col_totals[g])}" for g in unique_groups]
            label_bits.append(f"Missed: {missed_total}")
            label_bits.append(f"Grand: {hhmmss_from_seconds_total(self.latest_grand_total)}")
            self.all_day_total_row_var.set(" | ".join(label_bits))
        else:
            # Abbreviated format for many columns
            label_bits = [f"{g[:6]}: {hhmmss_from_seconds_total(col_totals[g])}" for g in unique_groups]
            label_bits.append(f"M: {missed_total}")
            label_bits.append(f"Total: {hhmmss_from_seconds_total(self.latest_grand_total)}")
            self.all_day_total_row_var.set(" | ".join(label_bits))
        
        # Force update Live tab labels immediately after data refresh
        self.update_wastage_labels()

        # ---------- restore selection by KEY and fire select event ----------
        reselected = False
        if sel_key_top:
            for iid in self.wastage_tree.get_children():
                vals = self.wastage_tree.item(iid)['values']
                if vals and len(vals) >= 2 and (vals[0], vals[1]) == sel_key_top:
                    self.wastage_tree.selection_set(iid)
                    try:
                        self.wastage_tree.focus(iid)
                    except Exception:
                        pass
                    reselected = True
                    break
        if reselected:
            try:
                # ensure any <<TreeviewSelect>> binding (that toggles Register/Pause) runs
                self.wastage_tree.event_generate("<<TreeviewSelect>>")
            except Exception:
                pass

        if sel_bottom_vals:
            for iid in self.wastage_by_day_tree.get_children():
                if self.wastage_by_day_tree.item(iid)['values'] == sel_bottom_vals:
                    self.wastage_by_day_tree.selection_set(iid)
                    break
    

    def reset_selected_wastage(self):
        selected = self.wastage_tree.selection()
        if not selected:
            return
        
        global wastage_log
        selected_item = self.wastage_tree.item(selected[0])["values"]
        today_str = datetime.now().strftime("%Y-%m-%d")
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        
        session_name = selected_item[0]
        scheduled_time_display = selected_item[1]  # e.g., "10:00 AM"
        
        # Find and remove ALL entries for this session today
        # We'll use a more direct approach - remove by session name and scheduled time
        entries_to_remove = []
        
        for i, row in enumerate(wastage_log):
            if (row["Date"] == today_str and 
                row["Session"] == session_name):
                
                # Check if scheduled time matches
                try:
                    log_scheduled_dt = datetime.strptime(row["Scheduled Start"], "%d-%b-%Y %I:%M %p")
                    log_time_display = log_scheduled_dt.strftime("%I:%M %p").lstrip("0")
                    if log_time_display == scheduled_time_display:
                        entries_to_remove.append(i)
                except:
                    pass
        
        # Remove entries in reverse order to maintain indices
        for i in reversed(entries_to_remove):
            del wastage_log[i]
        
        # Save the updated log
        save_wastage_log()

        # Reset tracking
        resets = load_reset_wastage()
        if today_str not in resets:
            resets[today_str] = []
        if session_name not in resets[today_str]:
            resets[today_str].append(session_name)
        save_reset_wastage(resets)

        # Reset session state if this was the current session
        if hasattr(self, 'active_session_idx') and self.active_session_idx is not None:
            current_session_name = self.schedule[self.active_session_idx][0]
            if current_session_name == session_name:
                # Reset session state
                self.registered = False
                self.paused = False
                self.register_btn.config(state="normal", text="Register")
                self.pause_btn.config(state="disabled", text="Pause")
                self.status_label.config(text="Session reset. Click Register to start tracking.", foreground="blue")

        # Update displays
        self.update_wastage_day_summary()
        self.refresh_wastage()
       

    def _only_time_from_scheduled(self, sched):
        try:
            dt = datetime.strptime(sched, "%d-%b-%Y %I:%M %p")
            return dt.strftime("%I:%M %p").lstrip("0")
        except Exception:
            return sched

    def on_tab_change(self, event):
        tab = event.widget.tab(event.widget.index("current"))["text"]
        if tab == "Wastage Report":
            self.refresh_wastage()

    def update_plan_highlight(self):
        if self.manual_plan_row_selected:
           return
        now = datetime.now()
        for idx, sess in enumerate(self.schedule):
            st_dt, en_dt = get_session_datetimes(sess[1], sess[2], now)
            if st_dt <= now <= en_dt:
                self.plan_tree.selection_set(self.plan_rows[idx])
                self.plan_tree.see(self.plan_rows[idx])
                self.plan_tree.item(self.plan_rows[idx], tags=("current",))
            else:
                self.plan_tree.item(self.plan_rows[idx], tags=())
        self.after(500, self.update_plan_highlight)

    def start_session(self):
        if self.active_session_idx is None or self.registered:
            return

        self.elapsed_timer_enabled = True
        self.registered = True
        self.paused = False
        self.remaining_visual_freeze = False
        self.remaining_visual_frozen_value = None
        self.pause_start_time = None
        self.study_active_from = datetime.now()

        # --- Ensure stopwatch starts running! ---
        self.stopwatch_running = True
        self.last_study_stopwatch_update = datetime.now()

        ## --- Add wastage if started late (no double count) ---
        now = datetime.now()
        idx = self.active_session_idx
        if idx is not None:
            session = self.schedule[idx]
            st_dt, en_dt = get_session_datetimes(session[1], session[2], now)
            scheduled = st_dt.strftime("%d-%b-%Y %I:%M %p")
            session_name = session[0]
            actual_start_str = now.strftime("%I:%M %p")

            delay_seconds = int((now - st_dt).total_seconds())
            if delay_seconds > 0:
                # how much is already logged for this (session, scheduled, today, Missed="No")
                today_key = now.strftime("%Y-%m-%d")
                already = 0
                for e in wastage_log:
                    if (e.get("Session") == session_name and
                        e.get("Scheduled Start") == scheduled and
                        e.get("Date") == today_key and
                        e.get("Missed", "No") == "No"):
                        already = parse_hhmmss(e.get("Wastage (hh:mm:ss)", "00:00:00"))
                        break

                to_add = max(0, delay_seconds - already)
                # call even if to_add == 0 so "Actual Start" gets updated from "PAUSED" to real time
                add_or_update_wastage(session_name, scheduled, actual_start_str, to_add, missed="No", app=self)

        # --- Just in case: stop extra study if still running ---
        if hasattr(self, "extra_study_running") and self.extra_study_running:
            self.toggle_extra_study()
        # Save the updated stopwatch to disk for other UI to pick up
        # Force save stopwatch and update all studied/progress UI immediately!
        set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=self.current_plan_name)

        if hasattr(self, "progress_text_label"):
            self.update_progress_bar()
        if hasattr(self, "bar_canvas"):
            self.update_study_bar_chart()
        if hasattr(self, "total_study_label"):
            total_studied_seconds = get_total_stopwatch_studied()
            self._update_total_study_label_live()
        
        # ‚úÖ FIX BUTTON STATES: When session starts, we're running (not paused)
        self.paused = False  # Already set above, but emphasizing it's running
        self.pause_btn.config(image=self.pause_img)  # Show PAUSE image since we're running
        self.pause_btn.config(state="normal")  # Enable the pause button
        
        # Disable start button since session is now running
        self.start_btn.config(state="disabled")
        
        print("[DEBUG] Session started - set to running state with PAUSE image")
                
        self.send_telegram("‚úÖ Session started at " + datetime.now().strftime('%I:%M %p'))
        
           

    def update_timer(self):
        now = datetime.now()
        idx, st_dt, en_dt = get_active_session_idx(self.schedule)
        is_active = (idx is not None)
        in_break = is_active and is_on_break(now, idx, self.schedule)
        after_session = is_active and now > en_dt

        # --- Alarm check ---
        if self.prev_session_idx is not None and idx != self.prev_session_idx:
            play_alarm_sound(self.alarm_file)
        self.prev_session_idx = idx

        # --- Today studied stopwatch logic: only run during active session, not paused, not break ---
        running = is_active and self.registered and not self.paused and not in_break and self.elapsed_timer_enabled
        self.stopwatch_running = running

        # --- Session change detection ---
        if not hasattr(self, "session_end_notified"):
            self.session_end_notified = False
        if not hasattr(self, "last_notified_session_idx"):
            self.last_notified_session_idx = None

        if idx != self.active_session_idx:
            if self.active_session_idx is not None and idx is None:
                try:
                    session_name = self.schedule[self.active_session_idx][0] if self.active_session_idx is not None else "Unknown"
                    st_dt = self.session_start_datetime
                    en_dt = self.session_end_datetime
                    if st_dt and en_dt:
                        scheduled = f"{st_dt.strftime('%I:%M %p').lstrip('0')} ‚Äì {en_dt.strftime('%I:%M %p').lstrip('0')}"
                    else:
                        scheduled = "N/A"
                    self.send_telegram(
                        f"‚ùå Session ended: {session_name}\n"
                        f"‚è∞ Scheduled: {scheduled}"
                    )
                    print("==> SESSION END NOTIFICATION SENT")
                except Exception as e:
                    print("Failed to send session end Telegram notification:", e)
            if self.active_session_idx is not None and self.study_elapsed_seconds > 0:
                self.total_studied_time += self.study_elapsed_seconds
            self.active_session_idx = idx
            self.session_start_datetime = st_dt
            self.session_end_datetime = en_dt
            self.elapsed_timer_enabled = False
            self.registered = False
            self.paused = False
            self.remaining_visual_freeze = False
            self.remaining_visual_frozen_value = None
            self.pause_start_time = None
            self.study_active_from = None
            self.study_elapsed_seconds = 0.0
            self.state = {}
            log_skipped_sessions(self.schedule, app=self)
            save_state(self.state)
            self.session_end_notified = False
            self.last_notified_session_idx = idx  # Update for new session
            self._pause_waste_carry = 0.0
            self._unregistered_waste_carry = 0.0
            if is_active:
                # Session start notification
                try:
                    session_name = self.schedule[idx][0] if idx is not None else "Unknown"
                    st_dt = self.session_start_datetime
                    en_dt = self.session_end_datetime
                    if st_dt and en_dt:
                        scheduled = f"{st_dt.strftime('%I:%M %p').lstrip('0')} ‚Äì {en_dt.strftime('%I:%M %p').lstrip('0')}"
                    else:
                        scheduled = "N/A"
                    # ---- ONLY SEND IF NOT SUPPRESSED ----
                    if not getattr(self, "suppress_next_session_telegram", False):
                        self.send_telegram(
                            f"‚úÖ Session started: {session_name}\n"
                            f"‚è∞ Scheduled: {scheduled}"
                        )  
                    self.suppress_next_session_telegram = False
                except Exception as e:
                    print("Failed to send session start Telegram notification:", e)
                self.display_session(idx)
            else:
                self.display_no_active_session()

        # --- Studied & wastage time calculation ---
        today_study = get_today_studied_seconds_actual(self.schedule)
        today_waste = 0
        today_str = datetime.now().strftime("%Y-%m-%d")
        resets = load_reset_wastage()
        reset_sessions = resets.get(today_str, [])
       
        load_wastage_log()
        backfill_gap_days(self.schedule, app=self, plan_name=self.current_plan_name)
        for entry in wastage_log:
            if entry["Date"] == today_str:
                if entry["Session"] in reset_sessions:
                    continue  # skip if reset
                today_waste += parse_hhmmss(entry["Wastage (hh:mm:ss)"])
        # Total
        total_study = get_total_stopwatch_studied()
        summary = self.update_wastage_day_summary()
        self.update_wastage_labels()
        self._update_total_study_label_live()

        # --- SESSION END NOTIFICATION ---
        if is_active and after_session and not self.session_end_notified:
            print("Session ended block running!")   # <--- DEBUG PRINT HERE
            try:
                session_name = self.schedule[idx][0] if idx is not None else "Unknown"
                st_dt = self.session_start_datetime
                en_dt = self.session_end_datetime
                if st_dt and en_dt:
                    scheduled = f"{st_dt.strftime('%I:%M %p').lstrip('0')} ‚Äì {en_dt.strftime('%I:%M %p').lstrip('0')}"
                else:
                    scheduled = "N/A"
                self.send_telegram(
                    f"‚ùå Session ended: {session_name}\n"
                    f"‚è∞ Scheduled: {scheduled}"
                )
                print("Telegram session end notification sent!")  # DEBUG
            except Exception as e:
                print("Failed to send session end Telegram notification:", e)
            self.session_end_notified = True

        # Timer UI
        if not is_active:
            self.status_label.config(text="No active session now. Timers are frozen.", foreground="blue")
            self.timer_display.config(text="Elapsed: 00:00:00.00")
            self.remain_display.config(text="Remaining: 00:00:00.00")
            self.start_btn.config(state=tk.DISABLED)
            self.pause_btn.config(state=tk.DISABLED, text="Pause")
        elif in_break:
            self.status_label.config(text="Paused for break.", foreground="blue")
            if self.elapsed_timer_enabled and self.study_active_from:
                self.study_elapsed_seconds += (now - self.study_active_from).total_seconds()
                self.study_active_from = None
            elapsed = self.study_elapsed_seconds if self.registered and self.elapsed_timer_enabled else 0.0
            self.timer_display.config(text=f"Elapsed: {format_time_centi(elapsed)}")
            remain_centi = (self.session_end_datetime - now).total_seconds()
            remain_centi = max(int(remain_centi * 100), 0)
            remain_text = format_time_centi(remain_centi / 100)
            self.remain_display.config(text=f"Remaining: {remain_text}")
            self.pause_btn.config(state=tk.DISABLED)
        elif after_session:
            print("==> In after_session block")
            if self.study_elapsed_seconds > 0:
                self.total_studied_time += self.study_elapsed_seconds
                self.study_elapsed_seconds = 0.0
            self.status_label.config(text="Session ended. Timers are frozen.", foreground="red")
            self.elapsed_timer_enabled = False
            self.registered = False
            self.timer_display.config(text="Elapsed: 00:00:00.00")
            self.remain_display.config(text=f"Remaining: 00:00:00.00")
            self.start_btn.config(state=tk.DISABLED)
            self.pause_btn.config(state=tk.DISABLED, text="Pause")
            self.state = {}
            save_state(self.state)
        else:
            # ‚úÖ ALWAYS calculate remaining time from current time (ignore pause state)
            remain_centi_val = (self.session_end_datetime - now).total_seconds()
            remain_centi_val = max(remain_centi_val, 0)
            
            # Only pause elapsed timer, not remaining timer
            if self.registered and self.elapsed_timer_enabled and not self.paused and self.study_active_from:
                elapsed = self.study_elapsed_seconds + (now - self.study_active_from).total_seconds()
                self.status_label.config(text="Running...", foreground="green")
            else:
                elapsed = self.study_elapsed_seconds if self.registered and self.elapsed_timer_enabled else 0.0
                if not self.elapsed_timer_enabled:
                    self.status_label.config(text="Click To Start Button", foreground="blue")
                elif self.paused:
                    self.status_label.config(text="Study paused.", foreground="orange")

            self.timer_display.config(text=f"Elapsed: {format_time_centi(elapsed)}")
            
            # ‚úÖ FIX: Always show live remaining time, ignore pause state for remaining timer
            remain_text = format_time_centi(remain_centi_val)
            self.remain_display.config(text=f"Remaining: {remain_text}")

            self.start_btn.config(state=tk.NORMAL if not self.registered else tk.DISABLED)
            self.pause_btn.config(state=tk.NORMAL if self.registered else tk.DISABLED, text="Resume" if self.paused else "Pause")
            
        # --- BREAK LABEL LIVE UPDATE ---
        if is_active:
            sess = self.schedule[idx]
            # If current session break is "No Break" or blank, show nothing
            if sess[3].strip().lower() == "no break" or not sess[3].strip():
                self.break_label.config(text="No break scheduled", foreground="gray")
            elif "-" in sess[3]:
                brk_start, brk_end = sess[3].split("-")
                brk_start_dt = parse_time(brk_start.strip())
                brk_end_dt = parse_time(brk_end.strip())
                
                # Check if parsing was successful
                if brk_start_dt is None or brk_end_dt is None:
                    self.break_label.config(text="Invalid break time format", foreground="orange")
                else:
                    now_time = now.time()
                    brk_disp = f"{to_12hour(brk_start_dt)} ‚Äì {to_12hour(brk_end_dt)}"
                    # Only highlight red if right now is during the break slot
                    if brk_start_dt <= now_time <= brk_end_dt:
                        self.break_label.config(text=f"Break Now: {brk_disp}", foreground="red")
                    else:
                        self.break_label.config(text=f"Break: {brk_disp}", foreground="black")
            else:
                self.break_label.config(text="")
       
        try:
            act_ratio = self._actual_ratio_now()
            act_min_equiv = int(round(act_ratio * 60))
            if hasattr(self, "actual_rate_var"):
                self.actual_rate_var.set(self._fmt_hhmm(act_min_equiv))
            if hasattr(self, "red_light"):
                self.red_light.blink(act_ratio > self._required_ratio_fixed())
        except Exception as e:
            print("[RATE] live update:", e)
        self.after(100, self.update_timer)

    def toggle_pause(self):
        if not self.registered or self.active_session_idx is None:
            return
        now = datetime.now()
        
        # ‚úÖ DEBUG: Let's see what's happening
        print(f"[DEBUG] toggle_pause called")
        print(f"[DEBUG] elapsed_timer_enabled: {getattr(self, 'elapsed_timer_enabled', 'NOT SET')}")
        print(f"[DEBUG] study_active_from: {getattr(self, 'study_active_from', 'NOT SET')}")
        print(f"[DEBUG] current self.paused: {getattr(self, 'paused', 'NOT SET')}")
        
        # ‚úÖ FIX: Force correct initial state
        if hasattr(self, 'elapsed_timer_enabled') and self.elapsed_timer_enabled:
            # Check if elapsed timer is running
            has_study_active = hasattr(self, 'study_active_from')
            study_active_value = getattr(self, 'study_active_from', None)
            elapsed_timer_running = (has_study_active and study_active_value is not None)
            
            print(f"[DEBUG] elapsed_timer_running: {elapsed_timer_running}")
            
            # If elapsed timer is NOT running, we should be paused
            if not elapsed_timer_running:
                print("[DEBUG] Elapsed timer not running - should be PAUSED")
                self.paused = True
                self.pause_btn.config(image=self.resume_img)
                print("[DEBUG] Set button to RESUME image")
            else:
                print("[DEBUG] Elapsed timer running - should be RUNNING") 
                self.paused = False
                self.pause_btn.config(image=self.pause_img)
                print("[DEBUG] Set button to PAUSE image")
        
        print(f"[DEBUG] After sync - self.paused: {self.paused}")
        
        if not self.paused:
            # === STARTING PAUSE (Only pause elapsed timer) ===
            self.paused = True
            
            # Google Sheets sync
            try:
                if getattr(self, "_sheet_sync", None):
                    name = (_load_profile().get("user_name", "") or "User")
                    th, wh, onl, tgt = self._sheet_get_stats()
                    # paused => Offline
                    self._sheet_sync.update(name=name, today_hours=th, week_hours=wh, online=False, today_target=tgt)
            except Exception as _e:
                print("[GSYNC] pause push failed:", _e)
            
            self._pause_waste_carry = 0.0
            
            # ‚úÖ FIXED: When pausing, show RESUME image (so user can resume)
            self.pause_btn.config(image=self.resume_img)
            self.status_label.config(text="Study paused. Timer continues.", foreground="orange")
            
            # ‚úÖ ONLY PAUSE ELAPSED TIMER - Don't touch remaining timer
            if self.elapsed_timer_enabled and self.study_active_from:
                self.study_elapsed_seconds += (now - self.study_active_from).total_seconds()
                self.study_active_from = None  # Stop elapsed timer
                
            # ‚úÖ REMOVED: Don't freeze the remaining timer - let it keep counting down
            # self.remaining_visual_freeze = True
            # self.remaining_visual_frozen_value = (self.session_end_datetime - now).total_seconds()
            # self.remaining_visual_frozen_value = max(self.remaining_visual_frozen_value, 0)
            
            self.pause_start_time = now
            self.pause_start = now
            
            # ‚úÖ SAVE immediately when pausing
            set_today_studied_elapsed(self.today_study_stopwatch_seconds, plan_name=self.current_plan_name)
            
            # === CREATE WASTAGE ROW IMMEDIATELY WITH CORRECT DATE ===
            idx = self.active_session_idx
            if idx is not None and not is_on_break(now, idx, self.schedule):
                session_name = self.schedule[idx][0]
                st_dt, en_dt = get_session_datetimes(self.schedule[idx][1], self.schedule[idx][2], now)
                
                # ‚úÖ KEY FIX: Use TODAY'S date for the scheduled time
                today = now.date()
                scheduled_today = datetime.combine(today, st_dt.time()).strftime("%d-%b-%Y %I:%M %p")
                
                # Create initial wastage entry with 0 seconds (will be updated as time progresses)
                add_or_update_wastage(session_name, scheduled_today, "PAUSED", 0, missed="No", app=self)
                print(f"[PAUSE] Created initial wastage row for {session_name} on {today} at {now.strftime('%H:%M:%S')}")
                
                # Force refresh to show the new row immediately
                if hasattr(self, "refresh_wastage"):
                    self.refresh_wastage()
                    
        else:
            # === RESUMING FROM PAUSE (Only resume elapsed timer) ===
            self.paused = False
            
            # Google Sheets sync
            try:
                if getattr(self, "_sheet_sync", None):
                    name = (_load_profile().get("user_name", "") or "User")
                    th, wh, onl, tgt = self._sheet_get_stats()
                    # running => Online
                    self._sheet_sync.update(name=name, today_hours=th, week_hours=wh, online=True, today_target=tgt)
            except Exception as _e:
                print("[GSYNC] resume push failed:", _e)
            
            self._pause_waste_carry = 0.0
            
            # ‚úÖ FIXED: When resuming, show PAUSE image (so user can pause again)
            self.pause_btn.config(image=self.pause_img)
            self.status_label.config(text="Study resumed.", foreground="green")

            # ‚úÖ ONLY RESUME ELAPSED TIMER - remaining timer was never paused
            if self.elapsed_timer_enabled:
                self.study_active_from = datetime.now()  # Restart elapsed timer
                
            # ‚úÖ REMOVED: remaining timer was never frozen, so don't unfreeze
            # self.remaining_visual_freeze = False
            
            if self.pause_start is not None:
                pause_dur = (datetime.now() - self.pause_start).total_seconds()

                # --- Pause credit logic ---
                if hasattr(self, "pause_credit_seconds"):
                    if self.pause_credit_seconds > 0:
                        if pause_dur <= self.pause_credit_seconds:
                            self.pause_credit_seconds -= pause_dur
                            self.update_pause_credit_label()
                            pause_dur = 0
                        else:
                            pause_dur -= self.pause_credit_seconds
                            self.pause_credit_seconds = 0
                            self.update_pause_credit_label()
                            
            self.pause_start = None
            
            # Force refresh after resume to update display
            if hasattr(self, "refresh_wastage"):
                self.refresh_wastage()
            if hasattr(self, "update_wastage_labels"):
                self.update_wastage_labels()
                
    def display_session(self, idx):
        # --- Called when a study session is running ---
        # ‚úÖ Safety check
        if not self.schedule or idx >= len(self.schedule):
            self.display_no_active_session()
            return
        sess = self.schedule[idx]
        session_name, start_str, end_str, break_str = sess
        st_dt, en_dt = get_session_datetimes(start_str, end_str)
        brk_disp = "--"
        if "-" in break_str:
            brk_start, brk_end = break_str.split("-")
            brk_start_12 = to_12hour(parse_time(brk_start.strip()))
            brk_end_12 = to_12hour(parse_time(brk_end.strip()))
            brk_disp = f"{brk_start_12} ‚Äì {brk_end_12}"

        self.session_label.config(text=f"Session: {session_name}", font=("Arial", 18, "bold"))
        self.time_label.config(
            text=f"Scheduled: {to_12hour(parse_time(start_str))} ‚Äì {to_12hour(parse_time(end_str))}",
            font=("Arial", 15)
        )
        self.break_label.config(
            text=f"Break: {brk_disp}",
            font=("Arial", 15)
        )
        self.status_label.config(
            text="Click Register to start elapsed timer.",
            foreground="#2976D9"
        )
        self.timer_display.config(text="Elapsed: 00:00:00.00")
        self.remain_display.config(text=f"Remaining: {format_time_centi((en_dt - datetime.now()).total_seconds())}")
        self.start_btn.config(state=tk.NORMAL)
        self.pause_btn.config(state=tk.DISABLED, text="Pause")
        self.study_active_from = None

    def display_no_active_session(self):      
        
        # --- Called when it's break time or no session is running ---
        from datetime import datetime, timedelta
        now = datetime.now()
        schedule = self.schedule
        break_found = False

        for i, sess in enumerate(schedule):
            if is_on_break(now, i, schedule):
                break_found = True
                # Parse break time
                brk_start_str, brk_end_str = sess[3].split('-')
                brk_start = brk_start_str.strip()
                brk_end = brk_end_str.strip()
                # Next session
                next_idx = (i + 1) % len(schedule)
                next_session_name = schedule[next_idx][0]
                # 12-hour format
                brk_start_12 = to_12hour(parse_time(brk_start))
                brk_end_12 = to_12hour(parse_time(brk_end))
                # Break remaining countdown
                today = now.date()
                brk_start_time = parse_time(brk_start)
                brk_end_time = parse_time(brk_end)
                dt_brk_start = datetime.combine(today, brk_start_time)
                dt_brk_end = datetime.combine(today, brk_end_time)
                if dt_brk_end <= dt_brk_start:
                    dt_brk_end += timedelta(days=1)
                remain = int((dt_brk_end - now).total_seconds())
                mins = remain // 60
                secs = remain % 60
                
                # ‚úÖ Show break labels
                self.session_label.config(text="Break Time", font=("Arial", 18, "bold"))
                self.time_label.config(text=f"{brk_start_12} ‚Äì {brk_end_12}", font=("Arial", 15, "bold"))
                self.break_label.config(text=f"Next: {next_session_name}", font=("Arial", 13))  # ‚úÖ Regular font (unbold)
                self.status_label.config(
                    text=f"Break in progress... {mins:02d}:{secs:02d} min left.",
                    foreground="#228B22"
                )
                self.timer_display.config(text="Elapsed: 00:00:00.00")
                self.remain_display.config(text="Remaining: 00:00:00.00")
                self.start_btn.config(state=tk.DISABLED)
                self.pause_btn.config(state=tk.DISABLED, text="Pause")
                self.study_active_from = None
                return  # ‚úÖ Exit here - don't execute the code below

        # ‚úÖ Not in break: Find next upcoming session
        next_session_name = None
        for i, sess in enumerate(schedule):
            sess_start_str = sess[1]
            sess_start_time = parse_time(sess_start_str)
            today = now.date()
            sess_start_dt = datetime.combine(today, sess_start_time)
            
            # If session start is in the future today
            if sess_start_dt > now:
                next_session_name = sess[0]
                break
        
        # If no future session today, get first session (next day)
        if next_session_name is None and len(schedule) > 0:
            next_session_name = schedule[0][0]
        
        # ‚úÖ Clean display for no active session
        self.session_label.config(text="No Active Session", font=("Arial", 18, "bold"))
        self.time_label.config(text="", font=("Arial", 13))  # ‚úÖ Empty instead of "--"
        
        if next_session_name:
            self.break_label.config(text=f"Next: {next_session_name}", font=("Arial", 13))  # ‚úÖ Show next session
        else:
            self.break_label.config(text="", font=("Arial", 13))  # ‚úÖ Empty if no schedule
        
        self.status_label.config(text="No active session now. Timers are frozen.", foreground="blue")
        self.timer_display.config(text="Elapsed: 00:00:00.00")
        self.remain_display.config(text="Remaining: 00:00:00.00")
        self.start_btn.config(state=tk.DISABLED)
        self.pause_btn.config(state=tk.DISABLED, text="Pause")
        self.study_active_from = None
    
from flask import Flask, redirect, url_for, request, Response
import threading

remote_app = Flask(__name__)
study_timer_app_instance = None



from datetime import datetime

def format_time_12hr(time_str):
    """
    Convert 'HH:MM' or 'HH:MM:SS' 24hr string to 'h:MM AM/PM'
    """
    for fmt in ("%H:%M:%S", "%H:%M"):
        try:
            dt = datetime.strptime(time_str, fmt)
            return dt.strftime("%I:%M %p").lstrip("0")  # Removes leading zero
        except ValueError:
            continue
    return time_str  # Return as-is if format unknown

def check_auth(pw):
    return pw == PASSWORD

def authenticate():
    return Response(
        'Login required.', 401,
        {'WWW-Authenticate': 'Basic realm="Login Required"'}
    )

def requires_auth(f):
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.password):
            return authenticate()
        return f(*args, **kwargs)
    decorated.__name__ = f.__name__
    return decorated

@remote_app.route('/')
def home():
    app = study_timer_app_instance
    status = "Unknown"
    pause_btn = ""
    start_btn = ""
    if study_timer_app_instance:
        if getattr(study_timer_app_instance, "registered", False):
            if getattr(study_timer_app_instance, "paused", False):
                status = "<b style='color:red;'>Paused</b>"
                pause_btn = '<a href="/pause"><button style="font-size:2em;width:120px;height:60px;">Resume</button></a>'
            else:
                status = "<b style='color:green;'>Running</b>"
                pause_btn = '<a href="/pause"><button style="font-size:2em;width:120px;height:60px;">Pause</button></a>'
        else:
            status = "<b style='color:gray;'>Not Started</b>"
            start_btn = '<a href="/start"><button style="font-size:2em;width:120px;height:60px;">Start</button></a>'
    idx = getattr(study_timer_app_instance, "running_session_index", None)
    schedule = getattr(study_timer_app_instance, "schedule", [])
    if idx is not None and isinstance(schedule, list) and idx < len(schedule):
        # If schedule is a list of tuples (("session name", ...)), use [0]
        session_name = schedule[idx][0] if isinstance(schedule[idx], (list, tuple)) else str(schedule[idx])
    else:
        session_name = "(No session)"        

    def hhmmss_from_seconds(seconds):
        seconds = int(seconds)
        h = seconds // 3600
        m = (seconds % 3600) // 60
        s = seconds % 60
        return f"{h:02}:{m:02}:{s:02}"

    session_name = "(No session)"
    remaining_str = "--:--:--"
    studied_str = "--:--:--"
    wastage_str = "--:--:--"

    if study_timer_app_instance:
        try:
            idx = getattr(study_timer_app_instance, "active_session_idx", None)
            schedule = getattr(study_timer_app_instance, "schedule", [])
            if idx is not None and isinstance(schedule, list) and idx < len(schedule):
                session_name = schedule[idx][0] if isinstance(schedule[idx], (list, tuple)) else str(schedule[idx])
            else:
                session_name = "(No session)"
        except Exception:
            session_name = "(No session)"  # or just pass

        try:
            remaining = getattr(study_timer_app_instance, "session_remaining_seconds", None)
            if remaining is not None:
                remaining_str = hhmmss_from_seconds(remaining)
        except Exception:
            remaining_str = "--:--:--"
           
        # Studied time
        try:
            studied = getattr(study_timer_app_instance, "today_study_stopwatch_seconds", 0)
            studied_str = hhmmss_from_seconds(studied)
        except Exception:
            studied_str = "--:--:--"

        # Wastage time
        try:
            wastage = study_timer_app_instance.get_today_wastage_seconds()
        except Exception:
            wastage = 0
        wastage_str = hhmmss_from_seconds(wastage)
        
        # Break time: shows only if currently in a break session
        break_time_str = "--:--:--"
        if study_timer_app_instance:
            try:
                break_start, break_end = study_timer_app_instance.get_current_break_time()
                if break_start and break_end:
                    # Convert to 12-hour format
                    break_time_str = f"{format_time_12hr(break_start)} ‚Äì {format_time_12hr(break_end)}"
                else:
                    break_time_str = "--:--:--"
            except Exception:
                break_time_str = "--:--:--"

    return f"""
    <div style='display:flex;justify-content:center;align-items:center;height:80vh;'>
      <div style='
          border-radius:16px;
          box-shadow:0 2px 10px #aaa;
          padding:2em 2.5em;
          background:#fff;
          text-align:center;
          min-width:260px;
      '>
        <h2 style='margin-bottom:1em;font-size:1.5em;font-weight:bold;'>Study Timer Remote</h2>
        <div style='margin-bottom:0.7em;font-size:1.15em;'>
            Status: {status}<br>
            Session: {session_name}<br>
            Remaining: {remaining_str}<br>
            <span style='display:inline-block;margin-top:0.5em;margin-bottom:0.7em;'>
                <b>Scheduled Time:</b> {break_time_str}
            </span><br>
            Today Studied: {studied_str}<br>
            Today Wastage: {wastage_str}
        </div>
        <div style='margin-top:1.5em;'>{pause_btn}{start_btn}</div>
      </div>
    </div>
"""
def remote_start():
    print("Remote START called!")  # Debug
    if study_timer_app_instance:
       study_timer_app_instance.start_session()
    return redirect(url_for('home'))

@remote_app.route('/pause')
@requires_auth
def remote_pause():
    if study_timer_app_instance:
        study_timer_app_instance.toggle_pause()
    return redirect(url_for('home'))
    
@remote_app.route('/start')
def remote_start():
    if study_timer_app_instance:
        study_timer_app_instance.start_session()  # <<--- USE YOUR REAL START LOGIC
    return redirect(url_for('home'))

def run_remote_server():
    remote_app.run(host='0.0.0.0', port=5000, debug=False)

def launch_remote_control(app_instance):
    global study_timer_app_instance
    study_timer_app_instance = app_instance
    threading.Thread(target=run_remote_server, daemon=True).start()
    

import traceback

# ---------- Profile badge (top-left) -----------------
class ProfileBadge(ttk.Frame):
    """Small profile widget with circular avatar, name, and tiny edit button."""
    def __init__(self, app, master):
        super().__init__(master)
        self.app = app
        self.configure(borderwidth=0)

        self.pic  = tk.Label(self, bd=0, highlightthickness=0)
        self.name = ttk.Label(self, text="You", font=("Segoe UI", 10, "bold"))
        # Create the button with one name
        self.edit = ttk.Button(self, text="‚úé", width=2, command=self._edit, takefocus=False)
        # Also store it with another name for the guide
        self.profile_edit_btn = self.edit

        self.pic.grid(row=0, column=0, padx=(0,6))
        self.name.grid(row=0, column=1, padx=(0,6))
        self.edit.grid(row=0, column=2)

        self._photo = None  # keep a strong ref to PhotoImage
        self.refresh()      # initial paint

    def refresh(self):
        """Read profile.json and repaint name + avatar."""
        import os
        prof = _load_profile()
        self.name.configure(text=(prof.get("user_name") or "You"))

        path = prof.get("avatar_path") or ""
        try:
            if path and os.path.isfile(path):
                from PIL import Image, ImageTk, ImageDraw
                im = Image.open(path).convert("RGBA").resize((22, 22))
                m  = Image.new("L", (22,22), 0)
                ImageDraw.Draw(m).ellipse((0,0,22,22), fill=255)
                av = Image.new("RGBA", (22,22), (0,0,0,0))
                av.paste(im, (0,0), m)
                self._photo = ImageTk.PhotoImage(av)
                self.pic.configure(image=self._photo)
            else:
                self.pic.configure(image="")
                self._photo = None
        except Exception:
            self.pic.configure(image="")
            self._photo = None

    def _edit(self):
        # Open the setup wizard to change name/avatar
        try:
            OnboardingWizard(self.app)
        except Exception as e:
            print("[PROFILE] open wizard error:", e)
            
def test_weekly_reset():
    """Test the weekly reset system"""
    try:
        reset_manager = WeeklyResetManager(
            LB_CREDENTIALS, LB_SHEET_ID, LB_WORKSHEET
        )
        
        print(f"Current week: {reset_manager.get_current_week_key()}")
        print(f"Last reset: {reset_manager.get_last_reset_week()}")
        
        # Force a reset for testing
        success = reset_manager.perform_weekly_reset()
        print(f"Reset result: {success}")
        
        return success
    except Exception as e:
        print(f"Test failed: {e}")
        return False 
        
if __name__ == "__main__":
    
  
    # Run weekly reset test once
    app_paths.migrate_existing_data()
    result = test_weekly_reset()
    print("Weekly reset test passed!" if result else "Weekly reset test failed.")

    try:
        # Check Razorpay
        try:
            import razorpay
            print("[PAYMENT] Razorpay library available")
        except ImportError:
            print("[PAYMENT] WARNING: Razorpay library not installed")

        # LAUNCH DIRECTLY WITHOUT SEPARATE AUTH WINDOW
        app = StudyTimerApp()
        
        # Optional: Try to load auth data if exists
        try:
            user_config_file = os.path.join(os.getenv('APPDATA'), 'StudyTimer', 'user_config.json')
            if os.path.exists(user_config_file):
                with open(user_config_file, 'r') as f:
                    app.auth_user_data = json.load(f)
                    print(f"[AUTH] ‚úì Loaded: {app.auth_user_data.get('email', 'Unknown')}")
        except Exception as e:
            print(f"[AUTH] No existing auth: {e}")
            app.auth_user_data = None
        
        # Import app_paths to get profile file location
       
        # Add auto-updater with profile path
        app = add_auto_update_to_app(
            app, 
            CURRENT_VERSION,
            profile_path=app_paths.profile_file
        )

        # Optional: Add payment menu
        try:
            app.add_payment_menu()
        except Exception:
            pass

        # Start remote control if available
        try:
            launch_remote_control(app)
        except NameError:
            pass

        # Run Tkinter loop
        app.mainloop()

    except Exception as e:
        import tkinter.messagebox as mbox
        import traceback
        mbox.showerror("Error", f"{e}\n\n{traceback.format_exc()}")

        
